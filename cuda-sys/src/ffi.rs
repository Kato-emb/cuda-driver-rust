/* automatically generated by rust-bindgen 0.71.1 */

pub type cuuint32_t = u32;
pub type cuuint64_t = u64;
pub type CUdeviceptr_v2 = ::std::ffi::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::std::ffi::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlib_st {
    _unused: [u8; 0],
}
pub type CUlibrary = *mut CUlib_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUkern_st {
    _unused: [u8; 0],
}
pub type CUkernel = *mut CUkern_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUtexref_st {
    _unused: [u8; 0],
}
pub type CUtexref = *mut CUtexref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUsurfref_st {
    _unused: [u8; 0],
}
pub type CUsurfref = *mut CUsurfref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
pub type CUtexObject_v1 = ::std::ffi::c_ulonglong;
pub type CUtexObject = CUtexObject_v1;
pub type CUsurfObject_v1 = ::std::ffi::c_ulonglong;
pub type CUsurfObject = CUsurfObject_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type CUmemoryPool = *mut CUmemPoolHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type CUuserObject = *mut CUuserObject_st;
pub type CUgraphConditionalHandle = cuuint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphDeviceUpdatableNode_st {
    _unused: [u8; 0],
}
pub type CUgraphDeviceNode = *mut CUgraphDeviceUpdatableNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUasyncCallbackEntry_st {
    _unused: [u8; 0],
}
pub type CUasyncCallbackHandle = *mut CUasyncCallbackEntry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgreenCtx_st {
    _unused: [u8; 0],
}
#[doc = " \\typedef typedef struct CUgreenCtx_st* CUgreenCtx\n A green context handle. This handle can be used safely from only one CPU thread at a time.\n Created via [cuGreenCtxCreate](crate::ffi::cuGreenCtxCreate)\n"]
pub type CUgreenCtx = *mut CUgreenCtx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::ffi::c_char; 16usize],
}
pub type CUuuid = CUuuid_st;
#[doc = " Fabric handle - An opaque handle representing a memory allocation\n that can be exported to processes in same or different nodes. For IPC\n between processes on different nodes they must be connected via the\n NVSwitch fabric.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemFabricHandle_st {
    pub data: [::std::ffi::c_uchar; 64usize],
}
#[doc = " Fabric handle - An opaque handle representing a memory allocation\n that can be exported to processes in same or different nodes. For IPC\n between processes on different nodes they must be connected via the\n NVSwitch fabric.\n"]
pub type CUmemFabricHandle_v1 = CUmemFabricHandle_st;
#[doc = " Fabric handle - An opaque handle representing a memory allocation\n that can be exported to processes in same or different nodes. For IPC\n between processes on different nodes they must be connected via the\n NVSwitch fabric.\n"]
pub type CUmemFabricHandle = CUmemFabricHandle_v1;
#[doc = " CUDA IPC event handle\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUipcEventHandle_st {
    pub reserved: [::std::ffi::c_char; 64usize],
}
#[doc = " CUDA IPC event handle\n"]
pub type CUipcEventHandle_v1 = CUipcEventHandle_st;
#[doc = " CUDA IPC event handle\n"]
pub type CUipcEventHandle = CUipcEventHandle_v1;
#[doc = " CUDA IPC mem handle\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUipcMemHandle_st {
    pub reserved: [::std::ffi::c_char; 64usize],
}
#[doc = " CUDA IPC mem handle\n"]
pub type CUipcMemHandle_v1 = CUipcMemHandle_st;
#[doc = " CUDA IPC mem handle\n"]
pub type CUipcMemHandle = CUipcMemHandle_v1;
#[repr(u32)]
#[doc = " CUDA Ipc Mem Flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUipcMem_flags_enum {
    #[doc = "< Automatically enable peer access between remote devices as needed\n"]
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1,
}
#[doc = " CUDA Ipc Mem Flags\n"]
pub use self::CUipcMem_flags_enum as CUipcMem_flags;
#[repr(u32)]
#[doc = " CUDA Mem Attach Flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemAttach_flags_enum {
    #[doc = "< Memory can be accessed by any stream on any device\n"]
    CU_MEM_ATTACH_GLOBAL = 1,
    #[doc = "< Memory cannot be accessed by any stream on any device\n"]
    CU_MEM_ATTACH_HOST = 2,
    #[doc = "< Memory can only be accessed by a single stream on the associated device\n"]
    CU_MEM_ATTACH_SINGLE = 4,
}
#[doc = " CUDA Mem Attach Flags\n"]
pub use self::CUmemAttach_flags_enum as CUmemAttach_flags;
impl CUctx_flags_enum {
    pub const CU_CTX_BLOCKING_SYNC: CUctx_flags_enum = CUctx_flags_enum::CU_CTX_SCHED_BLOCKING_SYNC;
}
#[repr(u32)]
#[doc = " Context creation flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUctx_flags_enum {
    #[doc = "< Automatic scheduling\n"]
    CU_CTX_SCHED_AUTO = 0,
    #[doc = "< Set spin as default scheduling\n"]
    CU_CTX_SCHED_SPIN = 1,
    #[doc = "< Set yield as default scheduling\n"]
    CU_CTX_SCHED_YIELD = 2,
    #[doc = "< Set blocking synchronization as default scheduling\n"]
    CU_CTX_SCHED_BLOCKING_SYNC = 4,
    CU_CTX_SCHED_MASK = 7,
    #[doc = "< \\deprecated This flag was deprecated as of CUDA 11.0\n  and it no longer has any effect. All contexts\n  as of CUDA 3.2 behave as though the flag is enabled.\n"]
    CU_CTX_MAP_HOST = 8,
    #[doc = "< Keep local memory allocation after launch\n"]
    CU_CTX_LMEM_RESIZE_TO_MAX = 16,
    #[doc = "< Trigger coredumps from exceptions in this context\n"]
    CU_CTX_COREDUMP_ENABLE = 32,
    #[doc = "< Enable user pipe to trigger coredumps in this context\n"]
    CU_CTX_USER_COREDUMP_ENABLE = 64,
    #[doc = "< Ensure synchronous memory operations on this context will synchronize\n"]
    CU_CTX_SYNC_MEMOPS = 128,
    CU_CTX_FLAGS_MASK = 255,
}
#[doc = " Context creation flags\n"]
pub use self::CUctx_flags_enum as CUctx_flags;
#[repr(u32)]
#[doc = " Event sched flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUevent_sched_flags_enum {
    #[doc = "< Automatic scheduling\n"]
    CU_EVENT_SCHED_AUTO = 0,
    #[doc = "< Set spin as default scheduling\n"]
    CU_EVENT_SCHED_SPIN = 1,
    #[doc = "< Set yield as default scheduling\n"]
    CU_EVENT_SCHED_YIELD = 2,
    #[doc = "< Set blocking synchronization as default scheduling\n"]
    CU_EVENT_SCHED_BLOCKING_SYNC = 4,
}
#[doc = " Event sched flags\n"]
pub use self::CUevent_sched_flags_enum as CUevent_sched_flags;
#[repr(u32)]
#[doc = " Stream creation flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstream_flags_enum {
    #[doc = "< Default stream flag\n"]
    CU_STREAM_DEFAULT = 0,
    #[doc = "< Stream does not synchronize with stream 0 (the NULL stream)\n"]
    CU_STREAM_NON_BLOCKING = 1,
}
#[doc = " Stream creation flags\n"]
pub use self::CUstream_flags_enum as CUstream_flags;
#[repr(u32)]
#[doc = " Event creation flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUevent_flags_enum {
    #[doc = "< Default event flag\n"]
    CU_EVENT_DEFAULT = 0,
    #[doc = "< Event uses blocking synchronization\n"]
    CU_EVENT_BLOCKING_SYNC = 1,
    #[doc = "< Event will not record timing data\n"]
    CU_EVENT_DISABLE_TIMING = 2,
    #[doc = "< Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must be set\n"]
    CU_EVENT_INTERPROCESS = 4,
}
#[doc = " Event creation flags\n"]
pub use self::CUevent_flags_enum as CUevent_flags;
#[repr(u32)]
#[doc = " Event record flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUevent_record_flags_enum {
    #[doc = "< Default event record flag\n"]
    CU_EVENT_RECORD_DEFAULT = 0,
    #[doc = "< When using stream capture, create an event record node\n  instead of the default behavior.  This flag is invalid\n  when used outside of capture.\n"]
    CU_EVENT_RECORD_EXTERNAL = 1,
}
#[doc = " Event record flags\n"]
pub use self::CUevent_record_flags_enum as CUevent_record_flags;
#[repr(u32)]
#[doc = " Event wait flags\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUevent_wait_flags_enum {
    #[doc = "< Default event wait flag\n"]
    CU_EVENT_WAIT_DEFAULT = 0,
    #[doc = "< When using stream capture, create an event wait node\n  instead of the default behavior.  This flag is invalid\n  when used outside of capture.\n"]
    CU_EVENT_WAIT_EXTERNAL = 1,
}
#[doc = " Event wait flags\n"]
pub use self::CUevent_wait_flags_enum as CUevent_wait_flags;
#[repr(u32)]
#[doc = " Flags for [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32) and [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstreamWaitValue_flags_enum {
    #[doc = "< Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit\nvalues). Note this is a cyclic comparison which ignores wraparound.\n(Default behavior.)\n"]
    CU_STREAM_WAIT_VALUE_GEQ = 0,
    #[doc = "< Wait until *addr == value.\n"]
    CU_STREAM_WAIT_VALUE_EQ = 1,
    #[doc = "< Wait until (*addr & value) != 0.\n"]
    CU_STREAM_WAIT_VALUE_AND = 2,
    #[doc = "< Wait until ~(*addr | value) != 0. Support for this operation can be\nqueried with [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)() and\n[CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR).\n"]
    CU_STREAM_WAIT_VALUE_NOR = 3,
    #[doc = "< Follow the wait operation with a flush of outstanding remote writes. This\nmeans that, if a remote write operation is guaranteed to have reached the\ndevice before the wait can be satisfied, that write is guaranteed to be\nvisible to downstream device work. The device is permitted to reorder\nremote writes internally. For example, this flag would be required if\ntwo remote writes arrive in a defined order, the wait is satisfied by the\nsecond write, and downstream work needs to observe the first write.\nSupport for this operation is restricted to selected platforms and can be\nqueried with [CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES).\n"]
    CU_STREAM_WAIT_VALUE_FLUSH = 1073741824,
}
#[doc = " Flags for [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32) and [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64)\n"]
pub use self::CUstreamWaitValue_flags_enum as CUstreamWaitValue_flags;
#[repr(u32)]
#[doc = " Flags for [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstreamWriteValue_flags_enum {
    #[doc = "< Default behavior\n"]
    CU_STREAM_WRITE_VALUE_DEFAULT = 0,
    #[doc = "< Permits the write to be reordered with writes which were issued\nbefore it, as a performance optimization. Normally,\n[cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32) will provide a memory fence before the\nwrite, which has similar semantics to\n__threadfence_system() but is scoped to the stream\nrather than a CUDA thread.\nThis flag is not supported in the v2 API.\n"]
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 1,
}
#[doc = " Flags for [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32)\n"]
pub use self::CUstreamWriteValue_flags_enum as CUstreamWriteValue_flags;
#[repr(u32)]
#[doc = " Operations for [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstreamBatchMemOpType_enum {
    #[doc = "< Represents a [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32) operation\n"]
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1,
    #[doc = "< Represents a [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32) operation\n"]
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,
    #[doc = "< Represents a [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64) operation\n"]
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4,
    #[doc = "< Represents a [cuStreamWriteValue64](crate::ffi::cuStreamWriteValue64) operation\n"]
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5,
    #[doc = "< Insert a memory barrier of the specified type\n"]
    CU_STREAM_MEM_OP_BARRIER = 6,
    #[doc = "< This has the same effect as [CU_STREAM_WAIT_VALUE_FLUSH](crate::ffi::CU_STREAM_WAIT_VALUE_FLUSH), but as a\nstandalone operation.\n"]
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3,
}
#[doc = " Operations for [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp)\n"]
pub use self::CUstreamBatchMemOpType_enum as CUstreamBatchMemOpType;
#[repr(u32)]
#[doc = " Flags for [cuStreamMemoryBarrier](crate::ffi::cuStreamMemoryBarrier)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstreamMemoryBarrier_flags_enum {
    #[doc = "< System-wide memory barrier.\n"]
    CU_STREAM_MEMORY_BARRIER_TYPE_SYS = 0,
    #[doc = "< Limit memory barrier scope to the GPU.\n"]
    CU_STREAM_MEMORY_BARRIER_TYPE_GPU = 1,
}
#[doc = " Flags for [cuStreamMemoryBarrier](crate::ffi::cuStreamMemoryBarrier)\n"]
pub use self::CUstreamMemoryBarrier_flags_enum as CUstreamMemoryBarrier_flags;
#[doc = " Per-operation parameters for [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp)\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union {
    pub operation: CUstreamBatchMemOpType,
    pub waitValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    pub writeValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    pub flushRemoteWrites: CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    pub memoryBarrier: CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
    pub pad: [cuuint64_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    pub flags: ::std::ffi::c_uint,
    #[doc = "< For driver internal use. Initial value is unimportant.\n"]
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    pub flags: ::std::ffi::c_uint,
    #[doc = "< For driver internal use. Initial value is unimportant.\n"]
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::ffi::c_uint,
}
#[doc = " Per-operation parameters for [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp)\n"]
pub type CUstreamBatchMemOpParams_v1 = CUstreamBatchMemOpParams_union;
#[doc = " Per-operation parameters for [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp)\n"]
pub type CUstreamBatchMemOpParams = CUstreamBatchMemOpParams_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st {
    pub ctx: CUcontext,
    pub count: ::std::ffi::c_uint,
    pub paramArray: *mut CUstreamBatchMemOpParams,
    pub flags: ::std::ffi::c_uint,
}
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS_v1 = CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st;
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS = CUDA_BATCH_MEM_OP_NODE_PARAMS_v1;
#[doc = " Batch memory operation node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st {
    #[doc = "< Context to use for the operations.\n"]
    pub ctx: CUcontext,
    #[doc = "< Number of operations in paramArray.\n"]
    pub count: ::std::ffi::c_uint,
    #[doc = "< Array of batch memory operations.\n"]
    pub paramArray: *mut CUstreamBatchMemOpParams,
    #[doc = "< Flags to control the node.\n"]
    pub flags: ::std::ffi::c_uint,
}
#[doc = " Batch memory operation node parameters\n"]
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS_v2 = CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st;
#[repr(u32)]
#[doc = " Occupancy calculator flag\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUoccupancy_flags_enum {
    #[doc = "< Default behavior\n"]
    CU_OCCUPANCY_DEFAULT = 0,
    #[doc = "< Assume global caching is enabled and cannot be automatically turned off\n"]
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 1,
}
#[doc = " Occupancy calculator flag\n"]
pub use self::CUoccupancy_flags_enum as CUoccupancy_flags;
#[repr(u32)]
#[doc = " Flags for [cuStreamUpdateCaptureDependencies](crate::ffi::cuStreamUpdateCaptureDependencies)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstreamUpdateCaptureDependencies_flags_enum {
    #[doc = "< Add new nodes to the dependency set\n"]
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = 0,
    #[doc = "< Replace the dependency set with the new nodes\n"]
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = 1,
}
#[doc = " Flags for [cuStreamUpdateCaptureDependencies](crate::ffi::cuStreamUpdateCaptureDependencies)\n"]
pub use self::CUstreamUpdateCaptureDependencies_flags_enum as CUstreamUpdateCaptureDependencies_flags;
#[repr(u32)]
#[doc = " Types of async notification that can be sent\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUasyncNotificationType_enum {
    CU_ASYNC_NOTIFICATION_TYPE_OVER_BUDGET = 1,
}
#[doc = " Types of async notification that can be sent\n"]
pub use self::CUasyncNotificationType_enum as CUasyncNotificationType;
#[doc = " Information passed to the user via the async notification callback\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUasyncNotificationInfo_st {
    pub type_: CUasyncNotificationType,
    pub info: CUasyncNotificationInfo_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUasyncNotificationInfo_st__bindgen_ty_1 {
    pub overBudget: CUasyncNotificationInfo_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUasyncNotificationInfo_st__bindgen_ty_1__bindgen_ty_1 {
    pub bytesOverBudget: ::std::ffi::c_ulonglong,
}
#[doc = " Information passed to the user via the async notification callback\n"]
pub type CUasyncNotificationInfo = CUasyncNotificationInfo_st;
#[doc = " CUDA async notification callback\n#### info:\nInformation describing what actions to take as a result of this trim notification.\n#### userData:\nPointer to user defined data provided at registration.\n#### callback:\nThe callback handle associated with this specific callback.\n"]
pub type CUasyncCallback = ::std::option::Option<
    unsafe extern "C" fn(
        info: *mut CUasyncNotificationInfo,
        userData: *mut ::std::ffi::c_void,
        callback: CUasyncCallbackHandle,
    ),
>;
#[repr(u32)]
#[doc = " Array formats\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUarray_format_enum {
    #[doc = "< Unsigned 8-bit integers\n"]
    CU_AD_FORMAT_UNSIGNED_INT8 = 1,
    #[doc = "< Unsigned 16-bit integers\n"]
    CU_AD_FORMAT_UNSIGNED_INT16 = 2,
    #[doc = "< Unsigned 32-bit integers\n"]
    CU_AD_FORMAT_UNSIGNED_INT32 = 3,
    #[doc = "< Signed 8-bit integers\n"]
    CU_AD_FORMAT_SIGNED_INT8 = 8,
    #[doc = "< Signed 16-bit integers\n"]
    CU_AD_FORMAT_SIGNED_INT16 = 9,
    #[doc = "< Signed 32-bit integers\n"]
    CU_AD_FORMAT_SIGNED_INT32 = 10,
    #[doc = "< 16-bit floating point\n"]
    CU_AD_FORMAT_HALF = 16,
    #[doc = "< 32-bit floating point\n"]
    CU_AD_FORMAT_FLOAT = 32,
    #[doc = "< 8-bit YUV planar format, with 4:2:0 sampling\n"]
    CU_AD_FORMAT_NV12 = 176,
    #[doc = "< 1 channel unsigned 8-bit normalized integer\n"]
    CU_AD_FORMAT_UNORM_INT8X1 = 192,
    #[doc = "< 2 channel unsigned 8-bit normalized integer\n"]
    CU_AD_FORMAT_UNORM_INT8X2 = 193,
    #[doc = "< 4 channel unsigned 8-bit normalized integer\n"]
    CU_AD_FORMAT_UNORM_INT8X4 = 194,
    #[doc = "< 1 channel unsigned 16-bit normalized integer\n"]
    CU_AD_FORMAT_UNORM_INT16X1 = 195,
    #[doc = "< 2 channel unsigned 16-bit normalized integer\n"]
    CU_AD_FORMAT_UNORM_INT16X2 = 196,
    #[doc = "< 4 channel unsigned 16-bit normalized integer\n"]
    CU_AD_FORMAT_UNORM_INT16X4 = 197,
    #[doc = "< 1 channel signed 8-bit normalized integer\n"]
    CU_AD_FORMAT_SNORM_INT8X1 = 198,
    #[doc = "< 2 channel signed 8-bit normalized integer\n"]
    CU_AD_FORMAT_SNORM_INT8X2 = 199,
    #[doc = "< 4 channel signed 8-bit normalized integer\n"]
    CU_AD_FORMAT_SNORM_INT8X4 = 200,
    #[doc = "< 1 channel signed 16-bit normalized integer\n"]
    CU_AD_FORMAT_SNORM_INT16X1 = 201,
    #[doc = "< 2 channel signed 16-bit normalized integer\n"]
    CU_AD_FORMAT_SNORM_INT16X2 = 202,
    #[doc = "< 4 channel signed 16-bit normalized integer\n"]
    CU_AD_FORMAT_SNORM_INT16X4 = 203,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC1 compression) format\n"]
    CU_AD_FORMAT_BC1_UNORM = 145,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC1 compression) format with sRGB encoding\n"]
    CU_AD_FORMAT_BC1_UNORM_SRGB = 146,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC2 compression) format\n"]
    CU_AD_FORMAT_BC2_UNORM = 147,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC2 compression) format with sRGB encoding\n"]
    CU_AD_FORMAT_BC2_UNORM_SRGB = 148,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC3 compression) format\n"]
    CU_AD_FORMAT_BC3_UNORM = 149,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC3 compression) format with sRGB encoding\n"]
    CU_AD_FORMAT_BC3_UNORM_SRGB = 150,
    #[doc = "< 1 channel unsigned normalized block-compressed (BC4 compression) format\n"]
    CU_AD_FORMAT_BC4_UNORM = 151,
    #[doc = "< 1 channel signed normalized block-compressed (BC4 compression) format\n"]
    CU_AD_FORMAT_BC4_SNORM = 152,
    #[doc = "< 2 channel unsigned normalized block-compressed (BC5 compression) format\n"]
    CU_AD_FORMAT_BC5_UNORM = 153,
    #[doc = "< 2 channel signed normalized block-compressed (BC5 compression) format\n"]
    CU_AD_FORMAT_BC5_SNORM = 154,
    #[doc = "< 3 channel unsigned half-float block-compressed (BC6H compression) format\n"]
    CU_AD_FORMAT_BC6H_UF16 = 155,
    #[doc = "< 3 channel signed half-float block-compressed (BC6H compression) format\n"]
    CU_AD_FORMAT_BC6H_SF16 = 156,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC7 compression) format\n"]
    CU_AD_FORMAT_BC7_UNORM = 157,
    #[doc = "< 4 channel unsigned normalized block-compressed (BC7 compression) format with sRGB encoding\n"]
    CU_AD_FORMAT_BC7_UNORM_SRGB = 158,
    #[doc = "< 10-bit YUV planar format, with 4:2:0 sampling\n"]
    CU_AD_FORMAT_P010 = 159,
    #[doc = "< 16-bit YUV planar format, with 4:2:0 sampling\n"]
    CU_AD_FORMAT_P016 = 161,
    #[doc = "< 8-bit YUV planar format, with 4:2:2 sampling\n"]
    CU_AD_FORMAT_NV16 = 162,
    #[doc = "< 10-bit YUV planar format, with 4:2:2 sampling\n"]
    CU_AD_FORMAT_P210 = 163,
    #[doc = "< 16-bit YUV planar format, with 4:2:2 sampling\n"]
    CU_AD_FORMAT_P216 = 164,
    #[doc = "< 2 channel, 8-bit YUV packed planar format, with 4:2:2 sampling\n"]
    CU_AD_FORMAT_YUY2 = 165,
    #[doc = "< 2 channel, 10-bit YUV packed planar format, with 4:2:2 sampling\n"]
    CU_AD_FORMAT_Y210 = 166,
    #[doc = "< 2 channel, 16-bit YUV packed planar format, with 4:2:2 sampling\n"]
    CU_AD_FORMAT_Y216 = 167,
    #[doc = "< 4 channel, 8-bit YUV packed planar format, with 4:4:4 sampling\n"]
    CU_AD_FORMAT_AYUV = 168,
    #[doc = "< 10-bit YUV packed planar format, with 4:4:4 sampling\n"]
    CU_AD_FORMAT_Y410 = 169,
    #[doc = "< 4 channel, 12-bit YUV packed planar format, with 4:4:4 sampling\n"]
    CU_AD_FORMAT_Y416 = 177,
    #[doc = "< 3 channel 8-bit YUV planar format, with 4:4:4 sampling\n"]
    CU_AD_FORMAT_Y444_PLANAR8 = 178,
    #[doc = "< 3 channel 10-bit YUV planar format, with 4:4:4 sampling\n"]
    CU_AD_FORMAT_Y444_PLANAR10 = 179,
    #[doc = "< 3 channel 8-bit YUV semi-planar format, with 4:4:4 sampling\n"]
    CU_AD_FORMAT_YUV444_8bit_SemiPlanar = 180,
    #[doc = "< 3 channel 16-bit YUV semi-planar format, with 4:4:4 sampling\n"]
    CU_AD_FORMAT_YUV444_16bit_SemiPlanar = 181,
    #[doc = "< 4 channel unorm R10G10B10A2 RGB format\n"]
    CU_AD_FORMAT_UNORM_INT_101010_2 = 80,
    CU_AD_FORMAT_MAX = 2147483647,
}
#[doc = " Array formats\n"]
pub use self::CUarray_format_enum as CUarray_format;
#[repr(u32)]
#[doc = " Texture reference addressing modes\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUaddress_mode_enum {
    #[doc = "< Wrapping address mode\n"]
    CU_TR_ADDRESS_MODE_WRAP = 0,
    #[doc = "< Clamp to edge address mode\n"]
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    #[doc = "< Mirror address mode\n"]
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    #[doc = "< Border address mode\n"]
    CU_TR_ADDRESS_MODE_BORDER = 3,
}
#[doc = " Texture reference addressing modes\n"]
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[repr(u32)]
#[doc = " Texture reference filtering modes\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUfilter_mode_enum {
    #[doc = "< Point filter mode\n"]
    CU_TR_FILTER_MODE_POINT = 0,
    #[doc = "< Linear filter mode\n"]
    CU_TR_FILTER_MODE_LINEAR = 1,
}
#[doc = " Texture reference filtering modes\n"]
pub use self::CUfilter_mode_enum as CUfilter_mode;
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED;
}
#[repr(u32)]
#[doc = " Device properties\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdevice_attribute_enum {
    #[doc = "< Maximum number of threads per block\n"]
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,
    #[doc = "< Maximum block dimension X\n"]
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,
    #[doc = "< Maximum block dimension Y\n"]
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,
    #[doc = "< Maximum block dimension Z\n"]
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,
    #[doc = "< Maximum grid dimension X\n"]
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,
    #[doc = "< Maximum grid dimension Y\n"]
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,
    #[doc = "< Maximum grid dimension Z\n"]
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,
    #[doc = "< Maximum shared memory available per block in bytes\n"]
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,
    #[doc = "< Memory available on device for __constant__ variables in a CUDA C kernel in bytes\n"]
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,
    #[doc = "< Warp size in threads\n"]
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,
    #[doc = "< Maximum pitch in bytes allowed by memory copies\n"]
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,
    #[doc = "< Maximum number of 32-bit registers available per block\n"]
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,
    #[doc = "< Typical clock frequency in kilohertz\n"]
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    #[doc = "< Alignment requirement for textures\n"]
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    #[doc = "< Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT.\n"]
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,
    #[doc = "< Number of multiprocessors on device\n"]
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    #[doc = "< Specifies whether there is a run time limit on kernels\n"]
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,
    #[doc = "< Device is integrated with host memory\n"]
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    #[doc = "< Device can map host memory into CUDA address space\n"]
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    #[doc = "< Compute mode (See [CUcomputemode](crate::ffi::CUcomputemode) for details)\n"]
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    #[doc = "< Maximum 1D texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,
    #[doc = "< Maximum 2D texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,
    #[doc = "< Maximum 2D texture height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,
    #[doc = "< Maximum 3D texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,
    #[doc = "< Maximum 3D texture height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,
    #[doc = "< Maximum 3D texture depth\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,
    #[doc = "< Maximum 2D layered texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,
    #[doc = "< Maximum 2D layered texture height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,
    #[doc = "< Maximum layers in a 2D layered texture\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,
    #[doc = "< Alignment requirement for surfaces\n"]
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,
    #[doc = "< Device can possibly execute multiple kernels concurrently\n"]
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    #[doc = "< Device has ECC support enabled\n"]
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,
    #[doc = "< PCI bus ID of the device\n"]
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    #[doc = "< PCI device ID of the device\n"]
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    #[doc = "< Device is using TCC driver model\n"]
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    #[doc = "< Peak memory clock frequency in kilohertz\n"]
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    #[doc = "< Global memory bus width in bits\n"]
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    #[doc = "< Size of L2 cache in bytes\n"]
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,
    #[doc = "< Maximum resident threads per multiprocessor\n"]
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,
    #[doc = "< Number of asynchronous engines\n"]
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    #[doc = "< Device shares a unified address space with the host\n"]
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    #[doc = "< Maximum 1D layered texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,
    #[doc = "< Maximum layers in a 1D layered texture\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,
    #[doc = "< Deprecated, do not use.\n"]
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,
    #[doc = "< Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,
    #[doc = "< Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,
    #[doc = "< Alternate maximum 3D texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,
    #[doc = "< Alternate maximum 3D texture height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,
    #[doc = "< Alternate maximum 3D texture depth\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,
    #[doc = "< PCI domain ID of the device\n"]
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    #[doc = "< Pitch alignment requirement for textures\n"]
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    #[doc = "< Maximum cubemap texture width/height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,
    #[doc = "< Maximum cubemap layered texture width/height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,
    #[doc = "< Maximum layers in a cubemap layered texture\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,
    #[doc = "< Maximum 1D surface width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,
    #[doc = "< Maximum 2D surface width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,
    #[doc = "< Maximum 2D surface height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,
    #[doc = "< Maximum 3D surface width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,
    #[doc = "< Maximum 3D surface height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,
    #[doc = "< Maximum 3D surface depth\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,
    #[doc = "< Maximum 1D layered surface width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,
    #[doc = "< Maximum layers in a 1D layered surface\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,
    #[doc = "< Maximum 2D layered surface width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,
    #[doc = "< Maximum 2D layered surface height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,
    #[doc = "< Maximum layers in a 2D layered surface\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,
    #[doc = "< Maximum cubemap surface width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,
    #[doc = "< Maximum cubemap layered surface width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,
    #[doc = "< Maximum layers in a cubemap layered surface\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,
    #[doc = "< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead.\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,
    #[doc = "< Maximum 2D linear texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,
    #[doc = "< Maximum 2D linear texture height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,
    #[doc = "< Maximum 2D linear texture pitch in bytes\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,
    #[doc = "< Maximum mipmapped 2D texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,
    #[doc = "< Maximum mipmapped 2D texture height\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,
    #[doc = "< Major compute capability version number\n"]
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    #[doc = "< Minor compute capability version number\n"]
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    #[doc = "< Maximum mipmapped 1D texture width\n"]
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,
    #[doc = "< Device supports stream priorities\n"]
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,
    #[doc = "< Device supports caching globals in L1\n"]
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,
    #[doc = "< Device supports caching locals in L1\n"]
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,
    #[doc = "< Maximum shared memory available per multiprocessor in bytes\n"]
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,
    #[doc = "< Maximum number of 32-bit registers available per multiprocessor\n"]
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,
    #[doc = "< Device can allocate managed memory on this system\n"]
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    #[doc = "< Device is on a multi-GPU board\n"]
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    #[doc = "< Unique id for a group of devices on the same multi-GPU board\n"]
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
    #[doc = "< Link between the device and the host supports native atomic operations (this is a placeholder attribute, and is not supported on any current hardware)\n"]
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,
    #[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance\n"]
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,
    #[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it\n"]
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU\n"]
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,
    #[doc = "< Device supports compute preemption.\n"]
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,
    #[doc = "< Device can access host registered memory at the same virtual address as the CPU\n"]
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,
    #[doc = "< Deprecated, along with v1 MemOps API, [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp) and related APIs are supported.\n"]
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1 = 92,
    #[doc = "< Deprecated, along with v1 MemOps API, 64-bit operations are supported in [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp) and related APIs.\n"]
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1 = 93,
    #[doc = "< Deprecated, along with v1 MemOps API, [CU_STREAM_WAIT_VALUE_NOR](crate::ffi::CU_STREAM_WAIT_VALUE_NOR) is supported.\n"]
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1 = 94,
    #[doc = "< Device supports launching cooperative kernels via [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel)\n"]
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95,
    #[doc = "< Deprecated, [cuLaunchCooperativeKernelMultiDevice](crate::ffi::cuLaunchCooperativeKernelMultiDevice) is deprecated.\n"]
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96,
    #[doc = "< Maximum optin shared memory per block\n"]
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97,
    #[doc = "< The [CU_STREAM_WAIT_VALUE_FLUSH](crate::ffi::CU_STREAM_WAIT_VALUE_FLUSH) flag and the [CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES](crate::ffi::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES) MemOp are supported on the device. See \\ref CUDA_MEMOP for additional details.\n"]
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98,
    #[doc = "< Device supports host memory registration via [cudaHostRegister](crate::ffi::cudaHostRegister).\n"]
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99,
    #[doc = "< Device accesses pageable memory via the host's page tables.\n"]
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100,
    #[doc = "< The host can directly access managed memory on the device without migration.\n"]
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101,
    #[doc = "< Deprecated, Use CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED\n"]
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = 102,
    #[doc = "< Device supports exporting memory to a posix file descriptor with [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), if requested via [cuMemCreate](crate::ffi::cuMemCreate)\n"]
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = 103,
    #[doc = "< Device supports exporting memory to a Win32 NT handle with [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), if requested via [cuMemCreate](crate::ffi::cuMemCreate)\n"]
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = 104,
    #[doc = "< Device supports exporting memory to a Win32 KMT handle with [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), if requested via [cuMemCreate](crate::ffi::cuMemCreate)\n"]
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105,
    #[doc = "< Maximum number of blocks per multiprocessor\n"]
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = 106,
    #[doc = "< Device supports compression of memory\n"]
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = 107,
    #[doc = "< Maximum L2 persisting lines capacity setting in bytes.\n"]
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = 108,
    #[doc = "< Maximum value of CUaccessPolicyWindow[num_bytes](crate::ffi::num_bytes).\n"]
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = 109,
    #[doc = "< Device supports specifying the GPUDirect RDMA flag with [cuMemCreate](crate::ffi::cuMemCreate)\n"]
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = 110,
    #[doc = "< Shared memory reserved by CUDA driver per block in bytes\n"]
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = 111,
    #[doc = "< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays\n"]
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = 112,
    #[doc = "< Device supports using the [cuMemHostRegister](crate::ffi::cuMemHostRegister) flag [CU_MEMHOSTERGISTER_READ_ONLY](crate::ffi::CU_MEMHOSTERGISTER_READ_ONLY) to register memory that must be mapped as read-only to the GPU\n"]
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113,
    #[doc = "< External timeline semaphore interop is supported on the device\n"]
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = 114,
    #[doc = "< Device supports using the [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) and [cuMemPool](crate::ffi::cuMemPool) family of APIs\n"]
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = 115,
    #[doc = "< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)\n"]
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = 116,
    #[doc = "< The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the [CUflushGPUDirectRDMAWritesOptions](crate::ffi::CUflushGPUDirectRDMAWritesOptions) enum\n"]
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = 117,
    #[doc = "< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See [CUGPUDirectRDMAWritesOrdering](crate::ffi::CUGPUDirectRDMAWritesOrdering) for the numerical values returned here.\n"]
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = 118,
    #[doc = "< Handle types supported with mempool based IPC\n"]
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = 119,
    #[doc = "< Indicates device supports cluster launch\n"]
    CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH = 120,
    #[doc = "< Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays\n"]
    CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED = 121,
    #[doc = "< 64-bit operations are supported in [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp) and related MemOp APIs.\n"]
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 122,
    #[doc = "< [CU_STREAM_WAIT_VALUE_NOR](crate::ffi::CU_STREAM_WAIT_VALUE_NOR) is supported by MemOp APIs.\n"]
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 123,
    #[doc = "< Device supports buffer sharing with dma_buf mechanism.\n"]
    CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED = 124,
    #[doc = "< Device supports IPC Events.\n"]
    CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED = 125,
    #[doc = "< Number of memory domains the device supports.\n"]
    CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT = 126,
    #[doc = "< Device supports accessing memory using Tensor Map.\n"]
    CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED = 127,
    #[doc = "< Device supports exporting memory to a fabric handle with cuMemExportToShareableHandle() or requested with cuMemCreate()\n"]
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED = 128,
    #[doc = "< Device supports unified function pointers.\n"]
    CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS = 129,
    #[doc = "< NUMA configuration of a device: value is of type [CUdeviceNumaConfig](crate::ffi::CUdeviceNumaConfig) enum\n"]
    CU_DEVICE_ATTRIBUTE_NUMA_CONFIG = 130,
    #[doc = "< NUMA node ID of the GPU memory\n"]
    CU_DEVICE_ATTRIBUTE_NUMA_ID = 131,
    #[doc = "< Device supports switch multicast and reduction operations.\n"]
    CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED = 132,
    #[doc = "< Indicates if contexts created on this device will be shared via MPS\n"]
    CU_DEVICE_ATTRIBUTE_MPS_ENABLED = 133,
    #[doc = "< NUMA ID of the host node closest to the device. Returns -1 when system does not support NUMA.\n"]
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID = 134,
    #[doc = "< Device supports CIG with D3D12.\n"]
    CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED = 135,
    #[doc = "< The returned valued shall be interpreted as a bitmask, where the individual bits are described by the [CUmemDecompressAlgorithm](crate::ffi::CUmemDecompressAlgorithm) enum.\n"]
    CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK = 136,
    #[doc = "< The returned valued is the maximum length in bytes of a single decompress operation that is allowed.\n"]
    CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH = 137,
    #[doc = "< The combined 16-bit PCI device ID and 16-bit PCI vendor ID.\n"]
    CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID = 139,
    #[doc = "< The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem vendor ID.\n"]
    CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID = 140,
    #[doc = "< Device supports HOST_NUMA location IPC between nodes in a multi-node system.\n"]
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED = 143,
    CU_DEVICE_ATTRIBUTE_MAX = 144,
}
#[doc = " Device properties\n"]
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[doc = " Legacy device properties\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUdevprop_st {
    #[doc = "< Maximum number of threads per block\n"]
    pub maxThreadsPerBlock: ::std::ffi::c_int,
    #[doc = "< Maximum size of each dimension of a block\n"]
    pub maxThreadsDim: [::std::ffi::c_int; 3usize],
    #[doc = "< Maximum size of each dimension of a grid\n"]
    pub maxGridSize: [::std::ffi::c_int; 3usize],
    #[doc = "< Shared memory available per block in bytes\n"]
    pub sharedMemPerBlock: ::std::ffi::c_int,
    #[doc = "< Constant memory available on device in bytes\n"]
    pub totalConstantMemory: ::std::ffi::c_int,
    #[doc = "< Warp size in threads\n"]
    pub SIMDWidth: ::std::ffi::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies\n"]
    pub memPitch: ::std::ffi::c_int,
    #[doc = "< 32-bit registers available per block\n"]
    pub regsPerBlock: ::std::ffi::c_int,
    #[doc = "< Clock frequency in kilohertz\n"]
    pub clockRate: ::std::ffi::c_int,
    #[doc = "< Alignment requirement for textures\n"]
    pub textureAlign: ::std::ffi::c_int,
}
#[doc = " Legacy device properties\n"]
pub type CUdevprop_v1 = CUdevprop_st;
#[doc = " Legacy device properties\n"]
pub type CUdevprop = CUdevprop_v1;
#[repr(u32)]
#[doc = " Pointer information\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUpointer_attribute_enum {
    #[doc = "< The [CUcontext](crate::ffi::CUcontext) on which a pointer was allocated or registered\n"]
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,
    #[doc = "< The [CUmemorytype](crate::ffi::CUmemorytype) describing the physical location of a pointer\n"]
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    #[doc = "< The address at which a pointer's memory may be accessed on the device\n"]
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    #[doc = "< The address at which a pointer's memory may be accessed on the host\n"]
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    #[doc = "< A pair of tokens for use with the nv-p2p.h Linux kernel interface\n"]
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    #[doc = "< Synchronize every synchronous memory operation initiated on this region\n"]
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    #[doc = "< A process-wide unique ID for an allocated memory region\n"]
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    #[doc = "< Indicates if the pointer points to managed memory\n"]
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    #[doc = "< A device ordinal of a device on which a pointer was allocated or registered\n"]
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
    #[doc = "< 1 if this pointer maps to an allocation that is suitable for [cudaIpcGetMemHandle](crate::ffi::cudaIpcGetMemHandle), 0 otherwise\n"]
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = 10,
    #[doc = "< Starting address for this requested pointer\n"]
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,
    #[doc = "< Size of the address range for this requested pointer\n"]
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = 12,
    #[doc = "< 1 if this pointer is in a valid address range that is mapped to a backing allocation, 0 otherwise\n"]
    CU_POINTER_ATTRIBUTE_MAPPED = 13,
    #[doc = "< Bitmask of allowed [CUmemAllocationHandleType](crate::ffi::CUmemAllocationHandleType) for this allocation\n"]
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,
    #[doc = "< 1 if the memory this pointer is referencing can be used with the GPUDirect RDMA API\n"]
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15,
    #[doc = "< Returns the access flags the device associated with the current context has on the corresponding memory referenced by the pointer given\n"]
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,
    #[doc = "< Returns the mempool handle for the allocation if it was allocated from a mempool. Otherwise returns NULL.\n"]
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17,
    #[doc = "< Size of the actual underlying mapping that the pointer belongs to\n"]
    CU_POINTER_ATTRIBUTE_MAPPING_SIZE = 18,
    #[doc = "< The start address of the mapping that the pointer belongs to\n"]
    CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR = 19,
    #[doc = "< A process-wide unique id corresponding to the physical allocation the pointer belongs to\n"]
    CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID = 20,
    #[doc = "< Returns in `*data` a boolean that indicates whether the pointer points to memory that is capable to be used for hardware accelerated decompression.\n"]
    CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE = 21,
}
#[doc = " Pointer information\n"]
pub use self::CUpointer_attribute_enum as CUpointer_attribute;
#[repr(u32)]
#[doc = " Function properties\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUfunction_attribute_enum {
    #[doc = " The maximum number of threads per block, beyond which a launch of the\n function would fail. This number depends on both the function and the\n device on which the function is currently loaded.\n"]
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    #[doc = " The size in bytes of statically-allocated shared memory required by\n this function. This does not include dynamically-allocated shared\n memory requested by the user at runtime.\n"]
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    #[doc = " The size in bytes of user-allocated constant memory required by this\n function.\n"]
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    #[doc = " The size in bytes of local memory used by each thread of this function.\n"]
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    #[doc = " The number of registers used by each thread of this function.\n"]
    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,
    #[doc = " The PTX virtual architecture version for which the function was\n compiled. This value is the major PTX version * 10 + the minor PTX\n version, so a PTX version 1.3 function would return the value 13.\n Note that this may return the undefined value of 0 for cubins\n compiled prior to CUDA 3.0.\n"]
    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    #[doc = " The binary architecture version for which the function was compiled.\n This value is the major binary version * 10 + the minor binary version,\n so a binary version 1.3 function would return the value 13. Note that\n this will return a value of 10 for legacy cubins that do not have a\n properly-encoded binary architecture version.\n"]
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    #[doc = " The attribute to indicate whether the function has been compiled with\n user specified option \"-Xptxas --dlcm=ca\" set .\n"]
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    #[doc = " The maximum size in bytes of dynamically-allocated shared memory that can be used by\n this function. If the user-specified dynamic shared memory size is larger than this\n value, the launch will fail.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    #[doc = " On devices where the L1 cache and shared memory use the same hardware resources,\n this sets the shared memory carveout preference, in percent of the total shared memory.\n Refer to [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR).\n This is only a hint, and the driver can choose a different ratio if required to execute the function.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    #[doc = " If this attribute is set, the kernel must launch with a valid cluster\n size specified.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET = 10,
    #[doc = " The required cluster width in blocks. The values must either all be 0 or\n all be positive. The validity of the cluster dimensions is otherwise\n checked at launch time.\n\n If the value is set during compile time, it cannot be set at runtime.\n Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH = 11,
    #[doc = " The required cluster height in blocks. The values must either all be 0 or\n all be positive. The validity of the cluster dimensions is otherwise\n checked at launch time.\n\n If the value is set during compile time, it cannot be set at runtime.\n Setting it at runtime should return CUDA_ERROR_NOT_PERMITTED.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT = 12,
    #[doc = " The required cluster depth in blocks. The values must either all be 0 or\n all be positive. The validity of the cluster dimensions is otherwise\n checked at launch time.\n\n If the value is set during compile time, it cannot be set at runtime.\n Setting it at runtime should return CUDA_ERROR_NOT_PERMITTED.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH = 13,
    #[doc = " Whether the function can be launched with non-portable cluster size. 1 is\n allowed, 0 is disallowed. A non-portable cluster size may only function\n on the specific SKUs the program is tested on. The launch might fail if\n the program is run on a different hardware platform.\n\n CUDA API provides cudaOccupancyMaxActiveClusters to assist with checking\n whether the desired size can be launched on the current device.\n\n Portable Cluster Size\n\n A portable cluster size is guaranteed to be functional on all compute\n capabilities higher than the target compute capability. The portable\n cluster size for sm_90 is 8 blocks per cluster. This value may increase\n for future compute capabilities.\n\n The specific hardware unit may support higher cluster sizes thats not\n guaranteed to be portable.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED = 14,
    #[doc = " The block scheduling policy of a function. The value type is\n CUclusterSchedulingPolicy / cudaClusterSchedulingPolicy.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 15,
    #[doc = " The block scheduling policy of a function. The value type is\n CUclusterSchedulingPolicy / cudaClusterSchedulingPolicy.\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute), [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    CU_FUNC_ATTRIBUTE_MAX = 16,
}
#[doc = " Function properties\n"]
pub use self::CUfunction_attribute_enum as CUfunction_attribute;
#[repr(u32)]
#[doc = " Function cache configurations\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUfunc_cache_enum {
    #[doc = "< no preference for shared memory or L1 (default)\n"]
    CU_FUNC_CACHE_PREFER_NONE = 0,
    #[doc = "< prefer larger shared memory and smaller L1 cache\n"]
    CU_FUNC_CACHE_PREFER_SHARED = 1,
    #[doc = "< prefer larger L1 cache and smaller shared memory\n"]
    CU_FUNC_CACHE_PREFER_L1 = 2,
    #[doc = "< prefer equal sized L1 cache and shared memory\n"]
    CU_FUNC_CACHE_PREFER_EQUAL = 3,
}
#[doc = " Function cache configurations\n"]
pub use self::CUfunc_cache_enum as CUfunc_cache;
#[repr(u32)]
#[doc = " \\deprecated\n\n Shared memory configurations\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUsharedconfig_enum {
    #[doc = "< set default shared memory bank size\n"]
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = 0,
    #[doc = "< set shared memory bank width to four bytes\n"]
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = 1,
    #[doc = "< set shared memory bank width to eight bytes\n"]
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 2,
}
#[doc = " \\deprecated\n\n Shared memory configurations\n"]
pub use self::CUsharedconfig_enum as CUsharedconfig;
#[repr(i32)]
#[doc = " Shared memory carveout configurations. These may be passed to [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute) or [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUshared_carveout_enum {
    #[doc = "< No preference for shared memory or L1 (default)\n"]
    CU_SHAREDMEM_CARVEOUT_DEFAULT = -1,
    #[doc = "< Prefer maximum available shared memory, minimum L1 cache\n"]
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100,
    #[doc = "< Prefer maximum available L1 cache, minimum shared memory\n"]
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0,
}
#[doc = " Shared memory carveout configurations. These may be passed to [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute) or [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
pub use self::CUshared_carveout_enum as CUshared_carveout;
#[repr(u32)]
#[doc = " Memory types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemorytype_enum {
    #[doc = "< Host memory\n"]
    CU_MEMORYTYPE_HOST = 1,
    #[doc = "< Device memory\n"]
    CU_MEMORYTYPE_DEVICE = 2,
    #[doc = "< Array memory\n"]
    CU_MEMORYTYPE_ARRAY = 3,
    #[doc = "< Unified device or host memory\n"]
    CU_MEMORYTYPE_UNIFIED = 4,
}
#[doc = " Memory types\n"]
pub use self::CUmemorytype_enum as CUmemorytype;
#[repr(u32)]
#[doc = " Compute Modes\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUcomputemode_enum {
    #[doc = "< Default compute mode (Multiple contexts allowed per device)\n"]
    CU_COMPUTEMODE_DEFAULT = 0,
    #[doc = "< Compute-prohibited mode (No contexts can be created on this device at this time)\n"]
    CU_COMPUTEMODE_PROHIBITED = 2,
    #[doc = "< Compute-exclusive-process mode (Only one context used by a single process can be present on this device at a time)\n"]
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3,
}
#[doc = " Compute Modes\n"]
pub use self::CUcomputemode_enum as CUcomputemode;
#[repr(u32)]
#[doc = " Memory advise values\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmem_advise_enum {
    #[doc = "< Data will mostly be read and only occasionally be written to\n"]
    CU_MEM_ADVISE_SET_READ_MOSTLY = 1,
    #[doc = "< Undo the effect of [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY)\n"]
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = 2,
    #[doc = "< Set the preferred location for the data as the specified device\n"]
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = 3,
    #[doc = "< Clear the preferred location for the data\n"]
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4,
    #[doc = "< Data will be accessed by the specified device, so prevent page faults as much as possible\n"]
    CU_MEM_ADVISE_SET_ACCESSED_BY = 5,
    #[doc = "< Let the Unified Memory subsystem decide on the page faulting policy for the specified device\n"]
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = 6,
}
#[doc = " Memory advise values\n"]
pub use self::CUmem_advise_enum as CUmem_advise;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmem_range_attribute_enum {
    #[doc = "< Whether the range will mostly be read and only occasionally be written to\n"]
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1,
    #[doc = "< The preferred location of the range\n"]
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = 2,
    #[doc = "< Memory range has [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY) set for specified device\n"]
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = 3,
    #[doc = "< The last location to which the range was prefetched\n"]
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4,
    #[doc = "< The preferred location type of the range\n"]
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE = 5,
    #[doc = "< The preferred location id of the range\n"]
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID = 6,
    #[doc = "< The last location type to which the range was prefetched\n"]
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE = 7,
    #[doc = "< The last location id to which the range was prefetched\n"]
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID = 8,
}
pub use self::CUmem_range_attribute_enum as CUmem_range_attribute;
#[repr(u32)]
#[doc = " Online compiler and linker options\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjit_option_enum {
    #[doc = " Max number of registers that a thread may use.\\n\n Option type: unsigned int\\n\n Applies to: compiler only\n"]
    CU_JIT_MAX_REGISTERS = 0,
    #[doc = " IN: Specifies minimum number of threads per block to target compilation\n for\\n\n OUT: Returns the number of threads the compiler actually targeted.\n This restricts the resource utilization of the compiler (e.g. max\n registers) such that a block with the given number of threads should be\n able to launch based on register limitations. Note, this option does not\n currently take into account any other resource limitations, such as\n shared memory utilization.\\n\n Cannot be combined with [CU_JIT_TARGET](crate::ffi::CU_JIT_TARGET).\\n\n Option type: unsigned int\\n\n Applies to: compiler only\n"]
    CU_JIT_THREADS_PER_BLOCK = 1,
    #[doc = " Overwrites the option value with the total wall clock time, in\n milliseconds, spent in the compiler and linker\\n\n Option type: float\\n\n Applies to: compiler and linker\n"]
    CU_JIT_WALL_TIME = 2,
    #[doc = " Pointer to a buffer in which to print any log messages\n that are informational in nature (the buffer size is specified via\n option [CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES](crate::ffi::CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES))\\n\n Option type: char *\\n\n Applies to: compiler and linker\n"]
    CU_JIT_INFO_LOG_BUFFER = 3,
    #[doc = " IN: Log buffer size in bytes.  Log messages will be capped at this size\n (including null terminator)\\n\n OUT: Amount of log buffer filled with messages\\n\n Option type: unsigned int\\n\n Applies to: compiler and linker\n"]
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4,
    #[doc = " Pointer to a buffer in which to print any log messages that\n reflect errors (the buffer size is specified via option\n [CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES](crate::ffi::CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES))\\n\n Option type: char *\\n\n Applies to: compiler and linker\n"]
    CU_JIT_ERROR_LOG_BUFFER = 5,
    #[doc = " IN: Log buffer size in bytes.  Log messages will be capped at this size\n (including null terminator)\\n\n OUT: Amount of log buffer filled with messages\\n\n Option type: unsigned int\\n\n Applies to: compiler and linker\n"]
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6,
    #[doc = " Level of optimizations to apply to generated code (0 - 4), with 4\n being the default and highest level of optimizations.\\n\n Option type: unsigned int\\n\n Applies to: compiler only\n"]
    CU_JIT_OPTIMIZATION_LEVEL = 7,
    #[doc = " No option value required. Determines the target based on the current\n attached context (default)\\n\n Option type: No option value needed\\n\n Applies to: compiler and linker\n"]
    CU_JIT_TARGET_FROM_CUCONTEXT = 8,
    #[doc = " Target is chosen based on supplied [CUjit_target](crate::ffi::CUjit_target).  Cannot be\n combined with [CU_JIT_THREADS_PER_BLOCK](crate::ffi::CU_JIT_THREADS_PER_BLOCK).\\n\n Option type: unsigned int for enumerated type [CUjit_target](crate::ffi::CUjit_target)\\n\n Applies to: compiler and linker\n"]
    CU_JIT_TARGET = 9,
    #[doc = " Specifies choice of fallback strategy if matching cubin is not found.\n Choice is based on supplied [CUjit_fallback](crate::ffi::CUjit_fallback).  This option cannot be\n used with cuLink* APIs as the linker requires exact matches.\\n\n Option type: unsigned int for enumerated type [CUjit_fallback](crate::ffi::CUjit_fallback)\\n\n Applies to: compiler only\n"]
    CU_JIT_FALLBACK_STRATEGY = 10,
    #[doc = " Specifies whether to create debug information in output (-g)\n (0: false, default)\\n\n Option type: int\\n\n Applies to: compiler and linker\n"]
    CU_JIT_GENERATE_DEBUG_INFO = 11,
    #[doc = " Generate verbose log messages (0: false, default)\\n\n Option type: int\\n\n Applies to: compiler and linker\n"]
    CU_JIT_LOG_VERBOSE = 12,
    #[doc = " Generate line number information (-lineinfo) (0: false, default)\\n\n Option type: int\\n\n Applies to: compiler only\n"]
    CU_JIT_GENERATE_LINE_INFO = 13,
    #[doc = " Specifies whether to enable caching explicitly (-dlcm) \\n\n Choice is based on supplied [CUjit_cacheMode_enum](crate::ffi::CUjit_cacheMode_enum).\\n\n Option type: unsigned int for enumerated type [CUjit_cacheMode_enum](crate::ffi::CUjit_cacheMode_enum)\\n\n Applies to: compiler only\n"]
    CU_JIT_CACHE_MODE = 14,
    #[doc = " \\deprecated\n This jit option is deprecated and should not be used.\n"]
    CU_JIT_NEW_SM3X_OPT = 15,
    #[doc = " This jit option is used for internal purpose only.\n"]
    CU_JIT_FAST_COMPILE = 16,
    #[doc = " Array of device symbol names that will be relocated to the corresponding\n host addresses stored in [CU_JIT_GLOBAL_SYMBOL_ADDRESSES](crate::ffi::CU_JIT_GLOBAL_SYMBOL_ADDRESSES).\\n\n Must contain [CU_JIT_GLOBAL_SYMBOL_COUNT](crate::ffi::CU_JIT_GLOBAL_SYMBOL_COUNT) entries.\\n\n When loading a device module, driver will relocate all encountered\n unresolved symbols to the host addresses.\\n\n It is only allowed to register symbols that correspond to unresolved\n global variables.\\n\n It is illegal to register the same device symbol at multiple addresses.\\n\n Option type: const char **\\n\n Applies to: dynamic linker only\n"]
    CU_JIT_GLOBAL_SYMBOL_NAMES = 17,
    #[doc = " Array of host addresses that will be used to relocate corresponding\n device symbols stored in [CU_JIT_GLOBAL_SYMBOL_NAMES](crate::ffi::CU_JIT_GLOBAL_SYMBOL_NAMES).\\n\n Must contain [CU_JIT_GLOBAL_SYMBOL_COUNT](crate::ffi::CU_JIT_GLOBAL_SYMBOL_COUNT) entries.\\n\n Option type: void **\\n\n Applies to: dynamic linker only\n"]
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = 18,
    #[doc = " Number of entries in [CU_JIT_GLOBAL_SYMBOL_NAMES](crate::ffi::CU_JIT_GLOBAL_SYMBOL_NAMES) and\n [CU_JIT_GLOBAL_SYMBOL_ADDRESSES](crate::ffi::CU_JIT_GLOBAL_SYMBOL_ADDRESSES) arrays.\\n\n Option type: unsigned int\\n\n Applies to: dynamic linker only\n"]
    CU_JIT_GLOBAL_SYMBOL_COUNT = 19,
    #[doc = " \\deprecated\n Enable link-time optimization (-dlto) for device code (Disabled by default).\\n\n This option is not supported on 32-bit platforms.\\n\n Option type: int\\n\n Applies to: compiler and linker\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_LTO = 20,
    #[doc = " \\deprecated\n Control single-precision denormals (-ftz) support (0: false, default).\n 1 : flushes denormal values to zero\n 0 : preserves denormal values\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_FTZ = 21,
    #[doc = " \\deprecated\n Control single-precision floating-point division and reciprocals\n (-prec-div) support (1: true, default).\n 1 : Enables the IEEE round-to-nearest mode\n 0 : Enables the fast approximation mode\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_PREC_DIV = 22,
    #[doc = " \\deprecated\n Control single-precision floating-point square root\n (-prec-sqrt) support (1: true, default).\n 1 : Enables the IEEE round-to-nearest mode\n 0 : Enables the fast approximation mode\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_PREC_SQRT = 23,
    #[doc = " \\deprecated\n Enable/Disable the contraction of floating-point multiplies\n and adds/subtracts into floating-point multiply-add (-fma)\n operations (1: Enable, default; 0: Disable).\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_FMA = 24,
    #[doc = " \\deprecated\n Array of kernel names that should be preserved at link time while others\n can be removed.\\n\n Must contain [CU_JIT_REFERENCED_KERNEL_COUNT](crate::ffi::CU_JIT_REFERENCED_KERNEL_COUNT) entries.\\n\n Note that kernel names can be mangled by the compiler in which case the\n mangled name needs to be specified.\\n\n Wildcard \"*\" can be used to represent zero or more characters instead of\n specifying the full or mangled name.\\n\n It is important to note that the wildcard \"*\" is also added implicitly.\n For example, specifying \"foo\" will match \"foobaz\", \"barfoo\", \"barfoobaz\" and\n thus preserve all kernels with those names. This can be avoided by providing\n a more specific name like \"barfoobaz\".\\n\n Option type: const char **\\n\n Applies to: dynamic linker only\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_REFERENCED_KERNEL_NAMES = 25,
    #[doc = " \\deprecated\n Number of entries in [CU_JIT_REFERENCED_KERNEL_NAMES](crate::ffi::CU_JIT_REFERENCED_KERNEL_NAMES) array.\\n\n Option type: unsigned int\\n\n Applies to: dynamic linker only\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_REFERENCED_KERNEL_COUNT = 26,
    #[doc = " \\deprecated\n Array of variable names (__device__ and/or __constant__) that should be\n preserved at link time while others can be removed.\\n\n Must contain [CU_JIT_REFERENCED_VARIABLE_COUNT](crate::ffi::CU_JIT_REFERENCED_VARIABLE_COUNT) entries.\\n\n Note that variable names can be mangled by the compiler in which case the\n mangled name needs to be specified.\\n\n Wildcard \"*\" can be used to represent zero or more characters instead of\n specifying the full or mangled name.\\n\n It is important to note that the wildcard \"*\" is also added implicitly.\n For example, specifying \"foo\" will match \"foobaz\", \"barfoo\", \"barfoobaz\" and\n thus preserve all variables with those names. This can be avoided by providing\n a more specific name like \"barfoobaz\".\\n\n Option type: const char **\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_REFERENCED_VARIABLE_NAMES = 27,
    #[doc = " \\deprecated\n Number of entries in [CU_JIT_REFERENCED_VARIABLE_NAMES](crate::ffi::CU_JIT_REFERENCED_VARIABLE_NAMES) array.\\n\n Option type: unsigned int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_REFERENCED_VARIABLE_COUNT = 28,
    #[doc = " \\deprecated\n This option serves as a hint to enable the JIT compiler/linker\n to remove constant (__constant__) and device (__device__) variables\n unreferenced in device code (Disabled by default).\\n\n Note that host references to constant and device variables using APIs like\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal)() with this option specified may result in undefined behavior unless\n the variables are explicitly specified using [CU_JIT_REFERENCED_VARIABLE_NAMES](crate::ffi::CU_JIT_REFERENCED_VARIABLE_NAMES).\\n\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES = 29,
    #[doc = " Generate position independent code (0: false)\\n\n Option type: int\\n\n Applies to: compiler only\n"]
    CU_JIT_POSITION_INDEPENDENT_CODE = 30,
    #[doc = " This option hints to the JIT compiler the minimum number of CTAs from the\n kernels grid to be mapped to a SM. This option is ignored when used together\n with [CU_JIT_MAX_REGISTERS](crate::ffi::CU_JIT_MAX_REGISTERS) or [CU_JIT_THREADS_PER_BLOCK](crate::ffi::CU_JIT_THREADS_PER_BLOCK).\n Optimizations based on this option need [CU_JIT_MAX_THREADS_PER_BLOCK](crate::ffi::CU_JIT_MAX_THREADS_PER_BLOCK) to\n be specified as well. For kernels already using PTX directive .minnctapersm,\n this option will be ignored by default. Use [CU_JIT_OVERRIDE_DIRECTIVE_VALUES](crate::ffi::CU_JIT_OVERRIDE_DIRECTIVE_VALUES)\n to let this option take precedence over the PTX directive.\n Option type: unsigned int\\n\n Applies to: compiler only\n"]
    CU_JIT_MIN_CTA_PER_SM = 31,
    #[doc = " Maximum number threads in a thread block, computed as the product of\n the maximum extent specifed for each dimension of the block. This limit\n is guaranteed not to be exeeded in any invocation of the kernel. Exceeding\n the the maximum number of threads results in runtime error or kernel launch\n failure. For kernels already using PTX directive .maxntid, this option will\n be ignored by default. Use [CU_JIT_OVERRIDE_DIRECTIVE_VALUES](crate::ffi::CU_JIT_OVERRIDE_DIRECTIVE_VALUES) to let this\n option take precedence over the PTX directive.\n Option type: int\\n\n Applies to: compiler only\n"]
    CU_JIT_MAX_THREADS_PER_BLOCK = 32,
    #[doc = " This option lets the values specified using [CU_JIT_MAX_REGISTERS](crate::ffi::CU_JIT_MAX_REGISTERS),\n [CU_JIT_THREADS_PER_BLOCK](crate::ffi::CU_JIT_THREADS_PER_BLOCK), [CU_JIT_MAX_THREADS_PER_BLOCK](crate::ffi::CU_JIT_MAX_THREADS_PER_BLOCK) and\n [CU_JIT_MIN_CTA_PER_SM](crate::ffi::CU_JIT_MIN_CTA_PER_SM) take precedence over any PTX directives.\n (0: Disable, default; 1: Enable)\n Option type: int\\n\n Applies to: compiler only\n"]
    CU_JIT_OVERRIDE_DIRECTIVE_VALUES = 33,
    #[doc = " This option lets the values specified using [CU_JIT_MAX_REGISTERS](crate::ffi::CU_JIT_MAX_REGISTERS),\n [CU_JIT_THREADS_PER_BLOCK](crate::ffi::CU_JIT_THREADS_PER_BLOCK), [CU_JIT_MAX_THREADS_PER_BLOCK](crate::ffi::CU_JIT_MAX_THREADS_PER_BLOCK) and\n [CU_JIT_MIN_CTA_PER_SM](crate::ffi::CU_JIT_MIN_CTA_PER_SM) take precedence over any PTX directives.\n (0: Disable, default; 1: Enable)\n Option type: int\\n\n Applies to: compiler only\n"]
    CU_JIT_NUM_OPTIONS = 34,
}
#[doc = " Online compiler and linker options\n"]
pub use self::CUjit_option_enum as CUjit_option;
#[repr(u32)]
#[doc = " Online compilation targets\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjit_target_enum {
    #[doc = "< Compute device class 3.0\n"]
    CU_TARGET_COMPUTE_30 = 30,
    #[doc = "< Compute device class 3.2\n"]
    CU_TARGET_COMPUTE_32 = 32,
    #[doc = "< Compute device class 3.5\n"]
    CU_TARGET_COMPUTE_35 = 35,
    #[doc = "< Compute device class 3.7\n"]
    CU_TARGET_COMPUTE_37 = 37,
    #[doc = "< Compute device class 5.0\n"]
    CU_TARGET_COMPUTE_50 = 50,
    #[doc = "< Compute device class 5.2\n"]
    CU_TARGET_COMPUTE_52 = 52,
    #[doc = "< Compute device class 5.3\n"]
    CU_TARGET_COMPUTE_53 = 53,
    #[doc = "< Compute device class 6.0.\n"]
    CU_TARGET_COMPUTE_60 = 60,
    #[doc = "< Compute device class 6.1.\n"]
    CU_TARGET_COMPUTE_61 = 61,
    #[doc = "< Compute device class 6.2.\n"]
    CU_TARGET_COMPUTE_62 = 62,
    #[doc = "< Compute device class 7.0.\n"]
    CU_TARGET_COMPUTE_70 = 70,
    #[doc = "< Compute device class 7.2.\n"]
    CU_TARGET_COMPUTE_72 = 72,
    #[doc = "< Compute device class 7.5.\n"]
    CU_TARGET_COMPUTE_75 = 75,
    #[doc = "< Compute device class 8.0.\n"]
    CU_TARGET_COMPUTE_80 = 80,
    #[doc = "< Compute device class 8.6.\n"]
    CU_TARGET_COMPUTE_86 = 86,
    #[doc = "< Compute device class 8.7.\n"]
    CU_TARGET_COMPUTE_87 = 87,
    #[doc = "< Compute device class 8.9.\n"]
    CU_TARGET_COMPUTE_89 = 89,
    #[doc = "< Compute device class 9.0.\n"]
    CU_TARGET_COMPUTE_90 = 90,
    #[doc = "< Compute device class 10.0.\n"]
    CU_TARGET_COMPUTE_100 = 100,
    #[doc = "< Compute device class 10.1.\n"]
    CU_TARGET_COMPUTE_101 = 101,
    #[doc = "< Compute device class 12.0.\n"]
    CU_TARGET_COMPUTE_120 = 120,
    CU_TARGET_COMPUTE_90A = 65626,
    CU_TARGET_COMPUTE_100A = 65636,
    CU_TARGET_COMPUTE_101A = 65637,
    CU_TARGET_COMPUTE_120A = 65656,
}
#[doc = " Online compilation targets\n"]
pub use self::CUjit_target_enum as CUjit_target;
#[repr(u32)]
#[doc = " Cubin matching fallback strategies\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjit_fallback_enum {
    #[doc = "< Prefer to compile ptx if exact binary match not found\n"]
    CU_PREFER_PTX = 0,
    #[doc = "< Prefer to fall back to compatible binary code if exact match not found\n"]
    CU_PREFER_BINARY = 1,
}
#[doc = " Cubin matching fallback strategies\n"]
pub use self::CUjit_fallback_enum as CUjit_fallback;
#[repr(u32)]
#[doc = " Caching modes for dlcm\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjit_cacheMode_enum {
    #[doc = "< Compile with no -dlcm flag specified\n"]
    CU_JIT_CACHE_OPTION_NONE = 0,
    #[doc = "< Compile with L1 cache disabled\n"]
    CU_JIT_CACHE_OPTION_CG = 1,
    #[doc = "< Compile with L1 cache enabled\n"]
    CU_JIT_CACHE_OPTION_CA = 2,
}
#[doc = " Caching modes for dlcm\n"]
pub use self::CUjit_cacheMode_enum as CUjit_cacheMode;
#[repr(u32)]
#[doc = " Device code formats\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjitInputType_enum {
    #[doc = " Compiled device-class-specific device code\\n\n Applicable options: none\n"]
    CU_JIT_INPUT_CUBIN = 0,
    #[doc = " PTX source code\\n\n Applicable options: PTX compiler options\n"]
    CU_JIT_INPUT_PTX = 1,
    #[doc = " Bundle of multiple cubins and/or PTX of some device code\\n\n Applicable options: PTX compiler options, [CU_JIT_FALLBACK_STRATEGY](crate::ffi::CU_JIT_FALLBACK_STRATEGY)\n"]
    CU_JIT_INPUT_FATBINARY = 2,
    #[doc = " Host object with embedded device code\\n\n Applicable options: PTX compiler options, [CU_JIT_FALLBACK_STRATEGY](crate::ffi::CU_JIT_FALLBACK_STRATEGY)\n"]
    CU_JIT_INPUT_OBJECT = 3,
    #[doc = " Archive of host objects with embedded device code\\n\n Applicable options: PTX compiler options, [CU_JIT_FALLBACK_STRATEGY](crate::ffi::CU_JIT_FALLBACK_STRATEGY)\n"]
    CU_JIT_INPUT_LIBRARY = 4,
    #[doc = " \\deprecated\n High-level intermediate code for link-time optimization\\n\n Applicable options: NVVM compiler options, PTX compiler options\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_INPUT_NVVM = 5,
    #[doc = " \\deprecated\n High-level intermediate code for link-time optimization\\n\n Applicable options: NVVM compiler options, PTX compiler options\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0\n"]
    CU_JIT_NUM_INPUT_TYPES = 6,
}
#[doc = " Device code formats\n"]
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
#[repr(u32)]
#[doc = " Flags to register a graphics resource\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 2,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8,
}
#[doc = " Flags to register a graphics resource\n"]
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
#[repr(u32)]
#[doc = " Flags for mapping and unmapping interop resources\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = 0,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 2,
}
#[doc = " Flags for mapping and unmapping interop resources\n"]
pub use self::CUgraphicsMapResourceFlags_enum as CUgraphicsMapResourceFlags;
#[repr(u32)]
#[doc = " Array indices for cube faces\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUarray_cubemap_face_enum {
    #[doc = "< Positive X face of cubemap\n"]
    CU_CUBEMAP_FACE_POSITIVE_X = 0,
    #[doc = "< Negative X face of cubemap\n"]
    CU_CUBEMAP_FACE_NEGATIVE_X = 1,
    #[doc = "< Positive Y face of cubemap\n"]
    CU_CUBEMAP_FACE_POSITIVE_Y = 2,
    #[doc = "< Negative Y face of cubemap\n"]
    CU_CUBEMAP_FACE_NEGATIVE_Y = 3,
    #[doc = "< Positive Z face of cubemap\n"]
    CU_CUBEMAP_FACE_POSITIVE_Z = 4,
    #[doc = "< Negative Z face of cubemap\n"]
    CU_CUBEMAP_FACE_NEGATIVE_Z = 5,
}
#[doc = " Array indices for cube faces\n"]
pub use self::CUarray_cubemap_face_enum as CUarray_cubemap_face;
#[repr(u32)]
#[doc = " Limits\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUlimit_enum {
    #[doc = "< GPU thread stack size\n"]
    CU_LIMIT_STACK_SIZE = 0,
    #[doc = "< GPU printf FIFO size\n"]
    CU_LIMIT_PRINTF_FIFO_SIZE = 1,
    #[doc = "< GPU malloc heap size\n"]
    CU_LIMIT_MALLOC_HEAP_SIZE = 2,
    #[doc = "< GPU device runtime launch synchronize depth\n"]
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 3,
    #[doc = "< GPU device runtime pending launch count\n"]
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 4,
    #[doc = "< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint\n"]
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = 5,
    #[doc = "< A size in bytes for L2 persisting lines cache size\n"]
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE = 6,
    #[doc = "< A maximum size in bytes of shared memory available to CUDA kernels on a CIG context. Can only be queried, cannot be set\n"]
    CU_LIMIT_SHMEM_SIZE = 7,
    #[doc = "< A non-zero value indicates this CUDA context is a CIG-enabled context. Can only be queried, cannot be set\n"]
    CU_LIMIT_CIG_ENABLED = 8,
    #[doc = "< When set to zero, CUDA will fail to launch a kernel on a CIG context, instead of using the fallback path, if the kernel uses more shared memory than available\n"]
    CU_LIMIT_CIG_SHMEM_FALLBACK_ENABLED = 9,
    CU_LIMIT_MAX = 10,
}
#[doc = " Limits\n"]
pub use self::CUlimit_enum as CUlimit;
#[repr(u32)]
#[doc = " Resource types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUresourcetype_enum {
    #[doc = "< Array resource\n"]
    CU_RESOURCE_TYPE_ARRAY = 0,
    #[doc = "< Mipmapped array resource\n"]
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    #[doc = "< Linear resource\n"]
    CU_RESOURCE_TYPE_LINEAR = 2,
    #[doc = "< Pitch 2D resource\n"]
    CU_RESOURCE_TYPE_PITCH2D = 3,
}
#[doc = " Resource types\n"]
pub use self::CUresourcetype_enum as CUresourcetype;
#[doc = " CUDA host function\n#### userData:\nArgument value passed to the function\n"]
pub type CUhostFn = ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::ffi::c_void)>;
#[repr(u32)]
#[doc = " Specifies performance hint with [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow) for hitProp and missProp members.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUaccessProperty_enum {
    #[doc = "< Normal cache persistence.\n"]
    CU_ACCESS_PROPERTY_NORMAL = 0,
    #[doc = "< Streaming access is less likely to persit from cache.\n"]
    CU_ACCESS_PROPERTY_STREAMING = 1,
    #[doc = "< Persisting access is more likely to persist in cache.\n"]
    CU_ACCESS_PROPERTY_PERSISTING = 2,
}
#[doc = " Specifies performance hint with [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow) for hitProp and missProp members.\n"]
pub use self::CUaccessProperty_enum as CUaccessProperty;
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.\n Partition into many segments and assign segments such that:\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUaccessPolicyWindow_st {
    #[doc = "< Starting address of the access policy window. CUDA driver may align it.\n"]
    pub base_ptr: *mut ::std::ffi::c_void,
    #[doc = "< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment.\n"]
    pub num_bytes: usize,
    #[doc = "< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp.\n"]
    pub hitRatio: f32,
    #[doc = "< [CUaccessProperty](crate::ffi::CUaccessProperty) set for hit.\n"]
    pub hitProp: CUaccessProperty,
    #[doc = "< [CUaccessProperty](crate::ffi::CUaccessProperty) set for miss. Must be either NORMAL or STREAMING\n"]
    pub missProp: CUaccessProperty,
}
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.\n Partition into many segments and assign segments such that:\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy.\n"]
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
#[doc = " Access policy window\n"]
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
#[doc = " GPU kernel node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_KERNEL_NODE_PARAMS_st {
    #[doc = "< Kernel to launch\n"]
    pub func: CUfunction,
    #[doc = "< Width of grid in blocks\n"]
    pub gridDimX: ::std::ffi::c_uint,
    #[doc = "< Height of grid in blocks\n"]
    pub gridDimY: ::std::ffi::c_uint,
    #[doc = "< Depth of grid in blocks\n"]
    pub gridDimZ: ::std::ffi::c_uint,
    #[doc = "< X dimension of each thread block\n"]
    pub blockDimX: ::std::ffi::c_uint,
    #[doc = "< Y dimension of each thread block\n"]
    pub blockDimY: ::std::ffi::c_uint,
    #[doc = "< Z dimension of each thread block\n"]
    pub blockDimZ: ::std::ffi::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes\n"]
    pub sharedMemBytes: ::std::ffi::c_uint,
    #[doc = "< Array of pointers to kernel parameters\n"]
    pub kernelParams: *mut *mut ::std::ffi::c_void,
    #[doc = "< Extra options\n"]
    pub extra: *mut *mut ::std::ffi::c_void,
}
#[doc = " GPU kernel node parameters\n"]
pub type CUDA_KERNEL_NODE_PARAMS_v1 = CUDA_KERNEL_NODE_PARAMS_st;
#[doc = " GPU kernel node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_KERNEL_NODE_PARAMS_v2_st {
    #[doc = "< Kernel to launch\n"]
    pub func: CUfunction,
    #[doc = "< Width of grid in blocks\n"]
    pub gridDimX: ::std::ffi::c_uint,
    #[doc = "< Height of grid in blocks\n"]
    pub gridDimY: ::std::ffi::c_uint,
    #[doc = "< Depth of grid in blocks\n"]
    pub gridDimZ: ::std::ffi::c_uint,
    #[doc = "< X dimension of each thread block\n"]
    pub blockDimX: ::std::ffi::c_uint,
    #[doc = "< Y dimension of each thread block\n"]
    pub blockDimY: ::std::ffi::c_uint,
    #[doc = "< Z dimension of each thread block\n"]
    pub blockDimZ: ::std::ffi::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes\n"]
    pub sharedMemBytes: ::std::ffi::c_uint,
    #[doc = "< Array of pointers to kernel parameters\n"]
    pub kernelParams: *mut *mut ::std::ffi::c_void,
    #[doc = "< Extra options\n"]
    pub extra: *mut *mut ::std::ffi::c_void,
    #[doc = "< Kernel to launch, will only be referenced if func is NULL\n"]
    pub kern: CUkernel,
    #[doc = "< Context for the kernel task to run in. The value NULL will indicate the current context should be used by the api. This field is ignored if func is set.\n"]
    pub ctx: CUcontext,
}
#[doc = " GPU kernel node parameters\n"]
pub type CUDA_KERNEL_NODE_PARAMS_v2 = CUDA_KERNEL_NODE_PARAMS_v2_st;
#[doc = " GPU kernel node parameters\n"]
pub type CUDA_KERNEL_NODE_PARAMS = CUDA_KERNEL_NODE_PARAMS_v2;
#[doc = " GPU kernel node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_KERNEL_NODE_PARAMS_v3_st {
    #[doc = "< Kernel to launch\n"]
    pub func: CUfunction,
    #[doc = "< Width of grid in blocks\n"]
    pub gridDimX: ::std::ffi::c_uint,
    #[doc = "< Height of grid in blocks\n"]
    pub gridDimY: ::std::ffi::c_uint,
    #[doc = "< Depth of grid in blocks\n"]
    pub gridDimZ: ::std::ffi::c_uint,
    #[doc = "< X dimension of each thread block\n"]
    pub blockDimX: ::std::ffi::c_uint,
    #[doc = "< Y dimension of each thread block\n"]
    pub blockDimY: ::std::ffi::c_uint,
    #[doc = "< Z dimension of each thread block\n"]
    pub blockDimZ: ::std::ffi::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes\n"]
    pub sharedMemBytes: ::std::ffi::c_uint,
    #[doc = "< Array of pointers to kernel parameters\n"]
    pub kernelParams: *mut *mut ::std::ffi::c_void,
    #[doc = "< Extra options\n"]
    pub extra: *mut *mut ::std::ffi::c_void,
    #[doc = "< Kernel to launch, will only be referenced if func is NULL\n"]
    pub kern: CUkernel,
    #[doc = "< Context for the kernel task to run in. The value NULL will indicate the current context should be used by the api. This field is ignored if func is set.\n"]
    pub ctx: CUcontext,
}
#[doc = " GPU kernel node parameters\n"]
pub type CUDA_KERNEL_NODE_PARAMS_v3 = CUDA_KERNEL_NODE_PARAMS_v3_st;
#[doc = " Memset node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMSET_NODE_PARAMS_st {
    #[doc = "< Destination device pointer\n"]
    pub dst: CUdeviceptr,
    #[doc = "< Pitch of destination device pointer. Unused if height is 1\n"]
    pub pitch: usize,
    #[doc = "< Value to be set\n"]
    pub value: ::std::ffi::c_uint,
    #[doc = "< Size of each element in bytes. Must be 1, 2, or 4.\n"]
    pub elementSize: ::std::ffi::c_uint,
    #[doc = "< Width of the row in elements\n"]
    pub width: usize,
    #[doc = "< Number of rows\n"]
    pub height: usize,
}
#[doc = " Memset node parameters\n"]
pub type CUDA_MEMSET_NODE_PARAMS_v1 = CUDA_MEMSET_NODE_PARAMS_st;
#[doc = " Memset node parameters\n"]
pub type CUDA_MEMSET_NODE_PARAMS = CUDA_MEMSET_NODE_PARAMS_v1;
#[doc = " Memset node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMSET_NODE_PARAMS_v2_st {
    #[doc = "< Destination device pointer\n"]
    pub dst: CUdeviceptr,
    #[doc = "< Pitch of destination device pointer. Unused if height is 1\n"]
    pub pitch: usize,
    #[doc = "< Value to be set\n"]
    pub value: ::std::ffi::c_uint,
    #[doc = "< Size of each element in bytes. Must be 1, 2, or 4.\n"]
    pub elementSize: ::std::ffi::c_uint,
    #[doc = "< Width of the row in elements\n"]
    pub width: usize,
    #[doc = "< Number of rows\n"]
    pub height: usize,
    #[doc = "< Context on which to run the node\n"]
    pub ctx: CUcontext,
}
#[doc = " Memset node parameters\n"]
pub type CUDA_MEMSET_NODE_PARAMS_v2 = CUDA_MEMSET_NODE_PARAMS_v2_st;
#[doc = " Host node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_HOST_NODE_PARAMS_st {
    #[doc = "< The function to call when the node executes\n"]
    pub fn_: CUhostFn,
    #[doc = "< Argument to pass to the function\n"]
    pub userData: *mut ::std::ffi::c_void,
}
#[doc = " Host node parameters\n"]
pub type CUDA_HOST_NODE_PARAMS_v1 = CUDA_HOST_NODE_PARAMS_st;
#[doc = " Host node parameters\n"]
pub type CUDA_HOST_NODE_PARAMS = CUDA_HOST_NODE_PARAMS_v1;
#[doc = " Host node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_HOST_NODE_PARAMS_v2_st {
    #[doc = "< The function to call when the node executes\n"]
    pub fn_: CUhostFn,
    #[doc = "< Argument to pass to the function\n"]
    pub userData: *mut ::std::ffi::c_void,
}
#[doc = " Host node parameters\n"]
pub type CUDA_HOST_NODE_PARAMS_v2 = CUDA_HOST_NODE_PARAMS_v2_st;
#[repr(u32)]
#[doc = " Conditional node types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphConditionalNodeType_enum {
    #[doc = "< Conditional 'if/else' Node. Body[0] executed if condition is non-zero.  If `size` == 2, an optional ELSE graph is created and this is executed if the condition is zero.\n"]
    CU_GRAPH_COND_TYPE_IF = 0,
    #[doc = "< Conditional 'while' Node. Body executed repeatedly while condition value is non-zero.\n"]
    CU_GRAPH_COND_TYPE_WHILE = 1,
    #[doc = "< Conditional 'switch' Node. Body[n] is executed once, where 'n' is the value of the condition. If the condition does not match a body index, no body is launched.\n"]
    CU_GRAPH_COND_TYPE_SWITCH = 2,
}
#[doc = " Conditional node types\n"]
pub use self::CUgraphConditionalNodeType_enum as CUgraphConditionalNodeType;
#[doc = " Conditional node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_CONDITIONAL_NODE_PARAMS {
    #[doc = "< Conditional node handle.\nHandles must be created in advance of creating the node\nusing [cuGraphConditionalHandleCreate](crate::ffi::cuGraphConditionalHandleCreate).\n"]
    pub handle: CUgraphConditionalHandle,
    #[doc = "< Type of conditional node.\n"]
    pub type_: CUgraphConditionalNodeType,
    #[doc = "< Size of graph output array.  Allowed values are 1 for CU_GRAPH_COND_TYPE_WHILE, 1 or 2\nfor CU_GRAPH_COND_TYPE_IF, or any value greater than zero for CU_GRAPH_COND_TYPE_SWITCH.\n"]
    pub size: ::std::ffi::c_uint,
    #[doc = "< CUDA-owned array populated with conditional node child graphs during creation of the node.\nValid for the lifetime of the conditional node.\nThe contents of the graph(s) are subject to the following constraints:\n\n- Allowed node types are kernel nodes, empty nodes, child graphs, memsets,\nmemcopies, and conditionals. This applies recursively to child graphs and conditional bodies.\n- All kernels, including kernels in nested conditionals or child graphs at any level,\nmust belong to the same CUDA context.\n\nThese graphs may be populated using graph node creation APIs or [cuStreamBeginCaptureToGraph](crate::ffi::cuStreamBeginCaptureToGraph).\n\nCU_GRAPH_COND_TYPE_IF:\nphGraph_out[0] is executed when the condition is non-zero.  If `size` == 2, phGraph_out[1] will\nbe executed when the condition is zero.\nCU_GRAPH_COND_TYPE_WHILE:\nphGraph_out[0] is executed as long as the condition is non-zero.\nCU_GRAPH_COND_TYPE_SWITCH:\nphGraph_out[n] is executed when the condition is equal to n.  If the condition >= `size`,\nno body graph is executed.\n"]
    pub phGraph_out: *mut CUgraph,
    #[doc = "< Context on which to run the node.  Must match context used to create the handle and all body nodes.\n"]
    pub ctx: CUcontext,
}
#[repr(u32)]
#[doc = " Graph node types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphNodeType_enum {
    #[doc = "< GPU kernel node\n"]
    CU_GRAPH_NODE_TYPE_KERNEL = 0,
    #[doc = "< Memcpy node\n"]
    CU_GRAPH_NODE_TYPE_MEMCPY = 1,
    #[doc = "< Memset node\n"]
    CU_GRAPH_NODE_TYPE_MEMSET = 2,
    #[doc = "< Host (executable) node\n"]
    CU_GRAPH_NODE_TYPE_HOST = 3,
    #[doc = "< Node which executes an embedded graph\n"]
    CU_GRAPH_NODE_TYPE_GRAPH = 4,
    #[doc = "< Empty (no-op) node\n"]
    CU_GRAPH_NODE_TYPE_EMPTY = 5,
    #[doc = "< External event wait node\n"]
    CU_GRAPH_NODE_TYPE_WAIT_EVENT = 6,
    #[doc = "< External event record node\n"]
    CU_GRAPH_NODE_TYPE_EVENT_RECORD = 7,
    #[doc = "< External semaphore signal node\n"]
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = 8,
    #[doc = "< External semaphore wait node\n"]
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = 9,
    #[doc = "< Memory Allocation Node\n"]
    CU_GRAPH_NODE_TYPE_MEM_ALLOC = 10,
    #[doc = "< Memory Free Node\n"]
    CU_GRAPH_NODE_TYPE_MEM_FREE = 11,
    #[doc = "< Batch MemOp Node\n"]
    CU_GRAPH_NODE_TYPE_BATCH_MEM_OP = 12,
    #[doc = "< Conditional Node\n\nMay be used to implement a conditional execution path or loop\ninside of a graph. The graph(s) contained within the body of the conditional node\ncan be selectively executed or iterated upon based on the value of a conditional\nvariable.\n\nHandles must be created in advance of creating the node\nusing [cuGraphConditionalHandleCreate](crate::ffi::cuGraphConditionalHandleCreate).\n\nThe following restrictions apply to graphs which contain conditional nodes:\nThe graph cannot be used in a child node.\nOnly one instantiation of the graph may exist at any point in time.\nThe graph cannot be cloned.\n\nTo set the control value, supply a default value when creating the handle and/or\ncall [cudaGraphSetConditional](crate::ffi::cudaGraphSetConditional) from device code.\n"]
    CU_GRAPH_NODE_TYPE_CONDITIONAL = 13,
}
#[doc = " Graph node types\n"]
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
#[repr(u32)]
#[doc = " Type annotations that can be applied to graph edges as part of [CUgraphEdgeData](crate::ffi::CUgraphEdgeData).\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphDependencyType_enum {
    #[doc = "< This is an ordinary dependency.\n"]
    CU_GRAPH_DEPENDENCY_TYPE_DEFAULT = 0,
    #[doc = "< This dependency type allows the downstream node to\nuse \\c cudaGridDependencySynchronize(). It may only be used\nbetween kernel nodes, and must be used with either the\n[CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC](crate::ffi::CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC) or\n[CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER](crate::ffi::CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER) outgoing port.\n"]
    CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC = 1,
}
#[doc = " Type annotations that can be applied to graph edges as part of [CUgraphEdgeData](crate::ffi::CUgraphEdgeData).\n"]
pub use self::CUgraphDependencyType_enum as CUgraphDependencyType;
#[doc = " Optional annotation for edges in a CUDA graph. Note, all edges implicitly have annotations and\n default to a zero-initialized value if not specified. A zero-initialized struct indicates a\n standard full serialization of two nodes with memory visibility.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphEdgeData_st {
    #[doc = "< This indicates when the dependency is triggered from the upstream\nnode on the edge. The meaning is specfic to the node type. A value\nof 0 in all cases means full completion of the upstream node, with\nmemory visibility to the downstream node or portion thereof\n(indicated by \\c to_port).\n<br>\nOnly kernel nodes define non-zero ports. A kernel node\ncan use the following output port types:\n[CU_GRAPH_KERNEL_NODE_PORT_DEFAULT](crate::ffi::CU_GRAPH_KERNEL_NODE_PORT_DEFAULT), [CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC](crate::ffi::CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC),\nor [CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER](crate::ffi::CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER).\n"]
    pub from_port: ::std::ffi::c_uchar,
    #[doc = "< This indicates what portion of the downstream node is dependent on\nthe upstream node or portion thereof (indicated by \\c from_port). The\nmeaning is specific to the node type. A value of 0 in all cases means\nthe entirety of the downstream node is dependent on the upstream work.\n<br>\nCurrently no node types define non-zero ports. Accordingly, this field\nmust be set to zero.\n"]
    pub to_port: ::std::ffi::c_uchar,
    #[doc = "< This should be populated with a value from [CUgraphDependencyType](crate::ffi::CUgraphDependencyType). (It\nis typed as char due to compiler-specific layout of bitfields.) See\n[CUgraphDependencyType](crate::ffi::CUgraphDependencyType).\n"]
    pub type_: ::std::ffi::c_uchar,
    #[doc = "< These bytes are unused and must be zeroed. This ensures\ncompatibility if additional fields are added in the future.\n"]
    pub reserved: [::std::ffi::c_uchar; 5usize],
}
#[doc = " Optional annotation for edges in a CUDA graph. Note, all edges implicitly have annotations and\n default to a zero-initialized value if not specified. A zero-initialized struct indicates a\n standard full serialization of two nodes with memory visibility.\n"]
pub type CUgraphEdgeData = CUgraphEdgeData_st;
#[repr(u32)]
#[doc = " Graph instantiation results\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphInstantiateResult_enum {
    #[doc = "< Instantiation succeeded\n"]
    CUDA_GRAPH_INSTANTIATE_SUCCESS = 0,
    #[doc = "< Instantiation failed for an unexpected reason which is described in the return value of the function\n"]
    CUDA_GRAPH_INSTANTIATE_ERROR = 1,
    #[doc = "< Instantiation failed due to invalid structure, such as cycles\n"]
    CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE = 2,
    #[doc = "< Instantiation for device launch failed because the graph contained an unsupported operation\n"]
    CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED = 3,
    #[doc = "< Instantiation for device launch failed due to the nodes belonging to different contexts\n"]
    CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED = 4,
    #[doc = "< One or more conditional handles are not associated with conditional nodes\n"]
    CUDA_GRAPH_INSTANTIATE_CONDITIONAL_HANDLE_UNUSED = 5,
}
#[doc = " Graph instantiation results\n"]
pub use self::CUgraphInstantiateResult_enum as CUgraphInstantiateResult;
#[doc = " Graph instantiation parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_GRAPH_INSTANTIATE_PARAMS_st {
    #[doc = "< Instantiation flags\n"]
    pub flags: cuuint64_t,
    #[doc = "< Upload stream\n"]
    pub hUploadStream: CUstream,
    #[doc = "< The node which caused instantiation to fail, if any\n"]
    pub hErrNode_out: CUgraphNode,
    #[doc = "< Whether instantiation was successful.  If it failed, the reason why\n"]
    pub result_out: CUgraphInstantiateResult,
}
#[doc = " Graph instantiation parameters\n"]
pub type CUDA_GRAPH_INSTANTIATE_PARAMS = CUDA_GRAPH_INSTANTIATE_PARAMS_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUsynchronizationPolicy_enum {
    CU_SYNC_POLICY_AUTO = 1,
    CU_SYNC_POLICY_SPIN = 2,
    CU_SYNC_POLICY_YIELD = 3,
    CU_SYNC_POLICY_BLOCKING_SYNC = 4,
}
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
#[repr(u32)]
#[doc = " Cluster scheduling policies. These may be passed to [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute) or [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUclusterSchedulingPolicy_enum {
    #[doc = "< the default policy\n"]
    CU_CLUSTER_SCHEDULING_POLICY_DEFAULT = 0,
    #[doc = "< spread the blocks within a cluster to the SMs\n"]
    CU_CLUSTER_SCHEDULING_POLICY_SPREAD = 1,
    #[doc = "< allow the hardware to load-balance the blocks in a cluster to the SMs\n"]
    CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING = 2,
}
#[doc = " Cluster scheduling policies. These may be passed to [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute) or [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
pub use self::CUclusterSchedulingPolicy_enum as CUclusterSchedulingPolicy;
#[repr(u32)]
#[doc = " Memory Synchronization Domain\n\n A kernel can be launched in a specified memory synchronization domain that affects all memory operations issued by\n that kernel. A memory barrier issued in one domain will only order memory operations in that domain, thus eliminating\n latency increase from memory barriers ordering unrelated traffic.\n\n By default, kernels are launched in domain 0. Kernel launched with [CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE](crate::ffi::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE) will have a\n different domain ID. User may also alter the domain ID with [CUlaunchMemSyncDomainMap](crate::ffi::CUlaunchMemSyncDomainMap) for a specific stream /\n graph node / kernel launch. See [CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN](crate::ffi::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN), [cuStreamSetAttribute](crate::ffi::cuStreamSetAttribute), [cuLaunchKernelEx](crate::ffi::cuLaunchKernelEx),\n [cuGraphKernelNodeSetAttribute](crate::ffi::cuGraphKernelNodeSetAttribute).\n\n Memory operations done in kernels launched in different domains are considered system-scope distanced. In other\n words, a GPU scoped memory synchronization is not sufficient for memory order to be observed by kernels in another\n memory synchronization domain even if they are on the same GPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUlaunchMemSyncDomain_enum {
    #[doc = "< Launch kernels in the default domain\n"]
    CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT = 0,
    #[doc = "< Launch kernels in the remote domain\n"]
    CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE = 1,
}
#[doc = " Memory Synchronization Domain\n\n A kernel can be launched in a specified memory synchronization domain that affects all memory operations issued by\n that kernel. A memory barrier issued in one domain will only order memory operations in that domain, thus eliminating\n latency increase from memory barriers ordering unrelated traffic.\n\n By default, kernels are launched in domain 0. Kernel launched with [CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE](crate::ffi::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE) will have a\n different domain ID. User may also alter the domain ID with [CUlaunchMemSyncDomainMap](crate::ffi::CUlaunchMemSyncDomainMap) for a specific stream /\n graph node / kernel launch. See [CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN](crate::ffi::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN), [cuStreamSetAttribute](crate::ffi::cuStreamSetAttribute), [cuLaunchKernelEx](crate::ffi::cuLaunchKernelEx),\n [cuGraphKernelNodeSetAttribute](crate::ffi::cuGraphKernelNodeSetAttribute).\n\n Memory operations done in kernels launched in different domains are considered system-scope distanced. In other\n words, a GPU scoped memory synchronization is not sufficient for memory order to be observed by kernels in another\n memory synchronization domain even if they are on the same GPU.\n"]
pub use self::CUlaunchMemSyncDomain_enum as CUlaunchMemSyncDomain;
#[doc = " Memory Synchronization Domain map\n\n See [cudaLaunchMemSyncDomain](crate::ffi::cudaLaunchMemSyncDomain).\n\n By default, kernels are launched in domain 0. Kernel launched with [CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE](crate::ffi::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE) will have a\n different domain ID. User may also alter the domain ID with [CUlaunchMemSyncDomainMap](crate::ffi::CUlaunchMemSyncDomainMap) for a specific stream /\n graph node / kernel launch. See [CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP](crate::ffi::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP).\n\n Domain ID range is available through [CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT](crate::ffi::CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchMemSyncDomainMap_st {
    #[doc = "< The default domain ID to use for designated kernels\n"]
    pub default_: ::std::ffi::c_uchar,
    #[doc = "< The remote domain ID to use for designated kernels\n"]
    pub remote: ::std::ffi::c_uchar,
}
#[doc = " Memory Synchronization Domain map\n\n See [cudaLaunchMemSyncDomain](crate::ffi::cudaLaunchMemSyncDomain).\n\n By default, kernels are launched in domain 0. Kernel launched with [CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE](crate::ffi::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE) will have a\n different domain ID. User may also alter the domain ID with [CUlaunchMemSyncDomainMap](crate::ffi::CUlaunchMemSyncDomainMap) for a specific stream /\n graph node / kernel launch. See [CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP](crate::ffi::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP).\n\n Domain ID range is available through [CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT](crate::ffi::CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT).\n"]
pub type CUlaunchMemSyncDomainMap = CUlaunchMemSyncDomainMap_st;
#[repr(u32)]
#[doc = " Launch attributes enum; used as id field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUlaunchAttributeID_enum {
    #[doc = "< Ignored entry, for convenient composition\n"]
    CU_LAUNCH_ATTRIBUTE_IGNORE = 0,
    #[doc = "< Valid for streams, graph nodes, launches. See\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[accessPolicyWindow](crate::ffi::accessPolicyWindow).\n"]
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW = 1,
    #[doc = "< Valid for graph nodes, launches. See\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[cooperative](crate::ffi::cooperative).\n"]
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE = 2,
    #[doc = "< Valid for streams. See\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[syncPolicy](crate::ffi::syncPolicy).\n"]
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3,
    #[doc = "< Valid for graph nodes, launches. See [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[clusterDim](crate::ffi::clusterDim).\n"]
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION = 4,
    #[doc = "< Valid for graph nodes, launches. See [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[clusterSchedulingPolicyPreference](crate::ffi::clusterSchedulingPolicyPreference).\n"]
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 5,
    #[doc = "< Valid for launches. Setting\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[programmaticStreamSerializationAllowed](crate::ffi::programmaticStreamSerializationAllowed)\nto non-0 signals that the kernel will use programmatic\nmeans to resolve its stream dependency, so that the\nCUDA runtime should opportunistically allow the grid's\nexecution to overlap with the previous kernel in the\nstream, if that kernel requests the overlap. The\ndependent launches can choose to wait on the\ndependency using the programmatic sync\n(cudaGridDependencySynchronize() or equivalent PTX\ninstructions).\n"]
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION = 6,
    #[doc = "< Valid for launches. Set\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[programmaticEvent](crate::ffi::programmaticEvent) to\nrecord the event. Event recorded through this\nlaunch attribute is guaranteed to only trigger\nafter all block in the associated kernel trigger\nthe event. A block can trigger the event through\nPTX launchdep.release or CUDA builtin function\ncudaTriggerProgrammaticLaunchCompletion(). A\ntrigger can also be inserted at the beginning of\neach block's execution if triggerAtBlockStart is\nset to non-0. The dependent launches can choose to\nwait on the dependency using the programmatic sync\n(cudaGridDependencySynchronize() or equivalent PTX\ninstructions). Note that dependents (including the\nCPU thread calling cuEventSynchronize()) are not\nguaranteed to observe the release precisely when\nit is released.  For example, cuEventSynchronize()\nmay only observe the event trigger long after the\nassociated kernel has completed. This recording\ntype is primarily meant for establishing\nprogrammatic dependency between device tasks. Note\nalso this type of dependency allows, but does not\nguarantee, concurrent execution of tasks.\n<br>\nThe event supplied must not be an interprocess or\ninterop event. The event must disable timing (i.e.\nmust be created with the [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING)\nflag set).\n"]
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT = 7,
    #[doc = "< Valid for streams, graph nodes, launches. See\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[priority](crate::ffi::priority).\n"]
    CU_LAUNCH_ATTRIBUTE_PRIORITY = 8,
    #[doc = "< Valid for streams, graph nodes, launches. See\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[memSyncDomainMap](crate::ffi::memSyncDomainMap).\n"]
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = 9,
    #[doc = "< Valid for streams, graph nodes, launches. See\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[memSyncDomain](crate::ffi::memSyncDomain).\n"]
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN = 10,
    #[doc = "< Valid for graph nodes, launches. Set\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[preferredClusterDim](crate::ffi::preferredClusterDim)\nto allow the kernel launch to specify a preferred substitute\ncluster dimension. Blocks may be grouped according to either\nthe dimensions specified with this attribute (grouped into a\n\"preferred substitute cluster\"), or the one specified with\n[CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](crate::ffi::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION) attribute (grouped\ninto a \"regular cluster\"). The cluster dimensions of a\n\"preferred substitute cluster\" shall be an integer multiple\ngreater than zero of the regular cluster dimensions. The\ndevice will attempt - on a best-effort basis - to group\nthread blocks into preferred clusters over grouping them\ninto regular clusters. When it deems necessary (primarily\nwhen the device temporarily runs out of physical resources\nto launch the larger preferred clusters), the device may\nswitch to launch the regular clusters instead to attempt to\nutilize as much of the physical device resources as possible.\n<br>\nEach type of cluster will have its enumeration / coordinate\nsetup as if the grid consists solely of its type of cluster.\nFor example, if the preferred substitute cluster dimensions\ndouble the regular cluster dimensions, there might be\nsimultaneously a regular cluster indexed at (1,0,0), and a\npreferred cluster indexed at (1,0,0). In this example, the\npreferred substitute cluster (1,0,0) replaces regular\nclusters (2,0,0) and (3,0,0) and groups their blocks.\n<br>\nThis attribute will only take effect when a regular cluster\ndimension has been specified. The preferred substitute\ncluster dimension must be an integer multiple greater than\nzero of the regular cluster dimension and must divide the\ngrid. It must also be no more than `maxBlocksPerCluster`, if\nit is set in the kernel's `__launch_bounds__`. Otherwise it\nmust be less than the maximum value the driver can support.\nOtherwise, setting this attribute to a value physically\nunable to fit on any particular device is permitted.\n"]
    CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION = 11,
    #[doc = "< Valid for launches. Set\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[launchCompletionEvent](crate::ffi::launchCompletionEvent) to record the\nevent.\n<br>\nNominally, the event is triggered once all blocks of the kernel\nhave begun execution. Currently this is a best effort. If a kernel\nB has a launch completion dependency on a kernel A, B may wait\nuntil A is complete. Alternatively, blocks of B may begin before\nall blocks of A have begun, for example if B can claim execution\nresources unavailable to A (e.g. they run on different GPUs) or\nif B is a higher priority than A.\nExercise caution if such an ordering inversion could lead\nto deadlock.\n<br>\nA launch completion event is nominally similar to a programmatic\nevent with \\c triggerAtBlockStart set except that it is not\nvisible to \\c cudaGridDependencySynchronize() and can be used with\ncompute capability less than 9.0.\n<br>\nThe event supplied must not be an interprocess or interop\nevent. The event must disable timing (i.e. must be created\nwith the [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING) flag set).\n"]
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT = 12,
    #[doc = "< Valid for graph nodes, launches. This attribute is graphs-only,\nand passing it to a launch in a non-capturing stream will result\nin an error.\n<br>\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[deviceUpdatableKernelNode](crate::ffi::deviceUpdatableKernelNode)[deviceUpdatable](crate::ffi::deviceUpdatable) can\nonly be set to 0 or 1. Setting the field to 1 indicates that the\ncorresponding kernel node should be device-updatable. On success, a handle\nwill be returned via\n[CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[deviceUpdatableKernelNode](crate::ffi::deviceUpdatableKernelNode)[devNode](crate::ffi::devNode) which can be\npassed to the various device-side update functions to update the node's\nkernel parameters from within another kernel. For more information on the\ntypes of device updates that can be made, as well as the relevant limitations\nthereof, see [cudaGraphKernelNodeUpdatesApply](crate::ffi::cudaGraphKernelNodeUpdatesApply).\n<br>\nNodes which are device-updatable have additional restrictions compared to\nregular kernel nodes. Firstly, device-updatable nodes cannot be removed\nfrom their graph via [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode). Additionally, once opted-in\nto this functionality, a node cannot opt out, and any attempt to set the\ndeviceUpdatable attribute to 0 will result in an error. Device-updatable\nkernel nodes also cannot have their attributes copied to/from another kernel\nnode via [cuGraphKernelNodeCopyAttributes](crate::ffi::cuGraphKernelNodeCopyAttributes). Graphs containing one or more\ndevice-updatable nodes also do not allow multiple instantiation, and neither\nthe graph nor its instantiated version can be passed to [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate).\n<br>\nIf a graph contains device-updatable nodes and updates those nodes from the device\nfrom within the graph, the graph must be uploaded with [cuGraphUpload](crate::ffi::cuGraphUpload) before it\nis launched. For such a graph, if host-side executable graph updates are made to the\ndevice-updatable nodes, the graph must be uploaded before it is launched again.\n"]
    CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE = 13,
    #[doc = "< Valid for launches. On devices where the L1 cache and shared memory use the\nsame hardware resources, setting [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[sharedMemCarveout](crate::ffi::sharedMemCarveout) to a\npercentage between 0-100 signals the CUDA driver to set the shared memory carveout\npreference, in percent of the total shared memory for that kernel launch.\nThis attribute takes precedence over [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](crate::ffi::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT).\nThis is only a hint, and the CUDA driver can choose a different configuration if\nrequired for the launch.\n"]
    CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 14,
}
#[doc = " Launch attributes enum; used as id field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub use self::CUlaunchAttributeID_enum as CUlaunchAttributeID;
#[doc = " Launch attributes union; used as value field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUlaunchAttributeValue_union {
    pub pad: [::std::ffi::c_char; 64usize],
    #[doc = "< Value of launch attribute [CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW](crate::ffi::CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW).\n"]
    pub accessPolicyWindow: CUaccessPolicyWindow,
    #[doc = "< Value of launch attribute [CU_LAUNCH_ATTRIBUTE_COOPERATIVE](crate::ffi::CU_LAUNCH_ATTRIBUTE_COOPERATIVE). Nonzero indicates a cooperative\nkernel (see [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel)).\n"]
    pub cooperative: ::std::ffi::c_int,
    #[doc = "< Value of launch attribute\n[CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY](crate::ffi::CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY). [CUsynchronizationPolicy](crate::ffi::CUsynchronizationPolicy) for\nwork queued up in this stream\n"]
    pub syncPolicy: CUsynchronizationPolicy,
    pub clusterDim: CUlaunchAttributeValue_union__bindgen_ty_1,
    #[doc = "< Value of launch attribute\n[CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](crate::ffi::CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE). Cluster\nscheduling policy preference for the kernel.\n"]
    pub clusterSchedulingPolicyPreference: CUclusterSchedulingPolicy,
    #[doc = "< Value of launch attribute\n[CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION](crate::ffi::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION).\n"]
    pub programmaticStreamSerializationAllowed: ::std::ffi::c_int,
    pub programmaticEvent: CUlaunchAttributeValue_union__bindgen_ty_2,
    pub launchCompletionEvent: CUlaunchAttributeValue_union__bindgen_ty_3,
    #[doc = "< Value of launch attribute [CU_LAUNCH_ATTRIBUTE_PRIORITY](crate::ffi::CU_LAUNCH_ATTRIBUTE_PRIORITY). Execution priority of the kernel.\n"]
    pub priority: ::std::ffi::c_int,
    #[doc = "< Value of launch attribute\n[CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP](crate::ffi::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP). See\n[CUlaunchMemSyncDomainMap](crate::ffi::CUlaunchMemSyncDomainMap).\n"]
    pub memSyncDomainMap: CUlaunchMemSyncDomainMap,
    #[doc = "< Value of launch attribute\n[CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN](crate::ffi::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN). See[CUlaunchMemSyncDomain](crate::ffi::CUlaunchMemSyncDomain)\n"]
    pub memSyncDomain: CUlaunchMemSyncDomain,
    pub preferredClusterDim: CUlaunchAttributeValue_union__bindgen_ty_4,
    pub deviceUpdatableKernelNode: CUlaunchAttributeValue_union__bindgen_ty_5,
    #[doc = "< Value of launch attribute [CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](crate::ffi::CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT).\n"]
    pub sharedMemCarveout: ::std::ffi::c_uint,
}
#[doc = "  Value of launch attribute [CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](crate::ffi::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION) that\n  represents the desired cluster dimensions for the kernel. Opaque type\n  with the following fields:\n      - `x` - The X dimension of the cluster, in blocks. Must be a divisor\n               of the grid X dimension.\n      - `y` - The Y dimension of the cluster, in blocks. Must be a divisor\n               of the grid Y dimension.\n      - `z` - The Z dimension of the cluster, in blocks. Must be a divisor\n               of the grid Z dimension.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_1 {
    pub x: ::std::ffi::c_uint,
    pub y: ::std::ffi::c_uint,
    pub z: ::std::ffi::c_uint,
}
#[doc = "  Value of launch attribute [CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT](crate::ffi::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT)\n  with the following fields:\n      - `CUevent` event - Event to fire when all blocks trigger it.\n      - `Event` record flags, see [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags). Does not accept :CU_EVENT_RECORD_EXTERNAL.\n      - `triggerAtBlockStart` - If this is set to non-0, each block launch will automatically trigger the event.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_2 {
    pub event: CUevent,
    pub flags: ::std::ffi::c_int,
    pub triggerAtBlockStart: ::std::ffi::c_int,
}
#[doc = " Value of launch attribute [CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT](crate::ffi::CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT)\n with the following fields:\n     - `CUevent` event - Event to fire when the last block launches\n     - `int` flags; - Event record flags, see [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags). Does not accept [CU_EVENT_RECORD_EXTERNAL](crate::ffi::CU_EVENT_RECORD_EXTERNAL).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_3 {
    pub event: CUevent,
    pub flags: ::std::ffi::c_int,
}
#[doc = "  Value of launch attribute [CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION](crate::ffi::CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION)\n  that represents the desired preferred cluster dimensions for the kernel.\n  Opaque type with the following fields:\n      - `x` - The X dimension of the preferred cluster, in blocks. Must\n               be a divisor of the grid X dimension, and must be a\n               multiple of the `x` field of [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[clusterDim](crate::ffi::clusterDim).\n      - `y` - The Y dimension of the preferred cluster, in blocks. Must\n               be a divisor of the grid Y dimension, and must be a\n               multiple of the `y` field of [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[clusterDim](crate::ffi::clusterDim).\n      - `z` - The Z dimension of the preferred cluster, in blocks. Must be\n               equal to the `z` field of [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[clusterDim](crate::ffi::clusterDim).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_4 {
    pub x: ::std::ffi::c_uint,
    pub y: ::std::ffi::c_uint,
    pub z: ::std::ffi::c_uint,
}
#[doc = "  Value of launch attribute [CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE](crate::ffi::CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE).\n  with the following fields:\n      - `int` deviceUpdatable - Whether or not the resulting kernel node should be device-updatable.\n      - `CUgraphDeviceNode` devNode - Returns a handle to pass to the various device-side update functions.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_5 {
    pub deviceUpdatable: ::std::ffi::c_int,
    pub devNode: CUgraphDeviceNode,
}
#[doc = " Launch attributes union; used as value field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub type CUlaunchAttributeValue = CUlaunchAttributeValue_union;
#[doc = " Launch attribute\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUlaunchAttribute_st {
    #[doc = "< Attribute to set\n"]
    pub id: CUlaunchAttributeID,
    pub pad: [::std::ffi::c_char; 4usize],
    #[doc = "< Value of the attribute\n"]
    pub value: CUlaunchAttributeValue,
}
#[doc = " Launch attribute\n"]
pub type CUlaunchAttribute = CUlaunchAttribute_st;
#[doc = " CUDA extensible launch configuration\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchConfig_st {
    #[doc = "< Width of grid in blocks\n"]
    pub gridDimX: ::std::ffi::c_uint,
    #[doc = "< Height of grid in blocks\n"]
    pub gridDimY: ::std::ffi::c_uint,
    #[doc = "< Depth of grid in blocks\n"]
    pub gridDimZ: ::std::ffi::c_uint,
    #[doc = "< X dimension of each thread block\n"]
    pub blockDimX: ::std::ffi::c_uint,
    #[doc = "< Y dimension of each thread block\n"]
    pub blockDimY: ::std::ffi::c_uint,
    #[doc = "< Z dimension of each thread block\n"]
    pub blockDimZ: ::std::ffi::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes\n"]
    pub sharedMemBytes: ::std::ffi::c_uint,
    #[doc = "< Stream identifier\n"]
    pub hStream: CUstream,
    #[doc = "< List of attributes; nullable if [CUlaunchConfig](crate::ffi::CUlaunchConfig)[numAttrs](crate::ffi::numAttrs) == 0\n"]
    pub attrs: *mut CUlaunchAttribute,
    #[doc = "< Number of attributes populated in [CUlaunchConfig](crate::ffi::CUlaunchConfig)[attrs](crate::ffi::attrs)\n"]
    pub numAttrs: ::std::ffi::c_uint,
}
#[doc = " CUDA extensible launch configuration\n"]
pub type CUlaunchConfig = CUlaunchConfig_st;
#[doc = " Launch attributes enum; used as id field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub use self::CUlaunchAttributeID as CUkernelNodeAttrID;
#[doc = " Launch attributes union; used as value field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub type CUkernelNodeAttrValue_v1 = CUlaunchAttributeValue;
#[doc = " Launch attributes union; used as value field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub type CUkernelNodeAttrValue = CUkernelNodeAttrValue_v1;
#[repr(u32)]
#[doc = " Possible stream capture statuses returned by [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstreamCaptureStatus_enum {
    #[doc = "< Stream is not capturing\n"]
    CU_STREAM_CAPTURE_STATUS_NONE = 0,
    #[doc = "< Stream is actively capturing\n"]
    CU_STREAM_CAPTURE_STATUS_ACTIVE = 1,
    #[doc = "< Stream is part of a capture sequence that\nhas been invalidated, but not terminated\n"]
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2,
}
#[doc = " Possible stream capture statuses returned by [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing)\n"]
pub use self::CUstreamCaptureStatus_enum as CUstreamCaptureStatus;
#[repr(u32)]
#[doc = " Possible modes for stream capture thread interactions. For more details see\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture) and [cuThreadExchangeStreamCaptureMode](crate::ffi::cuThreadExchangeStreamCaptureMode)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUstreamCaptureMode_enum {
    CU_STREAM_CAPTURE_MODE_GLOBAL = 0,
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = 1,
    CU_STREAM_CAPTURE_MODE_RELAXED = 2,
}
#[doc = " Launch attributes enum; used as id field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub use self::CUlaunchAttributeID as CUstreamAttrID;
#[doc = " Possible modes for stream capture thread interactions. For more details see\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture) and [cuThreadExchangeStreamCaptureMode](crate::ffi::cuThreadExchangeStreamCaptureMode)\n"]
pub use self::CUstreamCaptureMode_enum as CUstreamCaptureMode;
#[doc = " Launch attributes union; used as value field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub type CUstreamAttrValue_v1 = CUlaunchAttributeValue;
#[doc = " Launch attributes union; used as value field of [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)\n"]
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
#[repr(u32)]
#[doc = " Flags to specify search options. For more details see [cuGetProcAddress](crate::ffi::cuGetProcAddress)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdriverProcAddress_flags_enum {
    #[doc = "< Default search mode for driver symbols.\n"]
    CU_GET_PROC_ADDRESS_DEFAULT = 0,
    #[doc = "< Search for legacy versions of driver symbols.\n"]
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = 1,
    #[doc = "< Search for per-thread versions of driver symbols.\n"]
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = 2,
}
#[doc = " Flags to specify search options. For more details see [cuGetProcAddress](crate::ffi::cuGetProcAddress)\n"]
pub use self::CUdriverProcAddress_flags_enum as CUdriverProcAddress_flags;
#[repr(u32)]
#[doc = " Flags to indicate search status. For more details see [cuGetProcAddress](crate::ffi::cuGetProcAddress)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdriverProcAddressQueryResult_enum {
    #[doc = "< Symbol was succesfully found\n"]
    CU_GET_PROC_ADDRESS_SUCCESS = 0,
    #[doc = "< Symbol was not found in search\n"]
    CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND = 1,
    #[doc = "< Symbol was found but version supplied was not sufficient\n"]
    CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT = 2,
}
#[doc = " Flags to indicate search status. For more details see [cuGetProcAddress](crate::ffi::cuGetProcAddress)\n"]
pub use self::CUdriverProcAddressQueryResult_enum as CUdriverProcAddressQueryResult;
#[repr(u32)]
#[doc = " Execution Affinity Types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUexecAffinityType_enum {
    #[doc = "< Create a context with limited SMs.\n"]
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = 0,
    CU_EXEC_AFFINITY_TYPE_MAX = 1,
}
#[doc = " Execution Affinity Types\n"]
pub use self::CUexecAffinityType_enum as CUexecAffinityType;
#[doc = " Value for [CU_EXEC_AFFINITY_TYPE_SM_COUNT](crate::ffi::CU_EXEC_AFFINITY_TYPE_SM_COUNT)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexecAffinitySmCount_st {
    #[doc = "< The number of SMs the context is limited to use.\n"]
    pub val: ::std::ffi::c_uint,
}
#[doc = " Value for [CU_EXEC_AFFINITY_TYPE_SM_COUNT](crate::ffi::CU_EXEC_AFFINITY_TYPE_SM_COUNT)\n"]
pub type CUexecAffinitySmCount_v1 = CUexecAffinitySmCount_st;
#[doc = " Value for [CU_EXEC_AFFINITY_TYPE_SM_COUNT](crate::ffi::CU_EXEC_AFFINITY_TYPE_SM_COUNT)\n"]
pub type CUexecAffinitySmCount = CUexecAffinitySmCount_v1;
#[doc = " Execution Affinity Parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUexecAffinityParam_st {
    pub type_: CUexecAffinityType,
    pub param: CUexecAffinityParam_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUexecAffinityParam_st__bindgen_ty_1 {
    pub smCount: CUexecAffinitySmCount,
}
#[doc = " Execution Affinity Parameters\n"]
pub type CUexecAffinityParam_v1 = CUexecAffinityParam_st;
#[doc = " Execution Affinity Parameters\n"]
pub type CUexecAffinityParam = CUexecAffinityParam_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUcigDataType_enum {
    CIG_DATA_TYPE_D3D12_COMMAND_QUEUE = 1,
}
pub use self::CUcigDataType_enum as CUcigDataType;
#[doc = " CIG Context Create Params\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctxCigParam_st {
    pub sharedDataType: CUcigDataType,
    pub sharedData: *mut ::std::ffi::c_void,
}
#[doc = " CIG Context Create Params\n"]
pub type CUctxCigParam = CUctxCigParam_st;
#[doc = " Params for creating CUDA context\n Exactly one of execAffinityParams and cigParams\n must be non-NULL.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctxCreateParams_st {
    pub execAffinityParams: *mut CUexecAffinityParam,
    pub numExecAffinityParams: ::std::ffi::c_int,
    pub cigParams: *mut CUctxCigParam,
}
#[doc = " Params for creating CUDA context\n Exactly one of execAffinityParams and cigParams\n must be non-NULL.\n"]
pub type CUctxCreateParams = CUctxCreateParams_st;
#[repr(u32)]
#[doc = " Library options to be specified with [cuLibraryLoadData](crate::ffi::cuLibraryLoadData)() or [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile)()\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUlibraryOption_enum {
    CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE = 0,
    #[doc = " Specifes that the argument `code` passed to [cuLibraryLoadData](crate::ffi::cuLibraryLoadData)() will be preserved.\n Specifying this option will let the driver know that `code` can be accessed at any point\n until [cuLibraryUnload](crate::ffi::cuLibraryUnload)(). The default behavior is for the driver to allocate and\n maintain its own copy of `code`. Note that this is only a memory usage optimization\n hint and the driver can choose to ignore it if required.\n Specifying this option with [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile)() is invalid and\n will return [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n"]
    CU_LIBRARY_BINARY_IS_PRESERVED = 1,
    #[doc = " Specifes that the argument `code` passed to [cuLibraryLoadData](crate::ffi::cuLibraryLoadData)() will be preserved.\n Specifying this option will let the driver know that `code` can be accessed at any point\n until [cuLibraryUnload](crate::ffi::cuLibraryUnload)(). The default behavior is for the driver to allocate and\n maintain its own copy of `code`. Note that this is only a memory usage optimization\n hint and the driver can choose to ignore it if required.\n Specifying this option with [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile)() is invalid and\n will return [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n"]
    CU_LIBRARY_NUM_OPTIONS = 2,
}
#[doc = " Library options to be specified with [cuLibraryLoadData](crate::ffi::cuLibraryLoadData)() or [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile)()\n"]
pub use self::CUlibraryOption_enum as CUlibraryOption;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlibraryHostUniversalFunctionAndDataTable_st {
    pub functionTable: *mut ::std::ffi::c_void,
    pub functionWindowSize: usize,
    pub dataTable: *mut ::std::ffi::c_void,
    pub dataWindowSize: usize,
}
pub type CUlibraryHostUniversalFunctionAndDataTable = CUlibraryHostUniversalFunctionAndDataTable_st;
#[repr(u32)]
#[doc = " Error codes\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaError_enum {
    #[doc = " The API call returned with no errors. In the case of query calls, this\n also means that the operation being queried is complete (see\n [cuEventQuery](crate::ffi::cuEventQuery)() and [cuStreamQuery](crate::ffi::cuStreamQuery)()).\n"]
    CUDA_SUCCESS = 0,
    #[doc = " This indicates that one or more of the parameters passed to the API call\n is not within an acceptable range of values.\n"]
    CUDA_ERROR_INVALID_VALUE = 1,
    #[doc = " The API call failed because it was unable to allocate enough memory or\n other resources to perform the requested operation.\n"]
    CUDA_ERROR_OUT_OF_MEMORY = 2,
    #[doc = " This indicates that the CUDA driver has not been initialized with\n [cuInit](crate::ffi::cuInit)() or that initialization has failed.\n"]
    CUDA_ERROR_NOT_INITIALIZED = 3,
    #[doc = " This indicates that the CUDA driver is in the process of shutting down.\n"]
    CUDA_ERROR_DEINITIALIZED = 4,
    #[doc = " This indicates profiler is not initialized for this run. This can\n happen when the application is running with external profiling tools\n like visual profiler.\n"]
    CUDA_ERROR_PROFILER_DISABLED = 5,
    #[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to attempt to enable/disable the profiling via [cuProfilerStart](crate::ffi::cuProfilerStart) or\n [cuProfilerStop](crate::ffi::cuProfilerStop) without initialization.\n"]
    CUDA_ERROR_PROFILER_NOT_INITIALIZED = 6,
    #[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cuProfilerStart() when profiling is already enabled.\n"]
    CUDA_ERROR_PROFILER_ALREADY_STARTED = 7,
    #[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cuProfilerStop() when profiling is already disabled.\n"]
    CUDA_ERROR_PROFILER_ALREADY_STOPPED = 8,
    #[doc = " This indicates that the CUDA driver that the application has loaded is a\n stub library. Applications that run with the stub rather than a real\n driver loaded will result in CUDA API returning this error.\n"]
    CUDA_ERROR_STUB_LIBRARY = 34,
    #[doc = " This indicates that requested CUDA device is unavailable at the current\n time. Devices are often unavailable due to use of\n [CU_COMPUTEMODE_EXCLUSIVE_PROCESS](crate::ffi::CU_COMPUTEMODE_EXCLUSIVE_PROCESS) or [CU_COMPUTEMODE_PROHIBITED](crate::ffi::CU_COMPUTEMODE_PROHIBITED).\n"]
    CUDA_ERROR_DEVICE_UNAVAILABLE = 46,
    #[doc = " This indicates that no CUDA-capable devices were detected by the installed\n CUDA driver.\n"]
    CUDA_ERROR_NO_DEVICE = 100,
    #[doc = " This indicates that the device ordinal supplied by the user does not\n correspond to a valid CUDA device or that the action requested is\n invalid for the specified device.\n"]
    CUDA_ERROR_INVALID_DEVICE = 101,
    #[doc = " This error indicates that the Grid license is not applied.\n"]
    CUDA_ERROR_DEVICE_NOT_LICENSED = 102,
    #[doc = " This indicates that the device kernel image is invalid. This can also\n indicate an invalid CUDA module.\n"]
    CUDA_ERROR_INVALID_IMAGE = 200,
    #[doc = " This most frequently indicates that there is no context bound to the\n current thread. This can also be returned if the context passed to an\n API call is not a valid handle (such as a context that has had\n [cuCtxDestroy](crate::ffi::cuCtxDestroy)() invoked on it). This can also be returned if a user\n mixes different API versions (i.e. 3010 context with 3020 API calls).\n See [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion)() for more details.\n This can also be returned if the green context passed to an API call\n was not converted to a [CUcontext](crate::ffi::CUcontext) using [cuCtxFromGreenCtx](crate::ffi::cuCtxFromGreenCtx) API.\n"]
    CUDA_ERROR_INVALID_CONTEXT = 201,
    #[doc = " This indicated that the context being supplied as a parameter to the\n API call was already the active context.\n \\deprecated\n This error return is deprecated as of CUDA 3.2. It is no longer an\n error to attempt to push the active context via [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent)().\n"]
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = 202,
    #[doc = " This indicates that a map or register operation has failed.\n"]
    CUDA_ERROR_MAP_FAILED = 205,
    #[doc = " This indicates that an unmap or unregister operation has failed.\n"]
    CUDA_ERROR_UNMAP_FAILED = 206,
    #[doc = " This indicates that the specified array is currently mapped and thus\n cannot be destroyed.\n"]
    CUDA_ERROR_ARRAY_IS_MAPPED = 207,
    #[doc = " This indicates that the resource is already mapped.\n"]
    CUDA_ERROR_ALREADY_MAPPED = 208,
    #[doc = " This indicates that there is no kernel image available that is suitable\n for the device. This can occur when a user specifies code generation\n options for a particular CUDA source file that do not include the\n corresponding device configuration.\n"]
    CUDA_ERROR_NO_BINARY_FOR_GPU = 209,
    #[doc = " This indicates that a resource has already been acquired.\n"]
    CUDA_ERROR_ALREADY_ACQUIRED = 210,
    #[doc = " This indicates that a resource is not mapped.\n"]
    CUDA_ERROR_NOT_MAPPED = 211,
    #[doc = " This indicates that a mapped resource is not available for access as an\n array.\n"]
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = 212,
    #[doc = " This indicates that a mapped resource is not available for access as a\n pointer.\n"]
    CUDA_ERROR_NOT_MAPPED_AS_POINTER = 213,
    #[doc = " This indicates that an uncorrectable ECC error was detected during\n execution.\n"]
    CUDA_ERROR_ECC_UNCORRECTABLE = 214,
    #[doc = " This indicates that the [CUlimit](crate::ffi::CUlimit) passed to the API call is not\n supported by the active device.\n"]
    CUDA_ERROR_UNSUPPORTED_LIMIT = 215,
    #[doc = " This indicates that the [CUcontext](crate::ffi::CUcontext) passed to the API call can\n only be bound to a single CPU thread at a time but is already\n bound to a CPU thread.\n"]
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = 216,
    #[doc = " This indicates that peer access is not supported across the given\n devices.\n"]
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = 217,
    #[doc = " This indicates that a PTX JIT compilation failed.\n"]
    CUDA_ERROR_INVALID_PTX = 218,
    #[doc = " This indicates an error with OpenGL or DirectX context.\n"]
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = 219,
    #[doc = " This indicates that an uncorrectable NVLink error was detected during the\n execution.\n"]
    CUDA_ERROR_NVLINK_UNCORRECTABLE = 220,
    #[doc = " This indicates that the PTX JIT compiler library was not found.\n"]
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = 221,
    #[doc = " This indicates that the provided PTX was compiled with an unsupported toolchain.\n"]
    CUDA_ERROR_UNSUPPORTED_PTX_VERSION = 222,
    #[doc = " This indicates that the PTX JIT compilation was disabled.\n"]
    CUDA_ERROR_JIT_COMPILATION_DISABLED = 223,
    #[doc = " This indicates that the [CUexecAffinityType](crate::ffi::CUexecAffinityType) passed to the API call is not\n supported by the active device.\n"]
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = 224,
    #[doc = " This indicates that the code to be compiled by the PTX JIT contains\n unsupported call to cudaDeviceSynchronize.\n"]
    CUDA_ERROR_UNSUPPORTED_DEVSIDE_SYNC = 225,
    #[doc = " This indicates that an exception occurred on the device that is now\n contained by the GPU's error containment capability. Common causes are -\n a. Certain types of invalid accesses of peer GPU memory over nvlink\n b. Certain classes of hardware errors\n This leaves the process in an inconsistent state and any further CUDA\n work will return the same error. To continue using CUDA, the process must\n be terminated and relaunched.\n"]
    CUDA_ERROR_CONTAINED = 226,
    #[doc = " This indicates that the device kernel source is invalid. This includes\n compilation/linker errors encountered in device code or user error.\n"]
    CUDA_ERROR_INVALID_SOURCE = 300,
    #[doc = " This indicates that the file specified was not found.\n"]
    CUDA_ERROR_FILE_NOT_FOUND = 301,
    #[doc = " This indicates that a link to a shared object failed to resolve.\n"]
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,
    #[doc = " This indicates that initialization of a shared object failed.\n"]
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = 303,
    #[doc = " This indicates that an OS call failed.\n"]
    CUDA_ERROR_OPERATING_SYSTEM = 304,
    #[doc = " This indicates that a resource handle passed to the API call was not\n valid. Resource handles are opaque types like [CUstream](crate::ffi::CUstream) and [CUevent](crate::ffi::CUevent).\n"]
    CUDA_ERROR_INVALID_HANDLE = 400,
    #[doc = " This indicates that a resource required by the API call is not in a\n valid state to perform the requested operation.\n"]
    CUDA_ERROR_ILLEGAL_STATE = 401,
    #[doc = " This indicates an attempt was made to introspect an object in a way that\n would discard semantically important information. This is either due to\n the object using funtionality newer than the API version used to\n introspect it or omission of optional return arguments.\n"]
    CUDA_ERROR_LOSSY_QUERY = 402,
    #[doc = " This indicates that a named symbol was not found. Examples of symbols\n are global/constant variable names, driver function names, texture names,\n and surface names.\n"]
    CUDA_ERROR_NOT_FOUND = 500,
    #[doc = " This indicates that asynchronous operations issued previously have not\n completed yet. This result is not actually an error, but must be indicated\n differently than [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) (which indicates completion). Calls that\n may return this value include [cuEventQuery](crate::ffi::cuEventQuery)() and [cuStreamQuery](crate::ffi::cuStreamQuery)().\n"]
    CUDA_ERROR_NOT_READY = 600,
    #[doc = " While executing a kernel, the device encountered a\n load or store instruction on an invalid memory address.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_ILLEGAL_ADDRESS = 700,
    #[doc = " This indicates that a launch did not occur because it did not have\n appropriate resources. This error usually indicates that the user has\n attempted to pass too many arguments to the device kernel, or the\n kernel launch specifies too many threads for the kernel's register\n count. Passing arguments of the wrong size (i.e. a 64-bit pointer\n when a 32-bit int is expected) is equivalent to passing too many\n arguments and can also result in this error.\n"]
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = 701,
    #[doc = " This indicates that the device kernel took too long to execute. This can\n only occur if timeouts are enabled - see the device attribute\n [CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT](crate::ffi::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT) for more information.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,
    #[doc = " This error indicates a kernel launch that uses an incompatible texturing\n mode.\n"]
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = 703,
    #[doc = " This error indicates that a call to [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess)() is\n trying to re-enable peer access to a context which has already\n had peer access to it enabled.\n"]
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,
    #[doc = " This error indicates that [cuCtxDisablePeerAccess](crate::ffi::cuCtxDisablePeerAccess)() is\n trying to disable peer access which has not been enabled yet\n via [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess)().\n"]
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = 705,
    #[doc = " This error indicates that the primary context for the specified device\n has already been initialized.\n"]
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708,
    #[doc = " This error indicates that the context current to the calling thread\n has been destroyed using [cuCtxDestroy](crate::ffi::cuCtxDestroy), or is a primary context which\n has not yet been initialized.\n"]
    CUDA_ERROR_CONTEXT_IS_DESTROYED = 709,
    #[doc = " A device-side assert triggered during kernel execution. The context\n cannot be used anymore, and must be destroyed. All existing device\n memory allocations from this context are invalid and must be\n reconstructed if the program is to continue using CUDA.\n"]
    CUDA_ERROR_ASSERT = 710,
    #[doc = " This error indicates that the hardware resources required to enable\n peer access have been exhausted for one or more of the devices\n passed to [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess)().\n"]
    CUDA_ERROR_TOO_MANY_PEERS = 711,
    #[doc = " This error indicates that the memory range passed to [cuMemHostRegister](crate::ffi::cuMemHostRegister)()\n has already been registered.\n"]
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,
    #[doc = " This error indicates that the pointer passed to [cuMemHostUnregister](crate::ffi::cuMemHostUnregister)()\n does not correspond to any currently registered memory region.\n"]
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = 713,
    #[doc = " While executing a kernel, the device encountered a stack error.\n This can be due to stack corruption or exceeding the stack size limit.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_HARDWARE_STACK_ERROR = 714,
    #[doc = " While executing a kernel, the device encountered an illegal instruction.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_ILLEGAL_INSTRUCTION = 715,
    #[doc = " While executing a kernel, the device encountered a load or store instruction\n on a memory address which is not aligned.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_MISALIGNED_ADDRESS = 716,
    #[doc = " While executing a kernel, the device encountered an instruction\n which can only operate on memory locations in certain address spaces\n (global, shared, or local), but was supplied a memory address not\n belonging to an allowed address space.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_INVALID_ADDRESS_SPACE = 717,
    #[doc = " While executing a kernel, the device program counter wrapped its address space.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_INVALID_PC = 718,
    #[doc = " An exception occurred on the device while executing a kernel. Common\n causes include dereferencing an invalid device pointer and accessing\n out of bounds shared memory. Less common cases can be system specific - more\n information about these cases can be found in the system specific user guide.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched.\n"]
    CUDA_ERROR_LAUNCH_FAILED = 719,
    #[doc = " This error indicates that the number of blocks launched per grid for a kernel that was\n launched via either [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel) or [cuLaunchCooperativeKernelMultiDevice](crate::ffi::cuLaunchCooperativeKernelMultiDevice)\n exceeds the maximum number of blocks as allowed by [cuOccupancyMaxActiveBlocksPerMultiprocessor](crate::ffi::cuOccupancyMaxActiveBlocksPerMultiprocessor)\n or [cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](crate::ffi::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) times the number of multiprocessors\n as specified by the device attribute [CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT](crate::ffi::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT).\n"]
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720,
    #[doc = " An exception occurred on the device while exiting a kernel using tensor memory: the\n tensor memory was not completely deallocated. This leaves the process in an inconsistent\n state and any further CUDA work will return the same error. To continue using CUDA, the\n process must be terminated and relaunched.\n"]
    CUDA_ERROR_TENSOR_MEMORY_LEAK = 721,
    #[doc = " This error indicates that the attempted operation is not permitted.\n"]
    CUDA_ERROR_NOT_PERMITTED = 800,
    #[doc = " This error indicates that the attempted operation is not supported\n on the current system or device.\n"]
    CUDA_ERROR_NOT_SUPPORTED = 801,
    #[doc = " This error indicates that the system is not yet ready to start any CUDA\n work.  To continue using CUDA, verify the system configuration is in a\n valid state and all required driver daemons are actively running.\n More information about this error can be found in the system specific\n user guide.\n"]
    CUDA_ERROR_SYSTEM_NOT_READY = 802,
    #[doc = " This error indicates that there is a mismatch between the versions of\n the display driver and the CUDA driver. Refer to the compatibility documentation\n for supported versions.\n"]
    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = 803,
    #[doc = " This error indicates that the system was upgraded to run with forward compatibility\n but the visible hardware detected by CUDA does not support this configuration.\n Refer to the compatibility documentation for the supported hardware matrix or ensure\n that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES\n environment variable.\n"]
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = 804,
    #[doc = " This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server.\n"]
    CUDA_ERROR_MPS_CONNECTION_FAILED = 805,
    #[doc = " This error indicates that the remote procedural call between the MPS server and the MPS client failed.\n"]
    CUDA_ERROR_MPS_RPC_FAILURE = 806,
    #[doc = " This error indicates that the MPS server is not ready to accept new MPS client requests.\n This error can be returned when the MPS server is in the process of recovering from a fatal failure.\n"]
    CUDA_ERROR_MPS_SERVER_NOT_READY = 807,
    #[doc = " This error indicates that the hardware resources required to create MPS client have been exhausted.\n"]
    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = 808,
    #[doc = " This error indicates the the hardware resources required to support device connections have been exhausted.\n"]
    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = 809,
    #[doc = " This error indicates that the MPS client has been terminated by the server. To continue using CUDA, the process must be terminated and relaunched.\n"]
    CUDA_ERROR_MPS_CLIENT_TERMINATED = 810,
    #[doc = " This error indicates that the module is using CUDA Dynamic Parallelism, but the current configuration, like MPS, does not support it.\n"]
    CUDA_ERROR_CDP_NOT_SUPPORTED = 811,
    #[doc = " This error indicates that a module contains an unsupported interaction between different versions of CUDA Dynamic Parallelism.\n"]
    CUDA_ERROR_CDP_VERSION_MISMATCH = 812,
    #[doc = " This error indicates that the operation is not permitted when\n the stream is capturing.\n"]
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900,
    #[doc = " This error indicates that the current capture sequence on the stream\n has been invalidated due to a previous error.\n"]
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = 901,
    #[doc = " This error indicates that the operation would have resulted in a merge\n of two independent capture sequences.\n"]
    CUDA_ERROR_STREAM_CAPTURE_MERGE = 902,
    #[doc = " This error indicates that the capture was not initiated in this stream.\n"]
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = 903,
    #[doc = " This error indicates that the capture sequence contains a fork that was\n not joined to the primary stream.\n"]
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = 904,
    #[doc = " This error indicates that a dependency would have been created which\n crosses the capture sequence boundary. Only implicit in-stream ordering\n dependencies are allowed to cross the boundary.\n"]
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = 905,
    #[doc = " This error indicates a disallowed implicit dependency on a current capture\n sequence from cudaStreamLegacy.\n"]
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = 906,
    #[doc = " This error indicates that the operation is not permitted on an event which\n was last recorded in a capturing stream.\n"]
    CUDA_ERROR_CAPTURED_EVENT = 907,
    #[doc = " A stream capture sequence not initiated with the [CU_STREAM_CAPTURE_MODE_RELAXED](crate::ffi::CU_STREAM_CAPTURE_MODE_RELAXED)\n argument to [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture) was passed to [cuStreamEndCapture](crate::ffi::cuStreamEndCapture) in a\n different thread.\n"]
    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = 908,
    #[doc = " This error indicates that the timeout specified for the wait operation has lapsed.\n"]
    CUDA_ERROR_TIMEOUT = 909,
    #[doc = " This error indicates that the graph update was not performed because it included\n changes which violated constraints specific to instantiated graph update.\n"]
    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = 910,
    #[doc = " This indicates that an async error has occurred in a device outside of CUDA.\n If CUDA was waiting for an external device's signal before consuming shared data,\n the external device signaled an error indicating that the data is not valid for\n consumption. This leaves the process in an inconsistent state and any further CUDA\n work will return the same error. To continue using CUDA, the process must be\n terminated and relaunched.\n"]
    CUDA_ERROR_EXTERNAL_DEVICE = 911,
    #[doc = " Indicates a kernel launch error due to cluster misconfiguration.\n"]
    CUDA_ERROR_INVALID_CLUSTER_SIZE = 912,
    #[doc = " Indiciates a function handle is not loaded when calling an API that requires\n a loaded function.\n"]
    CUDA_ERROR_FUNCTION_NOT_LOADED = 913,
    #[doc = " This error indicates one or more resources passed in are not valid resource\n types for the operation.\n"]
    CUDA_ERROR_INVALID_RESOURCE_TYPE = 914,
    #[doc = " This error indicates one or more resources are insufficient or non-applicable for\n the operation.\n"]
    CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION = 915,
    #[doc = " This error indicates that an error happened during the key rotation\n sequence.\n"]
    CUDA_ERROR_KEY_ROTATION = 916,
    #[doc = " This indicates that an unknown internal error has occurred.\n"]
    CUDA_ERROR_UNKNOWN = 999,
}
#[doc = " Error codes\n"]
pub use self::cudaError_enum as CUresult;
impl CUdevice_P2PAttribute_enum {
    pub const CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED: CUdevice_P2PAttribute_enum =
        CUdevice_P2PAttribute_enum::CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED;
}
#[repr(u32)]
#[doc = " P2P Attributes\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdevice_P2PAttribute_enum {
    #[doc = "< A relative value indicating the performance of the link between two devices\n"]
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1,
    #[doc = "< P2P Access is enable\n"]
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = 2,
    #[doc = "< Atomic operation over the link supported\n"]
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = 3,
    #[doc = "< \\deprecated use CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED instead\n"]
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = 4,
}
#[doc = " P2P Attributes\n"]
pub use self::CUdevice_P2PAttribute_enum as CUdevice_P2PAttribute;
#[doc = " CUDA stream callback\n#### hStream:\nThe stream the callback was added to, as passed to [cuStreamAddCallback](crate::ffi::cuStreamAddCallback).  May be NULL.\n#### status:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) or any persistent error on the stream.\n#### userData:\nUser parameter provided at registration.\n"]
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(hStream: CUstream, status: CUresult, userData: *mut ::std::ffi::c_void),
>;
#[doc = " Block size to per-block dynamic shared memory mapping for a certain\n kernel `aram` blockSize Block size of the kernel.\n### Returns:\nThe dynamic shared memory needed by a block.\n"]
pub type CUoccupancyB2DSize =
    ::std::option::Option<unsafe extern "C" fn(blockSize: ::std::ffi::c_int) -> usize>;
#[doc = " 2D memory copy parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY2D_st {
    #[doc = "< Source X in bytes\n"]
    pub srcXInBytes: usize,
    #[doc = "< Source Y\n"]
    pub srcY: usize,
    #[doc = "< Source memory type (host, device, array)\n"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer\n"]
    pub srcHost: *const ::std::ffi::c_void,
    #[doc = "< Source device pointer\n"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference\n"]
    pub srcArray: CUarray,
    #[doc = "< Source pitch (ignored when src is array)\n"]
    pub srcPitch: usize,
    #[doc = "< Destination X in bytes\n"]
    pub dstXInBytes: usize,
    #[doc = "< Destination Y\n"]
    pub dstY: usize,
    #[doc = "< Destination memory type (host, device, array)\n"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer\n"]
    pub dstHost: *mut ::std::ffi::c_void,
    #[doc = "< Destination device pointer\n"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference\n"]
    pub dstArray: CUarray,
    #[doc = "< Destination pitch (ignored when dst is array)\n"]
    pub dstPitch: usize,
    #[doc = "< Width of 2D memory copy in bytes\n"]
    pub WidthInBytes: usize,
    #[doc = "< Height of 2D memory copy\n"]
    pub Height: usize,
}
#[doc = " 2D memory copy parameters\n"]
pub type CUDA_MEMCPY2D_v2 = CUDA_MEMCPY2D_st;
#[doc = " 2D memory copy parameters\n"]
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_v2;
#[doc = " 3D memory copy parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_st {
    #[doc = "< Source X in bytes\n"]
    pub srcXInBytes: usize,
    #[doc = "< Source Y\n"]
    pub srcY: usize,
    #[doc = "< Source Z\n"]
    pub srcZ: usize,
    #[doc = "< Source LOD\n"]
    pub srcLOD: usize,
    #[doc = "< Source memory type (host, device, array)\n"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer\n"]
    pub srcHost: *const ::std::ffi::c_void,
    #[doc = "< Source device pointer\n"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference\n"]
    pub srcArray: CUarray,
    #[doc = "< Must be NULL\n"]
    pub reserved0: *mut ::std::ffi::c_void,
    #[doc = "< Source pitch (ignored when src is array)\n"]
    pub srcPitch: usize,
    #[doc = "< Source height (ignored when src is array; may be 0 if Depth==1)\n"]
    pub srcHeight: usize,
    #[doc = "< Destination X in bytes\n"]
    pub dstXInBytes: usize,
    #[doc = "< Destination Y\n"]
    pub dstY: usize,
    #[doc = "< Destination Z\n"]
    pub dstZ: usize,
    #[doc = "< Destination LOD\n"]
    pub dstLOD: usize,
    #[doc = "< Destination memory type (host, device, array)\n"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer\n"]
    pub dstHost: *mut ::std::ffi::c_void,
    #[doc = "< Destination device pointer\n"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference\n"]
    pub dstArray: CUarray,
    #[doc = "< Must be NULL\n"]
    pub reserved1: *mut ::std::ffi::c_void,
    #[doc = "< Destination pitch (ignored when dst is array)\n"]
    pub dstPitch: usize,
    #[doc = "< Destination height (ignored when dst is array; may be 0 if Depth==1)\n"]
    pub dstHeight: usize,
    #[doc = "< Width of 3D memory copy in bytes\n"]
    pub WidthInBytes: usize,
    #[doc = "< Height of 3D memory copy\n"]
    pub Height: usize,
    #[doc = "< Depth of 3D memory copy\n"]
    pub Depth: usize,
}
#[doc = " 3D memory copy parameters\n"]
pub type CUDA_MEMCPY3D_v2 = CUDA_MEMCPY3D_st;
#[doc = " 3D memory copy parameters\n"]
pub type CUDA_MEMCPY3D = CUDA_MEMCPY3D_v2;
#[doc = " 3D memory cross-context copy parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_PEER_st {
    #[doc = "< Source X in bytes\n"]
    pub srcXInBytes: usize,
    #[doc = "< Source Y\n"]
    pub srcY: usize,
    #[doc = "< Source Z\n"]
    pub srcZ: usize,
    #[doc = "< Source LOD\n"]
    pub srcLOD: usize,
    #[doc = "< Source memory type (host, device, array)\n"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer\n"]
    pub srcHost: *const ::std::ffi::c_void,
    #[doc = "< Source device pointer\n"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference\n"]
    pub srcArray: CUarray,
    #[doc = "< Source context (ignored with srcMemoryType is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY))\n"]
    pub srcContext: CUcontext,
    #[doc = "< Source pitch (ignored when src is array)\n"]
    pub srcPitch: usize,
    #[doc = "< Source height (ignored when src is array; may be 0 if Depth==1)\n"]
    pub srcHeight: usize,
    #[doc = "< Destination X in bytes\n"]
    pub dstXInBytes: usize,
    #[doc = "< Destination Y\n"]
    pub dstY: usize,
    #[doc = "< Destination Z\n"]
    pub dstZ: usize,
    #[doc = "< Destination LOD\n"]
    pub dstLOD: usize,
    #[doc = "< Destination memory type (host, device, array)\n"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer\n"]
    pub dstHost: *mut ::std::ffi::c_void,
    #[doc = "< Destination device pointer\n"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference\n"]
    pub dstArray: CUarray,
    #[doc = "< Destination context (ignored with dstMemoryType is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY))\n"]
    pub dstContext: CUcontext,
    #[doc = "< Destination pitch (ignored when dst is array)\n"]
    pub dstPitch: usize,
    #[doc = "< Destination height (ignored when dst is array; may be 0 if Depth==1)\n"]
    pub dstHeight: usize,
    #[doc = "< Width of 3D memory copy in bytes\n"]
    pub WidthInBytes: usize,
    #[doc = "< Height of 3D memory copy\n"]
    pub Height: usize,
    #[doc = "< Depth of 3D memory copy\n"]
    pub Depth: usize,
}
#[doc = " 3D memory cross-context copy parameters\n"]
pub type CUDA_MEMCPY3D_PEER_v1 = CUDA_MEMCPY3D_PEER_st;
#[doc = " 3D memory cross-context copy parameters\n"]
pub type CUDA_MEMCPY3D_PEER = CUDA_MEMCPY3D_PEER_v1;
#[doc = " Memcpy node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY_NODE_PARAMS_st {
    #[doc = "< Must be zero\n"]
    pub flags: ::std::ffi::c_int,
    #[doc = "< Must be zero\n"]
    pub reserved: ::std::ffi::c_int,
    #[doc = "< Context on which to run the node\n"]
    pub copyCtx: CUcontext,
    #[doc = "< Parameters for the memory copy\n"]
    pub copyParams: CUDA_MEMCPY3D,
}
#[doc = " Memcpy node parameters\n"]
pub type CUDA_MEMCPY_NODE_PARAMS = CUDA_MEMCPY_NODE_PARAMS_st;
#[doc = " Array descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    #[doc = "< Width of array\n"]
    pub Width: usize,
    #[doc = "< Height of array\n"]
    pub Height: usize,
    #[doc = "< Array format\n"]
    pub Format: CUarray_format,
    #[doc = "< Channels per array element\n"]
    pub NumChannels: ::std::ffi::c_uint,
}
#[doc = " Array descriptor\n"]
pub type CUDA_ARRAY_DESCRIPTOR_v2 = CUDA_ARRAY_DESCRIPTOR_st;
#[doc = " Array descriptor\n"]
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_v2;
#[doc = " 3D array descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    #[doc = "< Width of 3D array\n"]
    pub Width: usize,
    #[doc = "< Height of 3D array\n"]
    pub Height: usize,
    #[doc = "< Depth of 3D array\n"]
    pub Depth: usize,
    #[doc = "< Array format\n"]
    pub Format: CUarray_format,
    #[doc = "< Channels per array element\n"]
    pub NumChannels: ::std::ffi::c_uint,
    #[doc = "< Flags\n"]
    pub Flags: ::std::ffi::c_uint,
}
#[doc = " 3D array descriptor\n"]
pub type CUDA_ARRAY3D_DESCRIPTOR_v2 = CUDA_ARRAY3D_DESCRIPTOR_st;
#[doc = " 3D array descriptor\n"]
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_v2;
#[doc = " CUDA array sparse properties\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    pub tileExtent: CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1,
    #[doc = " First mip level at which the mip tail begins.\n"]
    pub miptailFirstLevel: ::std::ffi::c_uint,
    #[doc = " Total size of the mip tail.\n"]
    pub miptailSize: ::std::ffi::c_ulonglong,
    #[doc = " Flags will either be zero or [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](crate::ffi::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL)\n"]
    pub flags: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 {
    #[doc = "< Width of sparse tile in elements\n"]
    pub width: ::std::ffi::c_uint,
    #[doc = "< Height of sparse tile in elements\n"]
    pub height: ::std::ffi::c_uint,
    #[doc = "< Depth of sparse tile in elements\n"]
    pub depth: ::std::ffi::c_uint,
}
#[doc = " CUDA array sparse properties\n"]
pub type CUDA_ARRAY_SPARSE_PROPERTIES_v1 = CUDA_ARRAY_SPARSE_PROPERTIES_st;
#[doc = " CUDA array sparse properties\n"]
pub type CUDA_ARRAY_SPARSE_PROPERTIES = CUDA_ARRAY_SPARSE_PROPERTIES_v1;
#[doc = " CUDA array memory requirements\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_MEMORY_REQUIREMENTS_st {
    #[doc = "< Total required memory size\n"]
    pub size: usize,
    #[doc = "< alignment requirement\n"]
    pub alignment: usize,
    pub reserved: [::std::ffi::c_uint; 4usize],
}
#[doc = " CUDA array memory requirements\n"]
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS_v1 = CUDA_ARRAY_MEMORY_REQUIREMENTS_st;
#[doc = " CUDA array memory requirements\n"]
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS = CUDA_ARRAY_MEMORY_REQUIREMENTS_v1;
#[doc = " CUDA Resource descriptor\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    #[doc = "< Resource type\n"]
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)\n"]
    pub flags: ::std::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< CUDA array\n"]
    pub hArray: CUarray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< CUDA mipmapped array\n"]
    pub hMipmappedArray: CUmipmappedArray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer\n"]
    pub devPtr: CUdeviceptr,
    #[doc = "< Array format\n"]
    pub format: CUarray_format,
    #[doc = "< Channels per array element\n"]
    pub numChannels: ::std::ffi::c_uint,
    #[doc = "< Size in bytes\n"]
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer\n"]
    pub devPtr: CUdeviceptr,
    #[doc = "< Array format\n"]
    pub format: CUarray_format,
    #[doc = "< Channels per array element\n"]
    pub numChannels: ::std::ffi::c_uint,
    #[doc = "< Width of the array in elements\n"]
    pub width: usize,
    #[doc = "< Height of the array in elements\n"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes\n"]
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::ffi::c_int; 32usize],
}
#[doc = " CUDA Resource descriptor\n"]
pub type CUDA_RESOURCE_DESC_v1 = CUDA_RESOURCE_DESC_st;
#[doc = " CUDA Resource descriptor\n"]
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_v1;
#[doc = " Texture descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_TEXTURE_DESC_st {
    #[doc = "< Address modes\n"]
    pub addressMode: [CUaddress_mode; 3usize],
    #[doc = "< Filter mode\n"]
    pub filterMode: CUfilter_mode,
    #[doc = "< Flags\n"]
    pub flags: ::std::ffi::c_uint,
    #[doc = "< Maximum anisotropy ratio\n"]
    pub maxAnisotropy: ::std::ffi::c_uint,
    #[doc = "< Mipmap filter mode\n"]
    pub mipmapFilterMode: CUfilter_mode,
    #[doc = "< Mipmap level bias\n"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp\n"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp\n"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color\n"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::ffi::c_int; 12usize],
}
#[doc = " Texture descriptor\n"]
pub type CUDA_TEXTURE_DESC_v1 = CUDA_TEXTURE_DESC_st;
#[doc = " Texture descriptor\n"]
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_v1;
#[repr(u32)]
#[doc = " Resource view format\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUresourceViewFormat_enum {
    #[doc = "< No resource view format (use underlying resource format)\n"]
    CU_RES_VIEW_FORMAT_NONE = 0,
    #[doc = "< 1 channel unsigned 8-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_1X8 = 1,
    #[doc = "< 2 channel unsigned 8-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_2X8 = 2,
    #[doc = "< 4 channel unsigned 8-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_4X8 = 3,
    #[doc = "< 1 channel signed 8-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_1X8 = 4,
    #[doc = "< 2 channel signed 8-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_2X8 = 5,
    #[doc = "< 4 channel signed 8-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_4X8 = 6,
    #[doc = "< 1 channel unsigned 16-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_1X16 = 7,
    #[doc = "< 2 channel unsigned 16-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_2X16 = 8,
    #[doc = "< 4 channel unsigned 16-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_4X16 = 9,
    #[doc = "< 1 channel signed 16-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_1X16 = 10,
    #[doc = "< 2 channel signed 16-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_2X16 = 11,
    #[doc = "< 4 channel signed 16-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_4X16 = 12,
    #[doc = "< 1 channel unsigned 32-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_1X32 = 13,
    #[doc = "< 2 channel unsigned 32-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_2X32 = 14,
    #[doc = "< 4 channel unsigned 32-bit integers\n"]
    CU_RES_VIEW_FORMAT_UINT_4X32 = 15,
    #[doc = "< 1 channel signed 32-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_1X32 = 16,
    #[doc = "< 2 channel signed 32-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_2X32 = 17,
    #[doc = "< 4 channel signed 32-bit integers\n"]
    CU_RES_VIEW_FORMAT_SINT_4X32 = 18,
    #[doc = "< 1 channel 16-bit floating point\n"]
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = 19,
    #[doc = "< 2 channel 16-bit floating point\n"]
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = 20,
    #[doc = "< 4 channel 16-bit floating point\n"]
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = 21,
    #[doc = "< 1 channel 32-bit floating point\n"]
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = 22,
    #[doc = "< 2 channel 32-bit floating point\n"]
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = 23,
    #[doc = "< 4 channel 32-bit floating point\n"]
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = 24,
    #[doc = "< Block compressed 1\n"]
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = 25,
    #[doc = "< Block compressed 2\n"]
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = 26,
    #[doc = "< Block compressed 3\n"]
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = 27,
    #[doc = "< Block compressed 4 unsigned\n"]
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = 28,
    #[doc = "< Block compressed 4 signed\n"]
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = 29,
    #[doc = "< Block compressed 5 unsigned\n"]
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = 30,
    #[doc = "< Block compressed 5 signed\n"]
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = 31,
    #[doc = "< Block compressed 6 unsigned half-float\n"]
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 32,
    #[doc = "< Block compressed 6 signed half-float\n"]
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = 33,
    #[doc = "< Block compressed 7\n"]
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = 34,
}
#[doc = " Resource view format\n"]
pub use self::CUresourceViewFormat_enum as CUresourceViewFormat;
#[doc = " Resource view descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format\n"]
    pub format: CUresourceViewFormat,
    #[doc = "< Width of the resource view\n"]
    pub width: usize,
    #[doc = "< Height of the resource view\n"]
    pub height: usize,
    #[doc = "< Depth of the resource view\n"]
    pub depth: usize,
    #[doc = "< First defined mipmap level\n"]
    pub firstMipmapLevel: ::std::ffi::c_uint,
    #[doc = "< Last defined mipmap level\n"]
    pub lastMipmapLevel: ::std::ffi::c_uint,
    #[doc = "< First layer index\n"]
    pub firstLayer: ::std::ffi::c_uint,
    #[doc = "< Last layer index\n"]
    pub lastLayer: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 16usize],
}
#[doc = " Resource view descriptor\n"]
pub type CUDA_RESOURCE_VIEW_DESC_v1 = CUDA_RESOURCE_VIEW_DESC_st;
#[doc = " Resource view descriptor\n"]
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_v1;
#[doc = " Tensor map descriptor. Requires compiler support for aligning to 64 bytes.\n"]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct CUtensorMap_st {
    pub opaque: [cuuint64_t; 16usize],
}
#[doc = " Tensor map descriptor. Requires compiler support for aligning to 64 bytes.\n"]
pub type CUtensorMap = CUtensorMap_st;
#[repr(u32)]
#[doc = " Tensor map data type\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUtensorMapDataType_enum {
    CU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,
    CU_TENSOR_MAP_DATA_TYPE_UINT16 = 1,
    CU_TENSOR_MAP_DATA_TYPE_UINT32 = 2,
    CU_TENSOR_MAP_DATA_TYPE_INT32 = 3,
    CU_TENSOR_MAP_DATA_TYPE_UINT64 = 4,
    CU_TENSOR_MAP_DATA_TYPE_INT64 = 5,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT16 = 6,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32 = 7,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT64 = 8,
    CU_TENSOR_MAP_DATA_TYPE_BFLOAT16 = 9,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ = 10,
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32 = 11,
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ = 12,
    CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B = 13,
    CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B = 14,
    CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B = 15,
}
#[doc = " Tensor map data type\n"]
pub use self::CUtensorMapDataType_enum as CUtensorMapDataType;
#[repr(u32)]
#[doc = " Tensor map interleave layout type\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUtensorMapInterleave_enum {
    CU_TENSOR_MAP_INTERLEAVE_NONE = 0,
    CU_TENSOR_MAP_INTERLEAVE_16B = 1,
    CU_TENSOR_MAP_INTERLEAVE_32B = 2,
}
#[doc = " Tensor map interleave layout type\n"]
pub use self::CUtensorMapInterleave_enum as CUtensorMapInterleave;
#[repr(u32)]
#[doc = " Tensor map swizzling mode of shared memory banks\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUtensorMapSwizzle_enum {
    CU_TENSOR_MAP_SWIZZLE_NONE = 0,
    CU_TENSOR_MAP_SWIZZLE_32B = 1,
    CU_TENSOR_MAP_SWIZZLE_64B = 2,
    CU_TENSOR_MAP_SWIZZLE_128B = 3,
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B = 4,
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B = 5,
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B = 6,
}
#[doc = " Tensor map swizzling mode of shared memory banks\n"]
pub use self::CUtensorMapSwizzle_enum as CUtensorMapSwizzle;
#[repr(u32)]
#[doc = " Tensor map L2 promotion type\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUtensorMapL2promotion_enum {
    CU_TENSOR_MAP_L2_PROMOTION_NONE = 0,
    CU_TENSOR_MAP_L2_PROMOTION_L2_64B = 1,
    CU_TENSOR_MAP_L2_PROMOTION_L2_128B = 2,
    CU_TENSOR_MAP_L2_PROMOTION_L2_256B = 3,
}
#[doc = " Tensor map L2 promotion type\n"]
pub use self::CUtensorMapL2promotion_enum as CUtensorMapL2promotion;
#[repr(u32)]
#[doc = " Tensor map out-of-bounds fill type\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUtensorMapFloatOOBfill_enum {
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA = 1,
}
#[doc = " Tensor map out-of-bounds fill type\n"]
pub use self::CUtensorMapFloatOOBfill_enum as CUtensorMapFloatOOBfill;
#[repr(u32)]
#[doc = " Tensor map Im2Col wide mode\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUtensorMapIm2ColWideMode_enum {
    CU_TENSOR_MAP_IM2COL_WIDE_MODE_W = 0,
    CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128 = 1,
}
#[doc = " Tensor map Im2Col wide mode\n"]
pub use self::CUtensorMapIm2ColWideMode_enum as CUtensorMapIm2ColWideMode;
#[doc = " GPU Direct v3 tokens\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    pub p2pToken: ::std::ffi::c_ulonglong,
    pub vaSpaceToken: ::std::ffi::c_uint,
}
#[doc = " GPU Direct v3 tokens\n"]
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st;
#[doc = " GPU Direct v3 tokens\n"]
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
#[repr(u32)]
#[doc = " Access flags that specify the level of access the current context's device has\n on the memory referenced.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum {
    #[doc = "< No access, meaning the device cannot access this memory at all, thus must be staged through accessible memory in order to complete certain operations\n"]
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = 0,
    #[doc = "< Read-only access, meaning writes to this memory are considered invalid accesses and thus return error in that case.\n"]
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = 1,
    #[doc = "< Read-write access, the device has full read-write access to the memory\n"]
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = 3,
}
#[doc = " Access flags that specify the level of access the current context's device has\n on the memory referenced.\n"]
pub use self::CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum as CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;
#[doc = " Kernel launch parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_LAUNCH_PARAMS_st {
    #[doc = "< Kernel to launch\n"]
    pub function: CUfunction,
    #[doc = "< Width of grid in blocks\n"]
    pub gridDimX: ::std::ffi::c_uint,
    #[doc = "< Height of grid in blocks\n"]
    pub gridDimY: ::std::ffi::c_uint,
    #[doc = "< Depth of grid in blocks\n"]
    pub gridDimZ: ::std::ffi::c_uint,
    #[doc = "< X dimension of each thread block\n"]
    pub blockDimX: ::std::ffi::c_uint,
    #[doc = "< Y dimension of each thread block\n"]
    pub blockDimY: ::std::ffi::c_uint,
    #[doc = "< Z dimension of each thread block\n"]
    pub blockDimZ: ::std::ffi::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes\n"]
    pub sharedMemBytes: ::std::ffi::c_uint,
    #[doc = "< Stream identifier\n"]
    pub hStream: CUstream,
    #[doc = "< Array of pointers to kernel parameters\n"]
    pub kernelParams: *mut *mut ::std::ffi::c_void,
}
#[doc = " Kernel launch parameters\n"]
pub type CUDA_LAUNCH_PARAMS_v1 = CUDA_LAUNCH_PARAMS_st;
#[doc = " Kernel launch parameters\n"]
pub type CUDA_LAUNCH_PARAMS = CUDA_LAUNCH_PARAMS_v1;
#[repr(u32)]
#[doc = " External memory handle types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUexternalMemoryHandleType_enum {
    #[doc = " Handle is an opaque file descriptor\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1,
    #[doc = " Handle is an opaque shared NT handle\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    #[doc = " Handle is an opaque, globally shared handle\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    #[doc = " Handle is a D3D12 heap object\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4,
    #[doc = " Handle is a D3D12 committed resource\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5,
    #[doc = " Handle is a shared NT handle to a D3D11 resource\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = 6,
    #[doc = " Handle is a globally shared handle to a D3D11 resource\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,
    #[doc = " Handle is an NvSciBuf object\n"]
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = 8,
}
#[doc = " External memory handle types\n"]
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[doc = " External memory handle descriptor\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    #[doc = " Type of the handle\n"]
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    #[doc = " Size of the memory allocation\n"]
    pub size: ::std::ffi::c_ulonglong,
    #[doc = " Flags must either be zero or [CUDA_EXTERNAL_MEMORY_DEDICATED](crate::ffi::CUDA_EXTERNAL_MEMORY_DEDICATED)\n"]
    pub flags: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    #[doc = " File descriptor referencing the memory object. Valid\n when type is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD)\n"]
    pub fd: ::std::ffi::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    #[doc = " A handle representing an NvSciBuf Object. Valid when type\n is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF)\n"]
    pub nvSciBufObject: *const ::std::ffi::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32)\n - [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT)\n - [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP)\n - [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE)\n - [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE)\n - [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT)\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT)\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT)\n then 'name' must be NULL.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL\n"]
    pub handle: *mut ::std::ffi::c_void,
    #[doc = " Name of a valid memory object.\n Must be NULL if 'handle' is non-NULL.\n"]
    pub name: *const ::std::ffi::c_void,
}
#[doc = " External memory handle descriptor\n"]
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
#[doc = " External memory handle descriptor\n"]
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
#[doc = " External memory buffer descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    #[doc = " Offset into the memory object where the buffer's base is\n"]
    pub offset: ::std::ffi::c_ulonglong,
    #[doc = " Size of the buffer\n"]
    pub size: ::std::ffi::c_ulonglong,
    #[doc = " Flags reserved for future use. Must be zero.\n"]
    pub flags: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 16usize],
}
#[doc = " External memory buffer descriptor\n"]
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
#[doc = " External memory buffer descriptor\n"]
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
#[doc = " External memory mipmap descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    #[doc = " Offset into the memory object where the base level of the\n mipmap chain is.\n"]
    pub offset: ::std::ffi::c_ulonglong,
    #[doc = " Format, dimension and type of base level of the mipmap chain\n"]
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    #[doc = " Total number of levels in the mipmap chain\n"]
    pub numLevels: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 16usize],
}
#[doc = " External memory mipmap descriptor\n"]
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 =
    CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
#[doc = " External memory mipmap descriptor\n"]
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
#[repr(u32)]
#[doc = " External semaphore handle types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUexternalSemaphoreHandleType_enum {
    #[doc = " Handle is an opaque file descriptor\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1,
    #[doc = " Handle is an opaque shared NT handle\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    #[doc = " Handle is an opaque, globally shared handle\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    #[doc = " Handle is a shared NT handle referencing a D3D12 fence object\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4,
    #[doc = " Handle is a shared NT handle referencing a D3D11 fence object\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = 5,
    #[doc = " Opaque handle to NvSciSync Object\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = 6,
    #[doc = " Handle is a shared NT handle referencing a D3D11 keyed mutex object\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = 7,
    #[doc = " Handle is a globally shared handle referencing a D3D11 keyed mutex object\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = 8,
    #[doc = " Handle is an opaque file descriptor referencing a timeline semaphore\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9,
    #[doc = " Handle is an opaque shared NT handle referencing a timeline semaphore\n"]
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10,
}
#[doc = " External semaphore handle types\n"]
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[doc = " External semaphore handle descriptor\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    #[doc = " Type of the handle\n"]
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    #[doc = " Flags reserved for the future. Must be zero.\n"]
    pub flags: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    #[doc = " File descriptor referencing the semaphore object. Valid\n when type is one of the following:\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD)\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD)\n"]
    pub fd: ::std::ffi::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Valid NvSciSyncObj. Must be non NULL\n"]
    pub nvSciSyncObj: *const ::std::ffi::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32)\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT)\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE)\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE)\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX)\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32)\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT)\n - [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT)\n then 'name' must be NULL.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL\n"]
    pub handle: *mut ::std::ffi::c_void,
    #[doc = " Name of a valid synchronization primitive.\n Must be NULL if 'handle' is non-NULL.\n"]
    pub name: *const ::std::ffi::c_void,
}
#[doc = " External semaphore handle descriptor\n"]
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
#[doc = " External semaphore handle descriptor\n"]
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
#[doc = " External semaphore signal parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    #[doc = " Only when [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS) is used to\n signal a [CUexternalSemaphore](crate::ffi::CUexternalSemaphore) of type\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC), the valid flag is\n [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC) which indicates\n that while signaling the [CUexternalSemaphore](crate::ffi::CUexternalSemaphore), no memory synchronization\n operations should be performed for any external memory object imported\n as [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF).\n For all other types of [CUexternalSemaphore](crate::ffi::CUexternalSemaphore), flags must be zero.\n"]
    pub flags: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::ffi::c_uint; 12usize],
}
#[doc = " Parameters for fence objects\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be signaled\n"]
    pub value: ::std::ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if [CUexternalSemaphoreHandleType](crate::ffi::CUexternalSemaphoreHandleType)\n is of type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC).\n"]
    pub fence: *mut ::std::ffi::c_void,
    pub reserved: ::std::ffi::c_ulonglong,
}
#[doc = " Parameters for keyed mutex objects\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to release the mutex with\n"]
    pub key: ::std::ffi::c_ulonglong,
}
#[doc = " External semaphore signal parameters\n"]
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
#[doc = " External semaphore signal parameters\n"]
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
#[doc = " External semaphore wait parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
    #[doc = " Only when [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS) is used to wait on\n a [CUexternalSemaphore](crate::ffi::CUexternalSemaphore) of type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC),\n the valid flag is [CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC)\n which indicates that while waiting for the [CUexternalSemaphore](crate::ffi::CUexternalSemaphore), no memory\n synchronization operations should be performed for any external memory\n object imported as [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF).\n For all other types of [CUexternalSemaphore](crate::ffi::CUexternalSemaphore), flags must be zero.\n"]
    pub flags: ::std::ffi::c_uint,
    pub reserved: [::std::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::ffi::c_uint; 10usize],
}
#[doc = " Parameters for fence objects\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be waited on\n"]
    pub value: ::std::ffi::c_ulonglong,
}
#[doc = " Pointer to NvSciSyncFence. Valid if CUexternalSemaphoreHandleType\n is of type CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::ffi::c_void,
    pub reserved: ::std::ffi::c_ulonglong,
}
#[doc = " Parameters for keyed mutex objects\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to acquire the mutex with\n"]
    pub key: ::std::ffi::c_ulonglong,
    #[doc = " Timeout in milliseconds to wait to acquire the mutex\n"]
    pub timeoutMs: ::std::ffi::c_uint,
}
#[doc = " External semaphore wait parameters\n"]
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st;
#[doc = " External semaphore wait parameters\n"]
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
#[doc = " Semaphore signal node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    #[doc = "< Array of external semaphore handles.\n"]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore signal parameters.\n"]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray.\n"]
    pub numExtSems: ::std::ffi::c_uint,
}
#[doc = " Semaphore signal node parameters\n"]
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st;
#[doc = " Semaphore signal node parameters\n"]
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
#[doc = " Semaphore signal node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st {
    #[doc = "< Array of external semaphore handles.\n"]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore signal parameters.\n"]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray.\n"]
    pub numExtSems: ::std::ffi::c_uint,
}
#[doc = " Semaphore signal node parameters\n"]
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st;
#[doc = " Semaphore wait node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    #[doc = "< Array of external semaphore handles.\n"]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore wait parameters.\n"]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray.\n"]
    pub numExtSems: ::std::ffi::c_uint,
}
#[doc = " Semaphore wait node parameters\n"]
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_st;
#[doc = " Semaphore wait node parameters\n"]
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
#[doc = " Semaphore wait node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st {
    #[doc = "< Array of external semaphore handles.\n"]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore wait parameters.\n"]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray.\n"]
    pub numExtSems: ::std::ffi::c_uint,
}
#[doc = " Semaphore wait node parameters\n"]
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st;
pub type CUmemGenericAllocationHandle_v1 = ::std::ffi::c_ulonglong;
pub type CUmemGenericAllocationHandle = CUmemGenericAllocationHandle_v1;
#[repr(u32)]
#[doc = " Flags for specifying particular handle types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemAllocationHandleType_enum {
    #[doc = "< Does not allow any export mechanism. >\n"]
    CU_MEM_HANDLE_TYPE_NONE = 0,
    #[doc = "< Allows a file descriptor to be used for exporting. Permitted only on POSIX systems. (int)\n"]
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = 1,
    #[doc = "< Allows a Win32 NT handle to be used for exporting. (HANDLE)\n"]
    CU_MEM_HANDLE_TYPE_WIN32 = 2,
    #[doc = "< Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)\n"]
    CU_MEM_HANDLE_TYPE_WIN32_KMT = 4,
    #[doc = "< Allows a fabric handle to be used for exporting. (CUmemFabricHandle)\n"]
    CU_MEM_HANDLE_TYPE_FABRIC = 8,
    CU_MEM_HANDLE_TYPE_MAX = 2147483647,
}
#[doc = " Flags for specifying particular handle types\n"]
pub use self::CUmemAllocationHandleType_enum as CUmemAllocationHandleType;
#[repr(u32)]
#[doc = " Specifies the memory protection flags for mapping.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemAccess_flags_enum {
    #[doc = "< Default, make the address range not accessible\n"]
    CU_MEM_ACCESS_FLAGS_PROT_NONE = 0,
    #[doc = "< Make the address range read accessible\n"]
    CU_MEM_ACCESS_FLAGS_PROT_READ = 1,
    #[doc = "< Make the address range read-write accessible\n"]
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE = 3,
    CU_MEM_ACCESS_FLAGS_PROT_MAX = 2147483647,
}
#[doc = " Specifies the memory protection flags for mapping.\n"]
pub use self::CUmemAccess_flags_enum as CUmemAccess_flags;
#[repr(u32)]
#[doc = " Specifies the type of location\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemLocationType_enum {
    CU_MEM_LOCATION_TYPE_INVALID = 0,
    #[doc = "< Location is a device location, thus id is a device ordinal\n"]
    CU_MEM_LOCATION_TYPE_DEVICE = 1,
    #[doc = "< Location is host, id is ignored\n"]
    CU_MEM_LOCATION_TYPE_HOST = 2,
    #[doc = "< Location is a host NUMA node, thus id is a host NUMA node id\n"]
    CU_MEM_LOCATION_TYPE_HOST_NUMA = 3,
    #[doc = "< Location is a host NUMA node of the current thread, id is ignored\n"]
    CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT = 4,
    CU_MEM_LOCATION_TYPE_MAX = 2147483647,
}
#[doc = " Specifies the type of location\n"]
pub use self::CUmemLocationType_enum as CUmemLocationType;
#[repr(u32)]
#[doc = " Defines the allocation types available\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemAllocationType_enum {
    CU_MEM_ALLOCATION_TYPE_INVALID = 0,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it\n"]
    CU_MEM_ALLOCATION_TYPE_PINNED = 1,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it\n"]
    CU_MEM_ALLOCATION_TYPE_MAX = 2147483647,
}
#[doc = " Defines the allocation types available\n"]
pub use self::CUmemAllocationType_enum as CUmemAllocationType;
#[repr(u32)]
#[doc = " Flag for requesting different optimal and required granularities for an allocation.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemAllocationGranularity_flags_enum {
    #[doc = "< Minimum required granularity for allocation\n"]
    CU_MEM_ALLOC_GRANULARITY_MINIMUM = 0,
    #[doc = "< Recommended granularity for allocation for best performance\n"]
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = 1,
}
#[doc = " Flag for requesting different optimal and required granularities for an allocation.\n"]
pub use self::CUmemAllocationGranularity_flags_enum as CUmemAllocationGranularity_flags;
#[repr(u32)]
#[doc = " Specifies the handle type for address range\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemRangeHandleType_enum {
    CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = 1,
    CU_MEM_RANGE_HANDLE_TYPE_MAX = 2147483647,
}
#[doc = " Specifies the handle type for address range\n"]
pub use self::CUmemRangeHandleType_enum as CUmemRangeHandleType;
#[repr(u32)]
#[doc = " Flag for requesting handle type for address range.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemRangeFlags_enum {
    #[doc = "< Indicates that DMA_BUF handle should be mapped via PCIe BAR1\n"]
    CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE = 1,
}
#[doc = " Flag for requesting handle type for address range.\n"]
pub use self::CUmemRangeFlags_enum as CUmemRangeFlags;
#[repr(u32)]
#[doc = " Sparse subresource types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUarraySparseSubresourceType_enum {
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1,
}
#[doc = " Sparse subresource types\n"]
pub use self::CUarraySparseSubresourceType_enum as CUarraySparseSubresourceType;
#[repr(u32)]
#[doc = " Memory operation types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemOperationType_enum {
    CU_MEM_OPERATION_TYPE_MAP = 1,
    CU_MEM_OPERATION_TYPE_UNMAP = 2,
}
#[doc = " Memory operation types\n"]
pub use self::CUmemOperationType_enum as CUmemOperationType;
#[repr(u32)]
#[doc = " Memory handle types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemHandleType_enum {
    CU_MEM_HANDLE_TYPE_GENERIC = 0,
}
#[doc = " Memory handle types\n"]
pub use self::CUmemHandleType_enum as CUmemHandleType;
#[doc = " Specifies the CUDA array or CUDA mipmapped array memory mapping information\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUarrayMapInfo_st {
    #[doc = "< Resource type\n"]
    pub resourceType: CUresourcetype,
    pub resource: CUarrayMapInfo_st__bindgen_ty_1,
    #[doc = "< Sparse subresource type\n"]
    pub subresourceType: CUarraySparseSubresourceType,
    pub subresource: CUarrayMapInfo_st__bindgen_ty_2,
    #[doc = "< Memory operation type\n"]
    pub memOperationType: CUmemOperationType,
    #[doc = "< Memory handle type\n"]
    pub memHandleType: CUmemHandleType,
    pub memHandle: CUarrayMapInfo_st__bindgen_ty_3,
    #[doc = "< Offset within the memory\n"]
    pub offset: ::std::ffi::c_ulonglong,
    #[doc = "< Device ordinal bit mask\n"]
    pub deviceBitMask: ::std::ffi::c_uint,
    #[doc = "< flags for future use, must be zero now.\n"]
    pub flags: ::std::ffi::c_uint,
    #[doc = "< Reserved for future use, must be zero now.\n"]
    pub reserved: [::std::ffi::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_1 {
    pub mipmap: CUmipmappedArray,
    pub array: CUarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_2 {
    pub sparseLevel: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1,
    pub miptail: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< For CUDA mipmapped arrays must a valid mipmap level. For CUDA arrays must be zero\n"]
    pub level: ::std::ffi::c_uint,
    #[doc = "< For CUDA layered arrays must be a valid layer index. Otherwise, must be zero\n"]
    pub layer: ::std::ffi::c_uint,
    #[doc = "< Starting X offset in elements\n"]
    pub offsetX: ::std::ffi::c_uint,
    #[doc = "< Starting Y offset in elements\n"]
    pub offsetY: ::std::ffi::c_uint,
    #[doc = "< Starting Z offset in elements\n"]
    pub offsetZ: ::std::ffi::c_uint,
    #[doc = "< Width in elements\n"]
    pub extentWidth: ::std::ffi::c_uint,
    #[doc = "< Height in elements\n"]
    pub extentHeight: ::std::ffi::c_uint,
    #[doc = "< Depth in elements\n"]
    pub extentDepth: ::std::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< For CUDA layered arrays must be a valid layer index. Otherwise, must be zero\n"]
    pub layer: ::std::ffi::c_uint,
    #[doc = "< Offset within mip tail\n"]
    pub offset: ::std::ffi::c_ulonglong,
    #[doc = "< Extent in bytes\n"]
    pub size: ::std::ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_3 {
    pub memHandle: CUmemGenericAllocationHandle,
}
#[doc = " Specifies the CUDA array or CUDA mipmapped array memory mapping information\n"]
pub type CUarrayMapInfo_v1 = CUarrayMapInfo_st;
#[doc = " Specifies the CUDA array or CUDA mipmapped array memory mapping information\n"]
pub type CUarrayMapInfo = CUarrayMapInfo_v1;
#[doc = " Specifies a memory location.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemLocation_st {
    #[doc = "< Specifies the location type, which modifies the meaning of id.\n"]
    pub type_: CUmemLocationType,
    #[doc = "< identifier for a given this location's [CUmemLocationType](crate::ffi::CUmemLocationType).\n"]
    pub id: ::std::ffi::c_int,
}
#[doc = " Specifies a memory location.\n"]
pub type CUmemLocation_v1 = CUmemLocation_st;
#[doc = " Specifies a memory location.\n"]
pub type CUmemLocation = CUmemLocation_v1;
#[repr(u32)]
#[doc = " Specifies compression attribute for an allocation.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemAllocationCompType_enum {
    #[doc = "< Allocating non-compressible memory\n"]
    CU_MEM_ALLOCATION_COMP_NONE = 0,
    #[doc = "< Allocating  compressible memory\n"]
    CU_MEM_ALLOCATION_COMP_GENERIC = 1,
}
#[doc = " Specifies compression attribute for an allocation.\n"]
pub use self::CUmemAllocationCompType_enum as CUmemAllocationCompType;
#[doc = " Specifies the allocation properties for a allocation.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st {
    #[doc = " Allocation type\n"]
    pub type_: CUmemAllocationType,
    #[doc = " requested [CUmemAllocationHandleType](crate::ffi::CUmemAllocationHandleType)\n"]
    pub requestedHandleTypes: CUmemAllocationHandleType,
    #[doc = " Location of allocation\n"]
    pub location: CUmemLocation,
    #[doc = " Windows-specific POBJECT_ATTRIBUTES required when\n [CU_MEM_HANDLE_TYPE_WIN32](crate::ffi::CU_MEM_HANDLE_TYPE_WIN32) is specified.  This object attributes structure\n includes security attributes that define\n the scope of which exported allocations may be transferred to other\n processes.  In all other cases, this field is required to be zero.\n"]
    pub win32HandleMetaData: *mut ::std::ffi::c_void,
    pub allocFlags: CUmemAllocationProp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st__bindgen_ty_1 {
    #[doc = " Allocation hint for requesting compressible memory.\n On devices that support Compute Data Compression, compressible\n memory can be used to accelerate accesses to data with unstructured\n sparsity and other compressible data patterns. Applications are\n expected to query allocation property of the handle obtained with\n [cuMemCreate](crate::ffi::cuMemCreate) using [cuMemGetAllocationPropertiesFromHandle](crate::ffi::cuMemGetAllocationPropertiesFromHandle) to\n validate if the obtained allocation is compressible or not. Note that\n compressed memory may not be mappable on all devices.\n"]
    pub compressionType: ::std::ffi::c_uchar,
    pub gpuDirectRDMACapable: ::std::ffi::c_uchar,
    #[doc = " Bitmask indicating intended usage for this allocation\n"]
    pub usage: ::std::ffi::c_ushort,
    pub reserved: [::std::ffi::c_uchar; 4usize],
}
#[doc = " Specifies the allocation properties for a allocation.\n"]
pub type CUmemAllocationProp_v1 = CUmemAllocationProp_st;
#[doc = " Specifies the allocation properties for a allocation.\n"]
pub type CUmemAllocationProp = CUmemAllocationProp_v1;
#[repr(u32)]
#[doc = " Flags for querying different granularities for a multicast object\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmulticastGranularity_flags_enum {
    #[doc = "< Minimum required granularity\n"]
    CU_MULTICAST_GRANULARITY_MINIMUM = 0,
    #[doc = "< Recommended granularity for best performance\n"]
    CU_MULTICAST_GRANULARITY_RECOMMENDED = 1,
}
#[doc = " Flags for querying different granularities for a multicast object\n"]
pub use self::CUmulticastGranularity_flags_enum as CUmulticastGranularity_flags;
#[doc = " Specifies the properties for a multicast object.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmulticastObjectProp_st {
    #[doc = " The number of devices in the multicast team that will bind memory to this\n object\n"]
    pub numDevices: ::std::ffi::c_uint,
    #[doc = " The maximum amount of memory that can be bound to this multicast object\n per device\n"]
    pub size: usize,
    #[doc = " Bitmask of exportable handle types (see [CUmemAllocationHandleType](crate::ffi::CUmemAllocationHandleType)) for\n this object\n"]
    pub handleTypes: ::std::ffi::c_ulonglong,
    #[doc = " Flags for future use, must be zero now\n"]
    pub flags: ::std::ffi::c_ulonglong,
}
#[doc = " Specifies the properties for a multicast object.\n"]
pub type CUmulticastObjectProp_v1 = CUmulticastObjectProp_st;
#[doc = " Specifies the properties for a multicast object.\n"]
pub type CUmulticastObjectProp = CUmulticastObjectProp_v1;
#[doc = " Memory access descriptor\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAccessDesc_st {
    #[doc = "< Location on which the request is to change it's accessibility\n"]
    pub location: CUmemLocation,
    #[doc = "< [CUmemProt](crate::ffi::CUmemProt) accessibility flags to set on the request\n"]
    pub flags: CUmemAccess_flags,
}
#[doc = " Memory access descriptor\n"]
pub type CUmemAccessDesc_v1 = CUmemAccessDesc_st;
#[doc = " Memory access descriptor\n"]
pub type CUmemAccessDesc = CUmemAccessDesc_v1;
#[repr(u32)]
#[doc = " CUDA Graph Update error types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphExecUpdateResult_enum {
    #[doc = "< The update succeeded\n"]
    CU_GRAPH_EXEC_UPDATE_SUCCESS = 0,
    #[doc = "< The update failed for an unexpected reason which is described in the return value of the function\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR = 1,
    #[doc = "< The update failed because the topology changed\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = 2,
    #[doc = "< The update failed because a node type changed\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = 3,
    #[doc = "< The update failed because the function of a kernel node changed (CUDA driver < 11.2)\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = 4,
    #[doc = "< The update failed because the parameters changed in a way that is not supported\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = 5,
    #[doc = "< The update failed because something about the node is not supported\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = 6,
    #[doc = "< The update failed because the function of a kernel node changed in an unsupported way\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = 7,
    #[doc = "< The update failed because the node attributes changed in a way that is not supported\n"]
    CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED = 8,
}
#[doc = " CUDA Graph Update error types\n"]
pub use self::CUgraphExecUpdateResult_enum as CUgraphExecUpdateResult;
#[doc = " Result information returned by cuGraphExecUpdate\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExecUpdateResultInfo_st {
    #[doc = " Gives more specific detail when a cuda graph update fails.\n"]
    pub result: CUgraphExecUpdateResult,
    #[doc = " The \"to node\" of the error edge when the topologies do not match.\n The error node when the error is associated with a specific node.\n NULL when the error is generic.\n"]
    pub errorNode: CUgraphNode,
    #[doc = " The from node of error edge when the topologies do not match. Otherwise NULL.\n"]
    pub errorFromNode: CUgraphNode,
}
#[doc = " Result information returned by cuGraphExecUpdate\n"]
pub type CUgraphExecUpdateResultInfo_v1 = CUgraphExecUpdateResultInfo_st;
#[doc = " Result information returned by cuGraphExecUpdate\n"]
pub type CUgraphExecUpdateResultInfo = CUgraphExecUpdateResultInfo_v1;
#[repr(u32)]
#[doc = " CUDA memory pool attributes\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemPool_attribute_enum {
    #[doc = " (value type = int)\n Allow cuMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n Cuda events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)\n"]
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = 1,
    #[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)\n"]
    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC = 2,
    #[doc = " (value type = int)\n Allow cuMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled).\n"]
    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES = 3,
    #[doc = " (value type = cuuint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)\n"]
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD = 4,
    #[doc = " (value type = cuuint64_t)\n Amount of backing memory currently allocated for the mempool.\n"]
    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT = 5,
    #[doc = " (value type = cuuint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero.\n"]
    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH = 6,
    #[doc = " (value type = cuuint64_t)\n Amount of memory from the pool that is currently in use by the application.\n"]
    CU_MEMPOOL_ATTR_USED_MEM_CURRENT = 7,
    #[doc = " (value type = cuuint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero.\n"]
    CU_MEMPOOL_ATTR_USED_MEM_HIGH = 8,
}
#[doc = " CUDA memory pool attributes\n"]
pub use self::CUmemPool_attribute_enum as CUmemPool_attribute;
#[doc = " Specifies the properties of allocations made from the pool.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolProps_st {
    #[doc = "< Allocation type. Currently must be specified as CU_MEM_ALLOCATION_TYPE_PINNED\n"]
    pub allocType: CUmemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool.\n"]
    pub handleTypes: CUmemAllocationHandleType,
    #[doc = "< Location where allocations should reside.\n"]
    pub location: CUmemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when\n [CU_MEM_HANDLE_TYPE_WIN32](crate::ffi::CU_MEM_HANDLE_TYPE_WIN32) is specified.  This security attribute defines\n the scope of which exported allocations may be transferred to other\n processes.  In all other cases, this field is required to be zero.\n"]
    pub win32SecurityAttributes: *mut ::std::ffi::c_void,
    #[doc = "< Maximum pool size. When set to 0, defaults to a system dependent value.\n"]
    pub maxSize: usize,
    #[doc = "< Bitmask indicating intended usage for the pool.\n"]
    pub usage: ::std::ffi::c_ushort,
    #[doc = "< reserved for future use, must be 0\n"]
    pub reserved: [::std::ffi::c_uchar; 54usize],
}
#[doc = " Specifies the properties of allocations made from the pool.\n"]
pub type CUmemPoolProps_v1 = CUmemPoolProps_st;
#[doc = " Specifies the properties of allocations made from the pool.\n"]
pub type CUmemPoolProps = CUmemPoolProps_v1;
#[doc = " Opaque data for exporting a pool allocation\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolPtrExportData_st {
    pub reserved: [::std::ffi::c_uchar; 64usize],
}
#[doc = " Opaque data for exporting a pool allocation\n"]
pub type CUmemPoolPtrExportData_v1 = CUmemPoolPtrExportData_st;
#[doc = " Opaque data for exporting a pool allocation\n"]
pub type CUmemPoolPtrExportData = CUmemPoolPtrExportData_v1;
#[doc = " Memory allocation node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_v1_st {
    #[doc = " in: location where the allocation should reside (specified in [location](crate::ffi::location)).\n [handleTypes](crate::ffi::handleTypes) must be [CU_MEM_HANDLE_TYPE_NONE](crate::ffi::CU_MEM_HANDLE_TYPE_NONE). IPC is not supported.\n"]
    pub poolProps: CUmemPoolProps,
    #[doc = "< in: array of memory access descriptors. Used to describe peer GPU access\n"]
    pub accessDescs: *const CUmemAccessDesc,
    #[doc = "< in: number of memory access descriptors.  Must not exceed the number of GPUs.\n"]
    pub accessDescCount: usize,
    #[doc = "< in: size in bytes of the requested allocation\n"]
    pub bytesize: usize,
    #[doc = "< out: address of the allocation returned by CUDA\n"]
    pub dptr: CUdeviceptr,
}
#[doc = " Memory allocation node parameters\n"]
pub type CUDA_MEM_ALLOC_NODE_PARAMS_v1 = CUDA_MEM_ALLOC_NODE_PARAMS_v1_st;
#[doc = " Memory allocation node parameters\n"]
pub type CUDA_MEM_ALLOC_NODE_PARAMS = CUDA_MEM_ALLOC_NODE_PARAMS_v1;
#[doc = " Memory allocation node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_v2_st {
    #[doc = " in: location where the allocation should reside (specified in [location](crate::ffi::location)).\n [handleTypes](crate::ffi::handleTypes) must be [CU_MEM_HANDLE_TYPE_NONE](crate::ffi::CU_MEM_HANDLE_TYPE_NONE). IPC is not supported.\n"]
    pub poolProps: CUmemPoolProps,
    #[doc = "< in: array of memory access descriptors. Used to describe peer GPU access\n"]
    pub accessDescs: *const CUmemAccessDesc,
    #[doc = "< in: number of memory access descriptors.  Must not exceed the number of GPUs.\n"]
    pub accessDescCount: usize,
    #[doc = "< in: size in bytes of the requested allocation\n"]
    pub bytesize: usize,
    #[doc = "< out: address of the allocation returned by CUDA\n"]
    pub dptr: CUdeviceptr,
}
#[doc = " Memory allocation node parameters\n"]
pub type CUDA_MEM_ALLOC_NODE_PARAMS_v2 = CUDA_MEM_ALLOC_NODE_PARAMS_v2_st;
#[doc = " Memory free node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEM_FREE_NODE_PARAMS_st {
    #[doc = "< in: the pointer to free\n"]
    pub dptr: CUdeviceptr,
}
#[doc = " Memory free node parameters\n"]
pub type CUDA_MEM_FREE_NODE_PARAMS = CUDA_MEM_FREE_NODE_PARAMS_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphMem_attribute_enum {
    #[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently associated with graphs\n"]
    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT = 0,
    #[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, associated with graphs since the\n last time it was reset.  High watermark can only be reset to zero.\n"]
    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH = 1,
    #[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator.\n"]
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT = 2,
    #[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator.\n"]
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH = 3,
}
pub use self::CUgraphMem_attribute_enum as CUgraphMem_attribute;
#[doc = " Child graph node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_CHILD_GRAPH_NODE_PARAMS_st {
    #[doc = "< The child graph to clone into the node for node creation, or\na handle to the graph owned by the node for node query\n"]
    pub graph: CUgraph,
}
#[doc = " Child graph node parameters\n"]
pub type CUDA_CHILD_GRAPH_NODE_PARAMS = CUDA_CHILD_GRAPH_NODE_PARAMS_st;
#[doc = " Event record node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EVENT_RECORD_NODE_PARAMS_st {
    #[doc = "< The event to record when the node executes\n"]
    pub event: CUevent,
}
#[doc = " Event record node parameters\n"]
pub type CUDA_EVENT_RECORD_NODE_PARAMS = CUDA_EVENT_RECORD_NODE_PARAMS_st;
#[doc = " Event wait node parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EVENT_WAIT_NODE_PARAMS_st {
    #[doc = "< The event to wait on from the node\n"]
    pub event: CUevent,
}
#[doc = " Event wait node parameters\n"]
pub type CUDA_EVENT_WAIT_NODE_PARAMS = CUDA_EVENT_WAIT_NODE_PARAMS_st;
#[doc = " Graph node parameters.  See [cuGraphAddNode](crate::ffi::cuGraphAddNode).\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUgraphNodeParams_st {
    #[doc = "< Type of the node\n"]
    pub type_: CUgraphNodeType,
    #[doc = "< Reserved. Must be zero.\n"]
    pub reserved0: [::std::ffi::c_int; 3usize],
    pub __bindgen_anon_1: CUgraphNodeParams_st__bindgen_ty_1,
    #[doc = "< Reserved bytes. Must be zero.\n"]
    pub reserved2: ::std::ffi::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUgraphNodeParams_st__bindgen_ty_1 {
    #[doc = "< Padding. Unused bytes must be zero.\n"]
    pub reserved1: [::std::ffi::c_longlong; 29usize],
    #[doc = "< Kernel node parameters.\n"]
    pub kernel: CUDA_KERNEL_NODE_PARAMS_v3,
    #[doc = "< Memcpy node parameters.\n"]
    pub memcpy: CUDA_MEMCPY_NODE_PARAMS,
    #[doc = "< Memset node parameters.\n"]
    pub memset: CUDA_MEMSET_NODE_PARAMS_v2,
    #[doc = "< Host node parameters.\n"]
    pub host: CUDA_HOST_NODE_PARAMS_v2,
    #[doc = "< Child graph node parameters.\n"]
    pub graph: CUDA_CHILD_GRAPH_NODE_PARAMS,
    #[doc = "< Event wait node parameters.\n"]
    pub eventWait: CUDA_EVENT_WAIT_NODE_PARAMS,
    #[doc = "< Event record node parameters.\n"]
    pub eventRecord: CUDA_EVENT_RECORD_NODE_PARAMS,
    #[doc = "< External semaphore signal node parameters.\n"]
    pub extSemSignal: CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2,
    #[doc = "< External semaphore wait node parameters.\n"]
    pub extSemWait: CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2,
    #[doc = "< Memory allocation node parameters.\n"]
    pub alloc: CUDA_MEM_ALLOC_NODE_PARAMS_v2,
    #[doc = "< Memory free node parameters.\n"]
    pub free: CUDA_MEM_FREE_NODE_PARAMS,
    #[doc = "< MemOp node parameters.\n"]
    pub memOp: CUDA_BATCH_MEM_OP_NODE_PARAMS_v2,
    #[doc = "< Conditional node parameters.\n"]
    pub conditional: CUDA_CONDITIONAL_NODE_PARAMS,
}
#[doc = " Graph node parameters.  See [cuGraphAddNode](crate::ffi::cuGraphAddNode).\n"]
pub type CUgraphNodeParams = CUgraphNodeParams_st;
#[repr(u32)]
#[doc = " Bitmasks for [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesOptions_enum {
    #[doc = "< [cuFlushGPUDirectRDMAWrites](crate::ffi::cuFlushGPUDirectRDMAWrites)() and its CUDA Runtime API counterpart are supported on the device.\n"]
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = 1,
    #[doc = "< The [CU_STREAM_WAIT_VALUE_FLUSH](crate::ffi::CU_STREAM_WAIT_VALUE_FLUSH) flag and the [CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES](crate::ffi::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES) MemOp are supported on the device.\n"]
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = 2,
}
#[doc = " Bitmasks for [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS)\n"]
pub use self::CUflushGPUDirectRDMAWritesOptions_enum as CUflushGPUDirectRDMAWritesOptions;
#[repr(u32)]
#[doc = " Platform native ordering for GPUDirect RDMA writes\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUGPUDirectRDMAWritesOrdering_enum {
    #[doc = "< The device does not natively support ordering of remote writes. [cuFlushGPUDirectRDMAWrites](crate::ffi::cuFlushGPUDirectRDMAWrites)() can be leveraged if supported.\n"]
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = 0,
    #[doc = "< Natively, the device can consistently consume remote writes, although other CUDA devices may not.\n"]
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = 100,
    #[doc = "< Any CUDA device in the system can consistently consume remote writes to this device.\n"]
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = 200,
}
#[doc = " Platform native ordering for GPUDirect RDMA writes\n"]
pub use self::CUGPUDirectRDMAWritesOrdering_enum as CUGPUDirectRDMAWritesOrdering;
#[repr(u32)]
#[doc = " The scopes for [cuFlushGPUDirectRDMAWrites](crate::ffi::cuFlushGPUDirectRDMAWrites)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesScope_enum {
    #[doc = "< Blocks until remote writes are visible to the CUDA device context owning the data.\n"]
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = 100,
    #[doc = "< Blocks until remote writes are visible to all CUDA device contexts.\n"]
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = 200,
}
#[doc = " The scopes for [cuFlushGPUDirectRDMAWrites](crate::ffi::cuFlushGPUDirectRDMAWrites)\n"]
pub use self::CUflushGPUDirectRDMAWritesScope_enum as CUflushGPUDirectRDMAWritesScope;
#[repr(u32)]
#[doc = " The targets for [cuFlushGPUDirectRDMAWrites](crate::ffi::cuFlushGPUDirectRDMAWrites)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesTarget_enum {
    #[doc = "< Sets the target for [cuFlushGPUDirectRDMAWrites](crate::ffi::cuFlushGPUDirectRDMAWrites)() to the currently active CUDA device context.\n"]
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = 0,
}
#[doc = " The targets for [cuFlushGPUDirectRDMAWrites](crate::ffi::cuFlushGPUDirectRDMAWrites)\n"]
pub use self::CUflushGPUDirectRDMAWritesTarget_enum as CUflushGPUDirectRDMAWritesTarget;
#[repr(u32)]
#[doc = " The additional write options for [cuGraphDebugDotPrint](crate::ffi::cuGraphDebugDotPrint)\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphDebugDot_flags_enum {
    #[doc = "< Output all debug data as if every debug flag is enabled\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = 1,
    #[doc = "< Use CUDA Runtime structures for output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = 2,
    #[doc = "< Adds CUDA_KERNEL_NODE_PARAMS values to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = 4,
    #[doc = "< Adds CUDA_MEMCPY3D values to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = 8,
    #[doc = "< Adds CUDA_MEMSET_NODE_PARAMS values to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = 16,
    #[doc = "< Adds CUDA_HOST_NODE_PARAMS values to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = 32,
    #[doc = "< Adds CUevent handle from record and wait nodes to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = 64,
    #[doc = "< Adds CUDA_EXT_SEM_SIGNAL_NODE_PARAMS values to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = 128,
    #[doc = "< Adds CUDA_EXT_SEM_WAIT_NODE_PARAMS values to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = 256,
    #[doc = "< Adds CUkernelNodeAttrValue values to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = 512,
    #[doc = "< Adds node handles and every kernel function handle to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = 1024,
    #[doc = "< Adds memory alloc node parameters to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = 2048,
    #[doc = "< Adds memory free node parameters to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = 4096,
    #[doc = "< Adds batch mem op node parameters to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS = 8192,
    #[doc = "< Adds edge numbering information\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO = 16384,
    #[doc = "< Adds conditional node parameters to output\n"]
    CU_GRAPH_DEBUG_DOT_FLAGS_CONDITIONAL_NODE_PARAMS = 32768,
}
#[doc = " The additional write options for [cuGraphDebugDotPrint](crate::ffi::cuGraphDebugDotPrint)\n"]
pub use self::CUgraphDebugDot_flags_enum as CUgraphDebugDot_flags;
#[repr(u32)]
#[doc = " Flags for user objects for graphs\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUuserObject_flags_enum {
    #[doc = "< Indicates the destructor execution is not synchronized by any CUDA handle.\n"]
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = 1,
}
#[doc = " Flags for user objects for graphs\n"]
pub use self::CUuserObject_flags_enum as CUuserObject_flags;
#[repr(u32)]
#[doc = " Flags for retaining user object references for graphs\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUuserObjectRetain_flags_enum {
    #[doc = "< Transfer references from the caller rather than creating new references.\n"]
    CU_GRAPH_USER_OBJECT_MOVE = 1,
}
#[doc = " Flags for retaining user object references for graphs\n"]
pub use self::CUuserObjectRetain_flags_enum as CUuserObjectRetain_flags;
#[repr(u32)]
#[doc = " Flags for instantiating a graph\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphInstantiate_flags_enum {
    #[doc = "< Automatically free memory allocated in a graph before relaunching.\n"]
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = 1,
    #[doc = "< Automatically upload the graph after instantiation. Only supported by\n[cuGraphInstantiateWithParams](crate::ffi::cuGraphInstantiateWithParams).  The upload will be performed using the\nstream provided in `instantiateParams`.\n"]
    CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD = 2,
    #[doc = "< Instantiate the graph to be launchable from the device. This flag can only\nbe used on platforms which support unified addressing. This flag cannot be\nused in conjunction with CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH.\n"]
    CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH = 4,
    #[doc = "< Run the graph using the per-node priority attributes rather than the\npriority of the stream it is launched into.\n"]
    CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY = 8,
}
#[doc = " Flags for instantiating a graph\n"]
pub use self::CUgraphInstantiate_flags_enum as CUgraphInstantiate_flags;
#[repr(u32)]
#[doc = " CUDA device NUMA configuration\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdeviceNumaConfig_enum {
    #[doc = "< The GPU is not a NUMA node\n"]
    CU_DEVICE_NUMA_CONFIG_NONE = 0,
    #[doc = "< The GPU is a NUMA node, CU_DEVICE_ATTRIBUTE_NUMA_ID contains its NUMA ID\n"]
    CU_DEVICE_NUMA_CONFIG_NUMA_NODE = 1,
}
#[doc = " CUDA device NUMA configuration\n"]
pub use self::CUdeviceNumaConfig_enum as CUdeviceNumaConfig;
#[repr(u32)]
#[doc = " CUDA Process States\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUprocessState_enum {
    #[doc = "< Default process state\n"]
    CU_PROCESS_STATE_RUNNING = 0,
    #[doc = "< CUDA API locks are taken so further CUDA API calls will block\n"]
    CU_PROCESS_STATE_LOCKED = 1,
    #[doc = "< Application memory contents have been checkpointed and underlying allocations and device handles have been released\n"]
    CU_PROCESS_STATE_CHECKPOINTED = 2,
    #[doc = "< Application entered an uncorrectable error during the checkpoint/restore process\n"]
    CU_PROCESS_STATE_FAILED = 3,
}
#[doc = " CUDA Process States\n"]
pub use self::CUprocessState_enum as CUprocessState;
#[doc = " CUDA checkpoint optional lock arguments\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUcheckpointLockArgs_st {
    #[doc = "< Timeout in milliseconds to attempt to lock the process, 0 indicates no timeout\n"]
    pub timeoutMs: ::std::ffi::c_uint,
    #[doc = "< Reserved for future use, must be zero\n"]
    pub reserved0: ::std::ffi::c_uint,
    #[doc = "< Reserved for future use, must be zeroed\n"]
    pub reserved1: [cuuint64_t; 7usize],
}
#[doc = " CUDA checkpoint optional lock arguments\n"]
pub type CUcheckpointLockArgs = CUcheckpointLockArgs_st;
#[doc = " CUDA checkpoint optional checkpoint arguments\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUcheckpointCheckpointArgs_st {
    #[doc = "< Reserved for future use, must be zeroed\n"]
    pub reserved: [cuuint64_t; 8usize],
}
#[doc = " CUDA checkpoint optional checkpoint arguments\n"]
pub type CUcheckpointCheckpointArgs = CUcheckpointCheckpointArgs_st;
#[doc = " CUDA checkpoint optional restore arguments\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUcheckpointRestoreArgs_st {
    #[doc = "< Reserved for future use, must be zeroed\n"]
    pub reserved: [cuuint64_t; 8usize],
}
#[doc = " CUDA checkpoint optional restore arguments\n"]
pub type CUcheckpointRestoreArgs = CUcheckpointRestoreArgs_st;
#[doc = " CUDA checkpoint optional unlock arguments\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUcheckpointUnlockArgs_st {
    #[doc = "< Reserved for future use, must be zeroed\n"]
    pub reserved: [cuuint64_t; 8usize],
}
#[doc = " CUDA checkpoint optional unlock arguments\n"]
pub type CUcheckpointUnlockArgs = CUcheckpointUnlockArgs_st;
#[repr(u32)]
#[doc = " Flags to specify for copies within a batch. For more details see [cuMemcpyBatchAsync](crate::ffi::cuMemcpyBatchAsync).\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemcpyFlags_enum {
    CU_MEMCPY_FLAG_DEFAULT = 0,
    #[doc = " Hint to the driver to try and overlap the copy with compute work on the SMs.\n"]
    CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE = 1,
}
#[doc = " Flags to specify for copies within a batch. For more details see [cuMemcpyBatchAsync](crate::ffi::cuMemcpyBatchAsync).\n"]
pub use self::CUmemcpyFlags_enum as CUmemcpyFlags;
#[repr(u32)]
#[doc = " These flags allow applications to convey the source access ordering CUDA must maintain.\n The destination will always be accessed in stream order.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemcpySrcAccessOrder_enum {
    #[doc = " Default invalid.\n"]
    CU_MEMCPY_SRC_ACCESS_ORDER_INVALID = 0,
    #[doc = " Indicates that access to the source pointer must be in stream order.\n"]
    CU_MEMCPY_SRC_ACCESS_ORDER_STREAM = 1,
    #[doc = " Indicates that access to the source pointer can be out of stream order and\n all accesses must be complete before the API call returns. This flag is suited for\n ephemeral sources (ex., stack variables) when it's known that no prior operations\n in the stream can be accessing the memory and also that the lifetime of the memory\n is limited to the scope that the source variable was declared in. Specifying\n this flag allows the driver to optimize the copy and removes the need for the user\n to synchronize the stream after the API call.\n"]
    CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL = 2,
    #[doc = " Indicates that access to the source pointer can be out of stream order and the accesses\n can happen even after the API call returns. This flag is suited for host pointers\n allocated outside CUDA (ex., via malloc) when it's known that no prior operations\n in the stream can be accessing the memory. Specifying this flag allows the driver\n to optimize the copy on certain platforms.\n"]
    CU_MEMCPY_SRC_ACCESS_ORDER_ANY = 3,
    #[doc = " Indicates that access to the source pointer can be out of stream order and the accesses\n can happen even after the API call returns. This flag is suited for host pointers\n allocated outside CUDA (ex., via malloc) when it's known that no prior operations\n in the stream can be accessing the memory. Specifying this flag allows the driver\n to optimize the copy on certain platforms.\n"]
    CU_MEMCPY_SRC_ACCESS_ORDER_MAX = 2147483647,
}
#[doc = " These flags allow applications to convey the source access ordering CUDA must maintain.\n The destination will always be accessed in stream order.\n"]
pub use self::CUmemcpySrcAccessOrder_enum as CUmemcpySrcAccessOrder;
#[doc = " Attributes specific to copies within a batch. For more details on usage see [cuMemcpyBatchAsync](crate::ffi::cuMemcpyBatchAsync).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemcpyAttributes_st {
    #[doc = "< Source access ordering to be observed for copies with this attribute.\n"]
    pub srcAccessOrder: CUmemcpySrcAccessOrder,
    #[doc = "< Hint location for the source operand. Ignored when the pointers are not managed memory or memory allocated outside CUDA.\n"]
    pub srcLocHint: CUmemLocation,
    #[doc = "< Hint location for the destination operand. Ignored when the pointers are not managed memory or memory allocated outside CUDA.\n"]
    pub dstLocHint: CUmemLocation,
    #[doc = "< Additional flags for copies with this attribute. See [CUmemcpyFlags](crate::ffi::CUmemcpyFlags)\n"]
    pub flags: ::std::ffi::c_uint,
}
#[doc = " Attributes specific to copies within a batch. For more details on usage see [cuMemcpyBatchAsync](crate::ffi::cuMemcpyBatchAsync).\n"]
pub type CUmemcpyAttributes_v1 = CUmemcpyAttributes_st;
#[doc = " Attributes specific to copies within a batch. For more details on usage see [cuMemcpyBatchAsync](crate::ffi::cuMemcpyBatchAsync).\n"]
pub type CUmemcpyAttributes = CUmemcpyAttributes_v1;
#[repr(u32)]
#[doc = " These flags allow applications to convey the operand type for individual copies specified in [cuMemcpy3DBatchAsync](crate::ffi::cuMemcpy3DBatchAsync).\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemcpy3DOperandType_enum {
    #[doc = "< Memcpy operand is a valid pointer.\n"]
    CU_MEMCPY_OPERAND_TYPE_POINTER = 1,
    #[doc = "< Memcpy operand is a CUarray.\n"]
    CU_MEMCPY_OPERAND_TYPE_ARRAY = 2,
    CU_MEMCPY_OPERAND_TYPE_MAX = 2147483647,
}
#[doc = " These flags allow applications to convey the operand type for individual copies specified in [cuMemcpy3DBatchAsync](crate::ffi::cuMemcpy3DBatchAsync).\n"]
pub use self::CUmemcpy3DOperandType_enum as CUmemcpy3DOperandType;
#[doc = " Struct representing offset into a CUarray in elements\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUoffset3D_st {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[doc = " Struct representing offset into a CUarray in elements\n"]
pub type CUoffset3D_v1 = CUoffset3D_st;
#[doc = " Struct representing offset into a CUarray in elements\n"]
pub type CUoffset3D = CUoffset3D_v1;
#[doc = " Struct representing width/height/depth of a CUarray in elements\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextent3D_st {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[doc = " Struct representing width/height/depth of a CUarray in elements\n"]
pub type CUextent3D_v1 = CUextent3D_st;
#[doc = " Struct representing width/height/depth of a CUarray in elements\n"]
pub type CUextent3D = CUextent3D_v1;
#[doc = " Struct representing an operand for copy with [cuMemcpy3DBatchAsync](crate::ffi::cuMemcpy3DBatchAsync)\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUmemcpy3DOperand_st {
    pub type_: CUmemcpy3DOperandType,
    pub op: CUmemcpy3DOperand_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUmemcpy3DOperand_st__bindgen_ty_1 {
    pub ptr: CUmemcpy3DOperand_st__bindgen_ty_1__bindgen_ty_1,
    pub array: CUmemcpy3DOperand_st__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Struct representing an operand when [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[type](crate::ffi::type) is [CU_MEMCPY_OPERAND_TYPE_POINTER](crate::ffi::CU_MEMCPY_OPERAND_TYPE_POINTER)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemcpy3DOperand_st__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: CUdeviceptr,
    #[doc = "< Length of each row in elements.\n"]
    pub rowLength: usize,
    #[doc = "< Height of each layer in elements.\n"]
    pub layerHeight: usize,
    #[doc = "< Hint location for the operand. Ignored when the pointers are not managed memory or memory allocated outside CUDA.\n"]
    pub locHint: CUmemLocation,
}
#[doc = " Struct representing an operand when [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[type](crate::ffi::type) is [CU_MEMCPY_OPERAND_TYPE_ARRAY](crate::ffi::CU_MEMCPY_OPERAND_TYPE_ARRAY)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemcpy3DOperand_st__bindgen_ty_1__bindgen_ty_2 {
    pub array: CUarray,
    pub offset: CUoffset3D,
}
#[doc = " Struct representing an operand for copy with [cuMemcpy3DBatchAsync](crate::ffi::cuMemcpy3DBatchAsync)\n"]
pub type CUmemcpy3DOperand_v1 = CUmemcpy3DOperand_st;
#[doc = " Struct representing an operand for copy with [cuMemcpy3DBatchAsync](crate::ffi::cuMemcpy3DBatchAsync)\n"]
pub type CUmemcpy3DOperand = CUmemcpy3DOperand_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_MEMCPY3D_BATCH_OP_st {
    #[doc = "< Source memcpy operand.\n"]
    pub src: CUmemcpy3DOperand,
    #[doc = "< Destination memcpy operand.\n"]
    pub dst: CUmemcpy3DOperand,
    #[doc = "< Extents of the memcpy between src and dst. The width, height and depth components must not be 0.\n"]
    pub extent: CUextent3D,
    #[doc = "< Source access ordering to be observed for copy from src to dst.\n"]
    pub srcAccessOrder: CUmemcpySrcAccessOrder,
    #[doc = "< Additional flags for copies with this attribute. See [CUmemcpyFlags](crate::ffi::CUmemcpyFlags)\n"]
    pub flags: ::std::ffi::c_uint,
}
pub type CUDA_MEMCPY3D_BATCH_OP_v1 = CUDA_MEMCPY3D_BATCH_OP_st;
pub type CUDA_MEMCPY3D_BATCH_OP = CUDA_MEMCPY3D_BATCH_OP_v1;
unsafe extern "C" {
    #[doc = " Gets the string description of an error code\n\n Sets `*pStr` to the address of a NULL-terminated string description\n of the error code `error`.\n If the error code is not recognized, [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n will be returned and `*pStr` will be set to the NULL address.\n#### error:\n- Error code to convert to string\n#### pStr:\n- Address of the string pointer.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [CUresult](crate::ffi::CUresult),\n [cudaGetErrorString](crate::ffi::cudaGetErrorString)\n"]
    pub fn cuGetErrorString(error: CUresult, pStr: *mut *const ::std::ffi::c_char) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the string representation of an error code enum name\n\n Sets `*pStr` to the address of a NULL-terminated string representation\n of the name of the enum error code `error`.\n If the error code is not recognized, [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n will be returned and `*pStr` will be set to the NULL address.\n#### error:\n- Error code to convert to string\n#### pStr:\n- Address of the string pointer.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [CUresult](crate::ffi::CUresult),\n [cudaGetErrorName](crate::ffi::cudaGetErrorName)\n"]
    pub fn cuGetErrorName(error: CUresult, pStr: *mut *const ::std::ffi::c_char) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Initialize the CUDA driver API\n Initializes the driver API and must be called before any other function from\n the driver API in the current process. Currently, the `Flags` parameter must be 0. If [cuInit](crate::ffi::cuInit)()\n has not been called, any function from the driver API will return\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED).\n#### Flags:\n- Initialization flag for CUDA.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_SYSTEM_DRIVER_MISMATCH](crate::ffi::CUDA_ERROR_SYSTEM_DRIVER_MISMATCH),\n [CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE](crate::ffi::CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n"]
    pub fn cuInit(Flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the latest CUDA version supported by driver\n\n Returns in `*driverVersion` the version of CUDA supported by\n the driver.  The version is returned as\n (1000 &times; major + 10 &times; minor). For example, CUDA 9.2\n would be represented by 9020.\n\n This function automatically returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if\n `driverVersion` is NULL.\n#### driverVersion:\n- Returns the CUDA driver version\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cudaDriverGetVersion](crate::ffi::cudaDriverGetVersion),\n [cudaRuntimeGetVersion](crate::ffi::cudaRuntimeGetVersion)\n"]
    pub fn cuDriverGetVersion(driverVersion: *mut ::std::ffi::c_int) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a handle to a compute device\n\n Returns in `*device` a device handle given an ordinal in the range <b>[0,\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount)()-1]</b>.\n#### device:\n- Returned device handle\n#### ordinal:\n- Device number to get handle for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGetLuid](crate::ffi::cuDeviceGetLuid),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem),\n [cuDeviceGetExecAffinitySupport](crate::ffi::cuDeviceGetExecAffinitySupport)\n"]
    pub fn cuDeviceGet(device: *mut CUdevice, ordinal: ::std::ffi::c_int) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the number of compute-capable devices\n\n Returns in `*count` the number of devices with compute capability greater\n than or equal to 2.0 that are available for execution. If there is no such\n device, [cuDeviceGetCount](crate::ffi::cuDeviceGetCount)() returns 0.\n#### count:\n- Returned number of compute-capable devices\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGetLuid](crate::ffi::cuDeviceGetLuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem),\n [cuDeviceGetExecAffinitySupport](crate::ffi::cuDeviceGetExecAffinitySupport),\n [cudaGetDeviceCount](crate::ffi::cudaGetDeviceCount)\n"]
    pub fn cuDeviceGetCount(count: *mut ::std::ffi::c_int) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns an identifier string for the device\n\n Returns an ASCII string identifying the device `dev` in the NULL-terminated\n string pointed to by `name`. `len` specifies the maximum length of the\n string that may be returned.\n#### name:\n- Returned identifier string for the device\n#### len:\n- Maximum length of string to store in `name`\n#### dev:\n- Device to get identifier string for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGetLuid](crate::ffi::cuDeviceGetLuid),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem),\n [cuDeviceGetExecAffinitySupport](crate::ffi::cuDeviceGetExecAffinitySupport),\n [cudaGetDeviceProperties](crate::ffi::cudaGetDeviceProperties)\n"]
    pub fn cuDeviceGetName(
        name: *mut ::std::ffi::c_char,
        len: ::std::ffi::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Return an UUID for the device\n\n Note there is a later version of this API, [cuDeviceGetUuid_v2](crate::ffi::cuDeviceGetUuid_v2). It will\n supplant this version in 12.0, which is retained for minor version compatibility.\n\n Returns 16-octets identifying the device `dev` in the structure\n pointed by the `uuid`.\n#### uuid:\n- Returned UUID\n#### dev:\n- Device to get identifier string for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetUuid_v2](crate::ffi::cuDeviceGetUuid_v2)\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetLuid](crate::ffi::cuDeviceGetLuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem),\n [cuDeviceGetExecAffinitySupport](crate::ffi::cuDeviceGetExecAffinitySupport),\n [cudaGetDeviceProperties](crate::ffi::cudaGetDeviceProperties)\n"]
    pub fn cuDeviceGetUuid(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Return an UUID for the device (11.4+)\n\n Returns 16-octets identifying the device `dev` in the structure\n pointed by the `uuid`. If the device is in MIG mode, returns its\n MIG UUID which uniquely identifies the subscribed MIG compute instance.\n#### uuid:\n- Returned UUID\n#### dev:\n- Device to get identifier string for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetLuid](crate::ffi::cuDeviceGetLuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem),\n [cudaGetDeviceProperties](crate::ffi::cudaGetDeviceProperties)\n"]
    pub fn cuDeviceGetUuid_v2(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Return an LUID and device node mask for the device\n\n Return identifying information (`luid` and `deviceNodeMask`) to allow\n matching device with graphics APIs.\n#### luid:\n- Returned LUID\n#### deviceNodeMask:\n- Returned device node mask\n#### dev:\n- Device to get identifier string for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem),\n [cuDeviceGetExecAffinitySupport](crate::ffi::cuDeviceGetExecAffinitySupport),\n [cudaGetDeviceProperties](crate::ffi::cudaGetDeviceProperties)\n"]
    pub fn cuDeviceGetLuid(
        luid: *mut ::std::ffi::c_char,
        deviceNodeMask: *mut ::std::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the total amount of memory on the device\n\n Returns in `*bytes` the total amount of memory available on the device\n `dev` in bytes.\n#### bytes:\n- Returned memory available on device in bytes\n#### dev:\n- Device handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceGetExecAffinitySupport](crate::ffi::cuDeviceGetExecAffinitySupport),\n [cudaMemGetInfo](crate::ffi::cudaMemGetInfo)\n"]
    pub fn cuDeviceTotalMem_v2(bytes: *mut usize, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.\n\n Returns in `maxWidthInElements` the maximum number of texture elements allocatable in a 1D linear texture\n for given `format` and `numChannels`.\n#### maxWidthInElements:\n- Returned maximum number of texture elements allocatable for given `format` and `numChannels`.\n#### format:\n- Texture format.\n#### numChannels:\n- Number of channels per texture element.\n#### dev:\n- Device handle.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cudaMemGetInfo](crate::ffi::cudaMemGetInfo),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem)\n"]
    pub fn cuDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut usize,
        format: CUarray_format,
        numChannels: ::std::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns information about the device\n\n Returns in `*pi` the integer value of the attribute `attrib` on device\n `dev`. The supported attributes are:\n - [CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK): Maximum number of threads per\n   block;\n - [CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X): Maximum x-dimension of a block\n - [CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y): Maximum y-dimension of a block\n - [CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z): Maximum z-dimension of a block\n - [CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X): Maximum x-dimension of a grid\n - [CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y): Maximum y-dimension of a grid\n - [CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z): Maximum z-dimension of a grid\n - [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK): Maximum amount of\n   shared memory available to a thread block in bytes\n - [CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY](crate::ffi::CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY): Memory available on device for\n   __constant__ variables in a CUDA C kernel in bytes\n - [CU_DEVICE_ATTRIBUTE_WARP_SIZE](crate::ffi::CU_DEVICE_ATTRIBUTE_WARP_SIZE): Warp size in threads\n - [CU_DEVICE_ATTRIBUTE_MAX_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_PITCH): Maximum pitch in bytes allowed by the\n   memory copy functions that involve memory regions allocated through\n   [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)()\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH): Maximum 1D\n  texture width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH): Maximum width\n  for a 1D texture bound to linear memory\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH): Maximum\n  mipmapped 1D texture width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH): Maximum 2D\n  texture width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT): Maximum 2D\n  texture height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH): Maximum width\n  for a 2D texture bound to linear memory\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT): Maximum height\n  for a 2D texture bound to linear memory\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH): Maximum pitch\n  in bytes for a 2D texture bound to linear memory\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH): Maximum\n  mipmapped 2D texture width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT): Maximum\n  mipmapped 2D texture height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH): Maximum 3D\n  texture width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT): Maximum 3D\n  texture height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH): Maximum 3D\n  texture depth\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE):\n  Alternate maximum 3D texture width, 0 if no alternate\n  maximum 3D texture size is supported\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE):\n  Alternate maximum 3D texture height, 0 if no alternate\n  maximum 3D texture size is supported\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE):\n  Alternate maximum 3D texture depth, 0 if no alternate\n  maximum 3D texture size is supported\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH):\n  Maximum cubemap texture width or height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH):\n  Maximum 1D layered texture width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS):\n   Maximum layers in a 1D layered texture\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH):\n  Maximum 2D layered texture width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT):\n   Maximum 2D layered texture height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS):\n   Maximum layers in a 2D layered texture\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH):\n   Maximum cubemap layered texture width or height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS):\n   Maximum layers in a cubemap layered texture\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH):\n   Maximum 1D surface width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH):\n   Maximum 2D surface width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT):\n   Maximum 2D surface height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH):\n   Maximum 3D surface width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT):\n   Maximum 3D surface height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH):\n   Maximum 3D surface depth\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH):\n   Maximum 1D layered surface width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS):\n   Maximum layers in a 1D layered surface\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH):\n   Maximum 2D layered surface width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT):\n   Maximum 2D layered surface height\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS):\n   Maximum layers in a 2D layered surface\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH):\n   Maximum cubemap surface width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH):\n   Maximum cubemap layered surface width\n - [CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS):\n   Maximum layers in a cubemap layered surface\n - [CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK): Maximum number of 32-bit\n   registers available to a thread block\n - [CU_DEVICE_ATTRIBUTE_CLOCK_RATE](crate::ffi::CU_DEVICE_ATTRIBUTE_CLOCK_RATE): The typical clock frequency in kilohertz\n - [CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT](crate::ffi::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT): Alignment requirement; texture\n   base addresses aligned to [textureAlign](crate::ffi::textureAlign) bytes do not need an offset\n   applied to texture fetches\n - [CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT](crate::ffi::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT): Pitch alignment requirement\n   for 2D texture references bound to pitched memory\n - [CU_DEVICE_ATTRIBUTE_GPU_OVERLAP](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_OVERLAP): 1 if the device can concurrently copy\n   memory between host and device while executing a kernel, or 0 if not\n - [CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT](crate::ffi::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT): Number of multiprocessors on\n   the device\n - [CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT](crate::ffi::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT): 1 if there is a run time limit\n   for kernels executed on the device, or 0 if not\n - [CU_DEVICE_ATTRIBUTE_INTEGRATED](crate::ffi::CU_DEVICE_ATTRIBUTE_INTEGRATED): 1 if the device is integrated with the\n   memory subsystem, or 0 if not\n - [CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY): 1 if the device can map host\n   memory into the CUDA address space, or 0 if not\n - [CU_DEVICE_ATTRIBUTE_COMPUTE_MODE](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE): Compute mode that device is currently\n   in. Available modes are as follows:\n   - [CU_COMPUTEMODE_DEFAULT](crate::ffi::CU_COMPUTEMODE_DEFAULT): Default mode - Device is not restricted and\n     can have multiple CUDA contexts present at a single time.\n   - [CU_COMPUTEMODE_PROHIBITED](crate::ffi::CU_COMPUTEMODE_PROHIBITED): Compute-prohibited mode - Device is\n     prohibited from creating new CUDA contexts.\n   - [CU_COMPUTEMODE_EXCLUSIVE_PROCESS](crate::ffi::CU_COMPUTEMODE_EXCLUSIVE_PROCESS):  Compute-exclusive-process mode - Device\n     can have only one context used by a single process at a time.\n - [CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS): 1 if the device supports\n   executing multiple kernels within the same context simultaneously, or 0 if\n   not. It is not guaranteed that multiple kernels will be resident\n   on the device concurrently so this feature should not be relied upon for\n   correctness.\n - [CU_DEVICE_ATTRIBUTE_ECC_ENABLED](crate::ffi::CU_DEVICE_ATTRIBUTE_ECC_ENABLED): 1 if error correction is enabled on the\n    device, 0 if error correction is disabled or not supported by the device\n - [CU_DEVICE_ATTRIBUTE_PCI_BUS_ID](crate::ffi::CU_DEVICE_ATTRIBUTE_PCI_BUS_ID): PCI bus identifier of the device\n - [CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID](crate::ffi::CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID): PCI device (also known as slot) identifier\n   of the device\n - [CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID](crate::ffi::CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID): PCI domain identifier of the device\n - [CU_DEVICE_ATTRIBUTE_TCC_DRIVER](crate::ffi::CU_DEVICE_ATTRIBUTE_TCC_DRIVER): 1 if the device is using a TCC driver. TCC\n    is only available on Tesla hardware running Windows Vista or later\n - [CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE](crate::ffi::CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE): Peak memory clock frequency in kilohertz\n - [CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH): Global memory bus width in bits\n - [CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE](crate::ffi::CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE): Size of L2 cache in bytes. 0 if the device doesn't have L2 cache\n - [CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR): Maximum resident threads per multiprocessor\n - [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](crate::ffi::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING): 1 if the device shares a unified address space with\n   the host, or 0 if not\n - [CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR): Major compute capability version number\n - [CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR): Minor compute capability version number\n - [CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED): 1 if device supports caching globals\n    in L1 cache, 0 if caching globals in L1 cache is not supported by the device\n - [CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED): 1 if device supports caching locals\n    in L1 cache, 0 if caching locals in L1 cache is not supported by the device\n - [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR): Maximum amount of\n   shared memory available to a multiprocessor in bytes; this amount is shared\n   by all thread blocks simultaneously resident on a multiprocessor\n - [CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR): Maximum number of 32-bit\n   registers available to a multiprocessor; this number is shared by all thread\n   blocks simultaneously resident on a multiprocessor\n - [CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY](crate::ffi::CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY): 1 if device supports allocating managed memory\n   on this system, 0 if allocating managed memory is not supported by the device on this system.\n - [CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD](crate::ffi::CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD): 1 if device is on a multi-GPU board, 0 if not.\n - [CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID](crate::ffi::CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID): Unique identifier for a group of devices\n   associated with the same board. Devices on the same multi-GPU board will share the same identifier.\n - [CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED): 1 if Link between the device and the host\n   supports native atomic operations.\n - [CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO](crate::ffi::CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO): Ratio of single precision performance\n   (in floating-point operations per second) to double precision performance.\n - [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS): Device supports coherently accessing\n   pageable memory without calling cudaHostRegister on it.\n - [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS): Device can coherently access managed memory\n   concurrently with the CPU.\n - [CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED): Device supports Compute Preemption.\n - [CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM): Device can access host registered\n   memory at the same virtual address as the CPU.\n -  [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN): The maximum per block shared memory size\n    supported on this device. This is the maximum value that can be opted into when using the cuFuncSetAttribute() or cuKernelSetAttribute() call.\n    For more details see [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES)\n - [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES): Device accesses pageable memory via the host's\n   page tables.\n - [CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST](crate::ffi::CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST): The host can directly access managed memory on the device without migration.\n - [CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED):  Device supports virtual memory management APIs like [cuMemAddressReserve](crate::ffi::cuMemAddressReserve), [cuMemCreate](crate::ffi::cuMemCreate), [cuMemMap](crate::ffi::cuMemMap) and related APIs\n - [CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED): Device supports exporting memory to a posix file descriptor with [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), if requested via [cuMemCreate](crate::ffi::cuMemCreate)\n - [CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED):  Device supports exporting memory to a Win32 NT handle with [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), if requested via [cuMemCreate](crate::ffi::cuMemCreate)\n - [CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED): Device supports exporting memory to a Win32 KMT handle with [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), if requested via [cuMemCreate](crate::ffi::cuMemCreate)\n - [CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR): Maximum number of thread blocks that can reside on a multiprocessor\n - [CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED): Device supports compressible memory allocation via [cuMemCreate](crate::ffi::cuMemCreate)\n - [CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE): Maximum L2 persisting lines capacity setting in bytes\n - [CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE): Maximum value of CUaccessPolicyWindow[num_bytes](crate::ffi::num_bytes)\n - [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED): Device supports specifying the GPUDirect RDMA flag with [cuMemCreate](crate::ffi::cuMemCreate).\n - [CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK](crate::ffi::CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK): Amount of shared memory per block reserved by CUDA driver in bytes\n - [CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED): Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays.\n - [CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED): Device supports using the [cuMemHostRegister](crate::ffi::cuMemHostRegister) flag [CU_MEMHOSTERGISTER_READ_ONLY](crate::ffi::CU_MEMHOSTERGISTER_READ_ONLY) to register memory that must be mapped as read-only to the GPU\n - [CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED): Device supports using the [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) and [cuMemPool](crate::ffi::cuMemPool) family of APIs\n - [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED): Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)\n - [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS): The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the [CUflushGPUDirectRDMAWritesOptions](crate::ffi::CUflushGPUDirectRDMAWritesOptions) enum\n - [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING): GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See [CUGPUDirectRDMAWritesOrdering](crate::ffi::CUGPUDirectRDMAWritesOrdering) for the numerical values returned here.\n - [CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES](crate::ffi::CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES): Bitmask of handle types supported with mempool based IPC\n - [CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED): Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays.\n - [CU_DEVICE_ATTRIBUTE_NUMA_CONFIG](crate::ffi::CU_DEVICE_ATTRIBUTE_NUMA_CONFIG): NUMA configuration of a device: value is of type [CUdeviceNumaConfig](crate::ffi::CUdeviceNumaConfig) enum\n - [CU_DEVICE_ATTRIBUTE_NUMA_ID](crate::ffi::CU_DEVICE_ATTRIBUTE_NUMA_ID): NUMA node ID of the GPU memory\n - [CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED): Device supports switch multicast and reduction operations.\n - [CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID): The combined 16-bit PCI device ID and 16-bit PCI vendor ID.\n - [CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID): The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem vendor ID.\nID.\n#### pi:\n- Returned device attribute value\n#### attrib:\n- Device attribute to query\n#### dev:\n- Device handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem),\n [cuDeviceGetExecAffinitySupport](crate::ffi::cuDeviceGetExecAffinitySupport),\n [cudaDeviceGetAttribute](crate::ffi::cudaDeviceGetAttribute),\n [cudaGetDeviceProperties](crate::ffi::cudaGetDeviceProperties)\n"]
    pub fn cuDeviceGetAttribute(
        pi: *mut ::std::ffi::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Return NvSciSync attributes that this device can support.\n\n Returns in `nvSciSyncAttrList`, the properties of NvSciSync that\n this CUDA device, `dev` can support. The returned `nvSciSyncAttrList`\n can be used to create an NvSciSync object that matches this device's capabilities.\n\n If NvSciSyncAttrKey_RequiredPerm field in `nvSciSyncAttrList` is\n already set this API will return [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n\n The applications should set `nvSciSyncAttrList` to a valid\n NvSciSyncAttrList failing which this API will return\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE).\n\n The `flags` controls how applications intends to use\n the NvSciSync created from the `nvSciSyncAttrList`. The valid flags are:\n - [CUDA_NVSCISYNC_ATTR_SIGNAL](crate::ffi::CUDA_NVSCISYNC_ATTR_SIGNAL), specifies that the applications intends to\n signal an NvSciSync on this CUDA device.\n - [CUDA_NVSCISYNC_ATTR_WAIT](crate::ffi::CUDA_NVSCISYNC_ATTR_WAIT), specifies that the applications intends to\n wait on an NvSciSync on this CUDA device.\n\n At least one of these flags must be set, failing which the API\n returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE). Both the flags are orthogonal\n to one another: a developer may set both these flags that allows to\n set both wait and signal specific attributes in the same `nvSciSyncAttrList`.\n\n Note that this API updates the input `nvSciSyncAttrList` with values equivalent\n to the following public attribute key-values:\n NvSciSyncAttrKey_RequiredPerm is set to\n - NvSciSyncAccessPerm_SignalOnly if [CUDA_NVSCISYNC_ATTR_SIGNAL](crate::ffi::CUDA_NVSCISYNC_ATTR_SIGNAL) is set in `flags`.\n - NvSciSyncAccessPerm_WaitOnly if [CUDA_NVSCISYNC_ATTR_WAIT](crate::ffi::CUDA_NVSCISYNC_ATTR_WAIT) is set in `flags`.\n - NvSciSyncAccessPerm_WaitSignal if both [CUDA_NVSCISYNC_ATTR_WAIT](crate::ffi::CUDA_NVSCISYNC_ATTR_WAIT) and\n [CUDA_NVSCISYNC_ATTR_SIGNAL](crate::ffi::CUDA_NVSCISYNC_ATTR_SIGNAL) are set in `flags`.\n NvSciSyncAttrKey_PrimitiveInfo is set to\n - NvSciSyncAttrValPrimitiveType_SysmemSemaphore on any valid `device`.\n - NvSciSyncAttrValPrimitiveType_Syncpoint if `device` is a Tegra device.\n - NvSciSyncAttrValPrimitiveType_SysmemSemaphorePayload64b if `device` is GA10X+.\n NvSciSyncAttrKey_GpuId is set to the same UUID that is returned for this\n `device` from [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid).\n#### nvSciSyncAttrList:\n- Return NvSciSync attributes supported.\n#### dev:\n- Valid Cuda Device to get NvSciSync attributes for.\n#### flags:\n- flags describing NvSciSync usage.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuDestroyExternalSemaphore](crate::ffi::cuDestroyExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::std::ffi::c_void,
        dev: CUdevice,
        flags: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the current memory pool of a device\n\n The memory pool must be local to the specified device.\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) allocates from the current mempool of the provided stream's device.\n By default, a device's current memory pool is its default memory pool.\n\n### Note:\n ### Note:\nUse [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync) to specify asynchronous allocations from a device different\n than the one the stream runs on.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool), [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate), [cuMemPoolDestroy](crate::ffi::cuMemPoolDestroy), [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync)\n"]
    pub fn cuDeviceSetMemPool(dev: CUdevice, pool: CUmemoryPool) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the current mempool for a device\n\n Returns the last pool provided to [cuDeviceSetMemPool](crate::ffi::cuDeviceSetMemPool) for this device\n or the device's default memory pool if [cuDeviceSetMemPool](crate::ffi::cuDeviceSetMemPool) has never been called.\n By default the current mempool is the default mempool for a device.\n Otherwise the returned pool must have been set with [cuDeviceSetMemPool](crate::ffi::cuDeviceSetMemPool).\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate), [cuDeviceSetMemPool](crate::ffi::cuDeviceSetMemPool)\n"]
    pub fn cuDeviceGetMemPool(pool: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the default mempool of a device\n\n The default mempool of a device contains device memory from that device.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemPoolTrimTo](crate::ffi::cuMemPoolTrimTo), [cuMemPoolGetAttribute](crate::ffi::cuMemPoolGetAttribute), [cuMemPoolSetAttribute](crate::ffi::cuMemPoolSetAttribute), cuMemPoolSetAccess, [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate)\n"]
    pub fn cuDeviceGetDefaultMemPool(pool_out: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns information about the execution affinity support of the device.\n\n Returns in `*pi` whether execution affinity type `type` is supported by device `dev`.\n The supported types are:\n - [CU_EXEC_AFFINITY_TYPE_SM_COUNT](crate::ffi::CU_EXEC_AFFINITY_TYPE_SM_COUNT): 1 if context with limited SMs is supported by the device,\n   or 0 if not;\n#### pi:\n- 1 if the execution affinity type `type` is supported by the device, or 0 if not\n#### type:\n- Execution affinity type to query\n#### dev:\n- Device handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem)\n"]
    pub fn cuDeviceGetExecAffinitySupport(
        pi: *mut ::std::ffi::c_int,
        type_: CUexecAffinityType,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Blocks until remote writes are visible to the specified scope\n\n Blocks until GPUDirect RDMA writes to the target context via mappings\n created through APIs like nvidia_p2p_get_pages (see\n https://docs.nvidia.com/cuda/gpudirect-rdma for more information), are\n visible to the specified scope.\n\n If the scope equals or lies within the scope indicated by\n [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING](crate::ffi::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING), the call\n will be a no-op and can be safely omitted for performance. This can be\n determined by comparing the numerical values between the two enums, with\n smaller scopes having smaller values.\n\n On platforms that support GPUDirect RDMA writes via more than one path in\n hardware (see [CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE](crate::ffi::CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE)), the user should\n consider those paths as belonging to separate ordering domains. Note that in\n such cases CUDA driver will report both RDMA writes ordering and RDMA write\n scope as ALL_DEVICES and a call to cuFlushGPUDirectRDMA will be a no-op,\n but when these multiple paths are used simultaneously, it is the user's\n responsibility to ensure ordering by using mechanisms outside the scope of\n CUDA.\n\n Users may query support for this API via\n [CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS](crate::ffi::CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS).\n#### target:\n- The target of the operation, see [CUflushGPUDirectRDMAWritesTarget](crate::ffi::CUflushGPUDirectRDMAWritesTarget)\n#### scope:\n- The scope of the operation, see [CUflushGPUDirectRDMAWritesScope](crate::ffi::CUflushGPUDirectRDMAWritesScope)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n"]
    pub fn cuFlushGPUDirectRDMAWrites(
        target: CUflushGPUDirectRDMAWritesTarget,
        scope: CUflushGPUDirectRDMAWritesScope,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns properties for a selected device\n\n \\deprecated\n\n This function was deprecated as of CUDA 5.0 and replaced by [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)().\n\n Returns in `*prop` the properties of device `dev`. The [CUdevprop](crate::ffi::CUdevprop)\n structure is defined as:\n\n \\code\ntypedef struct CUdevprop_st {\nint maxThreadsPerBlock;\nint maxThreadsDim[3];\nint maxGridSize[3];\nint sharedMemPerBlock;\nint totalConstantMemory;\nint SIMDWidth;\nint memPitch;\nint regsPerBlock;\nint clockRate;\nint textureAlign\n} CUdevprop;\n \\endcode\n where:\n\n - [maxThreadsPerBlock](crate::ffi::maxThreadsPerBlock) is the maximum number of threads per block;\n - [maxThreadsDim](crate::ffi::maxThreadsDim)[3] is the maximum sizes of each dimension of a block;\n - [maxGridSize](crate::ffi::maxGridSize)[3] is the maximum sizes of each dimension of a grid;\n - [sharedMemPerBlock](crate::ffi::sharedMemPerBlock) is the total amount of shared memory available per\n   block in bytes;\n - [totalConstantMemory](crate::ffi::totalConstantMemory) is the total amount of constant memory available on\n   the device in bytes;\n - [SIMDWidth](crate::ffi::SIMDWidth) is the warp size;\n - [memPitch](crate::ffi::memPitch) is the maximum pitch allowed by the memory copy functions that\n   involve memory regions allocated through [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)();\n - [regsPerBlock](crate::ffi::regsPerBlock) is the total number of registers available per block;\n - [clockRate](crate::ffi::clockRate) is the clock frequency in kilohertz;\n - [textureAlign](crate::ffi::textureAlign) is the alignment requirement; texture base addresses that\n   are aligned to [textureAlign](crate::ffi::textureAlign) bytes do not need an offset applied to\n   texture fetches.\n#### prop:\n- Returned properties of device\n#### dev:\n- Device to get properties for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem)\n"]
    pub fn cuDeviceGetProperties(prop: *mut CUdevprop, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the compute capability of the device\n\n \\deprecated\n\n This function was deprecated as of CUDA 5.0 and its functionality superseded\n by [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)().\n\n Returns in `*major` and `*minor` the major and minor revision numbers that\n define the compute capability of the device `dev`.\n#### major:\n- Major revision number\n#### minor:\n- Minor revision number\n#### dev:\n- Device handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetCount](crate::ffi::cuDeviceGetCount),\n [cuDeviceGetName](crate::ffi::cuDeviceGetName),\n [cuDeviceGetUuid](crate::ffi::cuDeviceGetUuid),\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceTotalMem](crate::ffi::cuDeviceTotalMem)\n"]
    pub fn cuDeviceComputeCapability(
        major: *mut ::std::ffi::c_int,
        minor: *mut ::std::ffi::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Retain the primary context on the GPU\n\n Retains the primary context on the device.\n Once the user successfully retains the primary context, the primary context\n will be active and available to the user until the user releases it\n with [cuDevicePrimaryCtxRelease](crate::ffi::cuDevicePrimaryCtxRelease)() or resets it with [cuDevicePrimaryCtxReset](crate::ffi::cuDevicePrimaryCtxReset)().\n Unlike [cuCtxCreate](crate::ffi::cuCtxCreate)() the newly retained context is not pushed onto the stack.\n\n Retaining the primary context for the first time will fail with [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n if the compute mode of the device is [CU_COMPUTEMODE_PROHIBITED](crate::ffi::CU_COMPUTEMODE_PROHIBITED). The function\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)() can be used with [CU_DEVICE_ATTRIBUTE_COMPUTE_MODE](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE) to\n determine the compute mode  of the device.\n The <i>nvidia-smi</i> tool can be used to set the compute mode for\n devices. Documentation for <i>nvidia-smi</i> can be obtained by passing a\n -h option to it.\n\n Please note that the primary context always supports pinned allocations. Other\n flags can be specified by [cuDevicePrimaryCtxSetFlags](crate::ffi::cuDevicePrimaryCtxSetFlags)().\n#### pctx:\n- Returned context handle of the new context\n#### dev:\n- Device for which primary context is requested\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuDevicePrimaryCtxRelease](crate::ffi::cuDevicePrimaryCtxRelease),\n [cuDevicePrimaryCtxSetFlags](crate::ffi::cuDevicePrimaryCtxSetFlags),\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuDevicePrimaryCtxRetain(pctx: *mut CUcontext, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Release the primary context on the GPU\n\n Releases the primary context interop on the device.\n A retained context should always be released once the user is done using\n it. The context is automatically reset once the last reference to it is\n released. This behavior is different when the primary context was retained\n by the CUDA runtime from CUDA 4.0 and earlier. In this case, the primary\n context remains always active.\n\n Releasing a primary context that has not been previously retained will\n fail with [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT).\n\n Please note that unlike [cuCtxDestroy](crate::ffi::cuCtxDestroy)() this method does not pop the context\n from stack in any circumstances.\n#### dev:\n- Device which primary context is released\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuDevicePrimaryCtxRetain](crate::ffi::cuDevicePrimaryCtxRetain),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuDevicePrimaryCtxRelease_v2(dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Set flags for the primary context\n\n Sets the flags for the primary context on the device overwriting perviously\n set ones.\n\n The three LSBs of the `flags` parameter can be used to control how the OS\n thread, which owns the CUDA context at the time of an API call, interacts\n with the OS scheduler when waiting for results from the GPU. Only one of\n the scheduling flags can be set when creating a context.\n\n - [CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN): Instruct CUDA to actively spin when waiting for\n results from the GPU. This can decrease latency when waiting for the GPU,\n but may lower the performance of CPU threads if they are performing work in\n parallel with the CUDA thread.\n\n - [CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD): Instruct CUDA to yield its thread when waiting for\n results from the GPU. This can increase latency when waiting for the GPU,\n but can increase the performance of CPU threads performing work in parallel\n with the GPU.\n\n - [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work.\n\n - [CU_CTX_BLOCKING_SYNC](crate::ffi::CU_CTX_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work. <br>\n <b>Deprecated:</b> This flag was deprecated as of CUDA 4.0 and was\n replaced with [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC).\n\n - [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO): The default value if the `flags` parameter is zero,\n uses a heuristic based on the number of active CUDA contexts in the\n process \\e C and the number of logical processors in the system \\e P. If\n \\e C > \\e P, then CUDA will yield to other OS threads when waiting for\n the GPU ([CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD)), otherwise CUDA will not yield while\n waiting for results and actively spin on the processor ([CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN)).\n Additionally, on Tegra devices, [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO) uses a heuristic based on\n the power profile of the platform and may choose [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC)\n for low-powered devices.\n\n - [CU_CTX_LMEM_RESIZE_TO_MAX](crate::ffi::CU_CTX_LMEM_RESIZE_TO_MAX): Instruct CUDA to not reduce local memory\n after resizing local memory for a kernel. This can prevent thrashing by\n local memory allocations when launching many kernels with high local\n memory usage at the cost of potentially increased memory usage. <br>\n <b>Deprecated:</b> This flag is deprecated and the behavior enabled\n by this flag is now the default and cannot be disabled.\n\n - [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE): If GPU coredumps have not been enabled globally\n with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment variables, this flag can\n be set during context creation to instruct CUDA to create a coredump if\n this context raises an exception during execution. These environment variables\n are described in the CUDA-GDB user guide under the \"GPU core dump support\"\n section.\n The initial settings will be taken from the global settings at the time of\n context creation. The other settings that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current.\n\n - [CU_CTX_USER_COREDUMP_ENABLE](crate::ffi::CU_CTX_USER_COREDUMP_ENABLE): If user-triggered GPU coredumps have not\n been enabled globally with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment\n variables, this flag can be set during context creation to instruct CUDA to\n create a coredump if data is written to a certain pipe that is present in the\n OS space. These environment variables are described in the CUDA-GDB user\n guide under the \"GPU core dump support\" section.\n It is important to note that the pipe name *must* be set with\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) before creating the context if this flag is\n used. Setting this flag implies that [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE) is set.\n The initial settings will be taken from the global settings at the time of\n context creation. The other settings that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current.\n\n - [CU_CTX_SYNC_MEMOPS](crate::ffi::CU_CTX_SYNC_MEMOPS): Ensures that synchronous memory operations initiated\n on this context will always synchronize. See further documentation in the\n section titled \"API Synchronization behavior\" to learn more about cases when\n synchronous memory operations can exhibit asynchronous behavior.\n#### dev:\n- Device for which the primary context flags are set\n#### flags:\n- New flags for the device\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuDevicePrimaryCtxRetain](crate::ffi::cuDevicePrimaryCtxRetain),\n [cuDevicePrimaryCtxGetState](crate::ffi::cuDevicePrimaryCtxGetState),\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxSetFlags](crate::ffi::cuCtxSetFlags),\n [cudaSetDeviceFlags](crate::ffi::cudaSetDeviceFlags)\n"]
    pub fn cuDevicePrimaryCtxSetFlags_v2(dev: CUdevice, flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get the state of the primary context\n\n Returns in `*flags` the flags for the primary context of `dev`, and in\n `*active` whether it is active.  See [cuDevicePrimaryCtxSetFlags](crate::ffi::cuDevicePrimaryCtxSetFlags) for flag\n values.\n#### dev:\n- Device to get primary context flags for\n#### flags:\n- Pointer to store flags\n#### active:\n- Pointer to store context state; 0 = inactive, 1 = active\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDevicePrimaryCtxSetFlags](crate::ffi::cuDevicePrimaryCtxSetFlags),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxSetFlags](crate::ffi::cuCtxSetFlags),\n [cudaGetDeviceFlags](crate::ffi::cudaGetDeviceFlags)\n"]
    pub fn cuDevicePrimaryCtxGetState(
        dev: CUdevice,
        flags: *mut ::std::ffi::c_uint,
        active: *mut ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroy all allocations and reset all state on the primary context\n\n Explicitly destroys and cleans up all resources associated with the current\n device in the current process.\n\n Note that it is responsibility of the calling function to ensure that no\n other module in the process is using the device any more. For that reason\n it is recommended to use [cuDevicePrimaryCtxRelease](crate::ffi::cuDevicePrimaryCtxRelease)() in most cases.\n However it is safe for other modules to call [cuDevicePrimaryCtxRelease](crate::ffi::cuDevicePrimaryCtxRelease)()\n even after resetting the device.\n Resetting the primary context does not release it, an application that has\n retained the primary context should explicitly release its usage.\n#### dev:\n- Device for which primary context is destroyed\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE](crate::ffi::CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuDevicePrimaryCtxRetain](crate::ffi::cuDevicePrimaryCtxRetain),\n [cuDevicePrimaryCtxRelease](crate::ffi::cuDevicePrimaryCtxRelease),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cudaDeviceReset](crate::ffi::cudaDeviceReset)\n"]
    pub fn cuDevicePrimaryCtxReset_v2(dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a CUDA context\n\n### Note:\n ### Note:\nIn most cases it is recommended to use [cuDevicePrimaryCtxRetain](crate::ffi::cuDevicePrimaryCtxRetain).\n\n Creates a new CUDA context and associates it with the calling thread. The\n `flags` parameter is described below. The context is created with a usage\n count of 1 and the caller of [cuCtxCreate](crate::ffi::cuCtxCreate)() must call [cuCtxDestroy](crate::ffi::cuCtxDestroy)()\n when done using the context. If a context is already current to the thread,\n it is supplanted by the newly created context and may be restored by a subsequent\n call to [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent)().\n\n The three LSBs of the `flags` parameter can be used to control how the OS\n thread, which owns the CUDA context at the time of an API call, interacts\n with the OS scheduler when waiting for results from the GPU. Only one of\n the scheduling flags can be set when creating a context.\n\n - [CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN): Instruct CUDA to actively spin when waiting for\n results from the GPU. This can decrease latency when waiting for the GPU,\n but may lower the performance of CPU threads if they are performing work in\n parallel with the CUDA thread.\n\n - [CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD): Instruct CUDA to yield its thread when waiting for\n results from the GPU. This can increase latency when waiting for the GPU,\n but can increase the performance of CPU threads performing work in parallel\n with the GPU.\n\n - [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work.\n\n - [CU_CTX_BLOCKING_SYNC](crate::ffi::CU_CTX_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work. <br>\n <b>Deprecated:</b> This flag was deprecated as of CUDA 4.0 and was\n replaced with [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC).\n\n - [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO): The default value if the `flags` parameter is zero,\n uses a heuristic based on the number of active CUDA contexts in the\n process \\e C and the number of logical processors in the system \\e P. If\n \\e C > \\e P, then CUDA will yield to other OS threads when waiting for\n the GPU ([CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD)), otherwise CUDA will not yield while\n waiting for results and actively spin on the processor ([CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN)).\n Additionally, on Tegra devices, [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO) uses a heuristic based on\n the power profile of the platform and may choose [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC)\n for low-powered devices.\n\n - [CU_CTX_MAP_HOST](crate::ffi::CU_CTX_MAP_HOST): Instruct CUDA to support mapped pinned allocations.\n This flag must be set in order to allocate pinned host memory that is\n accessible to the GPU.\n\n - [CU_CTX_LMEM_RESIZE_TO_MAX](crate::ffi::CU_CTX_LMEM_RESIZE_TO_MAX): Instruct CUDA to not reduce local memory\n after resizing local memory for a kernel. This can prevent thrashing by\n local memory allocations when launching many kernels with high local\n memory usage at the cost of potentially increased memory usage. <br>\n <b>Deprecated:</b> This flag is deprecated and the behavior enabled\n by this flag is now the default and cannot be disabled.\n Instead, the per-thread stack size can be controlled with [cuCtxSetLimit](crate::ffi::cuCtxSetLimit)().\n\n - [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE): If GPU coredumps have not been enabled globally\n with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment variables, this flag can\n be set during context creation to instruct CUDA to create a coredump if\n this context raises an exception during execution. These environment variables\n are described in the CUDA-GDB user guide under the \"GPU core dump support\"\n section.\n The initial attributes will be taken from the global attributes at the time of\n context creation. The other attributes that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current.\n\n - [CU_CTX_USER_COREDUMP_ENABLE](crate::ffi::CU_CTX_USER_COREDUMP_ENABLE): If user-triggered GPU coredumps have not\n been enabled globally with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment\n variables, this flag can be set during context creation to instruct CUDA to\n create a coredump if data is written to a certain pipe that is present in the\n OS space. These environment variables are described in the CUDA-GDB user\n guide under the \"GPU core dump support\" section.\n It is important to note that the pipe name *must* be set with\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) before creating the context if this flag is\n used. Setting this flag implies that [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE) is set.\n The initial attributes will be taken from the global attributes at the time of\n context creation. The other attributes that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current.\n Setting this flag on any context creation is equivalent to setting the\n [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER) attribute to `true` globally.\n\n - [CU_CTX_SYNC_MEMOPS](crate::ffi::CU_CTX_SYNC_MEMOPS): Ensures that synchronous memory operations initiated\n on this context will always synchronize. See further documentation in the\n section titled \"API Synchronization behavior\" to learn more about cases when\n synchronous memory operations can exhibit asynchronous behavior.\n\n Context creation will fail with [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN) if the compute mode of\n the device is [CU_COMPUTEMODE_PROHIBITED](crate::ffi::CU_COMPUTEMODE_PROHIBITED). The function [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)()\n can be used with [CU_DEVICE_ATTRIBUTE_COMPUTE_MODE](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE) to determine the\n compute mode of the device. The <i>nvidia-smi</i> tool can be used to set\n the compute mode for * devices.\n Documentation for <i>nvidia-smi</i> can be obtained by passing a\n -h option to it.\n#### pctx:\n- Returned context handle of the new context\n#### flags:\n- Context creation flags\n#### dev:\n- Device to create context on\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal),\n [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxCreate_v2(
        pctx: *mut CUcontext,
        flags: ::std::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a CUDA context with execution affinity\n\n Creates a new CUDA context with execution affinity and associates it with\n the calling thread. The `paramsArray` and `flags` parameter are described below.\n The context is created with a usage count of 1 and the caller of [cuCtxCreate](crate::ffi::cuCtxCreate)() must\n call [cuCtxDestroy](crate::ffi::cuCtxDestroy)() when done using the context. If a context is already\n current to the thread, it is supplanted by the newly created context and may\n be restored by a subsequent call to [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent)().\n\n The type and the amount of execution resource the context can use is limited by `paramsArray`\n and `numParams`. The `paramsArray` is an array of `CUexecAffinityParam` and the `numParams`\n describes the size of the array. If two `CUexecAffinityParam` in the array have the same type,\n the latter execution affinity parameter overrides the former execution affinity parameter.\n The supported execution affinity types are:\n - [CU_EXEC_AFFINITY_TYPE_SM_COUNT](crate::ffi::CU_EXEC_AFFINITY_TYPE_SM_COUNT) limits the portion of SMs that the context can use. The portion\n   of SMs is specified as the number of SMs via `CUexecAffinitySmCount`. This limit will be internally\n   rounded up to the next hardware-supported amount. Hence, it is imperative to query the actual execution\n   affinity of the context via `cuCtxGetExecAffinity` after context creation. Currently, this attribute\n   is only supported under Volta+ MPS.\n\n The three LSBs of the `flags` parameter can be used to control how the OS\n thread, which owns the CUDA context at the time of an API call, interacts\n with the OS scheduler when waiting for results from the GPU. Only one of\n the scheduling flags can be set when creating a context.\n\n - [CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN): Instruct CUDA to actively spin when waiting for\n results from the GPU. This can decrease latency when waiting for the GPU,\n but may lower the performance of CPU threads if they are performing work in\n parallel with the CUDA thread.\n\n - [CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD): Instruct CUDA to yield its thread when waiting for\n results from the GPU. This can increase latency when waiting for the GPU,\n but can increase the performance of CPU threads performing work in parallel\n with the GPU.\n\n - [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work.\n\n - [CU_CTX_BLOCKING_SYNC](crate::ffi::CU_CTX_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work. <br>\n <b>Deprecated:</b> This flag was deprecated as of CUDA 4.0 and was\n replaced with [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC).\n\n - [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO): The default value if the `flags` parameter is zero,\n uses a heuristic based on the number of active CUDA contexts in the\n process \\e C and the number of logical processors in the system \\e P. If\n \\e C > \\e P, then CUDA will yield to other OS threads when waiting for\n the GPU ([CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD)), otherwise CUDA will not yield while\n waiting for results and actively spin on the processor ([CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN)).\n Additionally, on Tegra devices, [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO) uses a heuristic based on\n the power profile of the platform and may choose [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC)\n for low-powered devices.\n\n - [CU_CTX_MAP_HOST](crate::ffi::CU_CTX_MAP_HOST): Instruct CUDA to support mapped pinned allocations.\n This flag must be set in order to allocate pinned host memory that is\n accessible to the GPU.\n\n - [CU_CTX_LMEM_RESIZE_TO_MAX](crate::ffi::CU_CTX_LMEM_RESIZE_TO_MAX): Instruct CUDA to not reduce local memory\n after resizing local memory for a kernel. This can prevent thrashing by\n local memory allocations when launching many kernels with high local\n memory usage at the cost of potentially increased memory usage. <br>\n <b>Deprecated:</b> This flag is deprecated and the behavior enabled\n by this flag is now the default and cannot be disabled.\n Instead, the per-thread stack size can be controlled with [cuCtxSetLimit](crate::ffi::cuCtxSetLimit)().\n\n - [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE): If GPU coredumps have not been enabled globally\n with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment variables, this flag can\n be set during context creation to instruct CUDA to create a coredump if\n this context raises an exception during execution. These environment variables\n are described in the CUDA-GDB user guide under the \"GPU core dump support\"\n section.\n The initial attributes will be taken from the global attributes at the time of\n context creation. The other attributes that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current.\n\n - [CU_CTX_USER_COREDUMP_ENABLE](crate::ffi::CU_CTX_USER_COREDUMP_ENABLE): If user-triggered GPU coredumps have not\n been enabled globally with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment\n variables, this flag can be set during context creation to instruct CUDA to\n create a coredump if data is written to a certain pipe that is present in the\n OS space. These environment variables are described in the CUDA-GDB user\n guide under the \"GPU core dump support\" section.\n It is important to note that the pipe name *must* be set with\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) before creating the context if this flag is\n used. Setting this flag implies that [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE) is set.\n The initial attributes will be taken from the global attributes at the time of\n context creation. The other attributes that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current.\n Setting this flag on any context creation is equivalent to setting the\n [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER) attribute to `true` globally.\n\n Context creation will fail with [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN) if the compute mode of\n the device is [CU_COMPUTEMODE_PROHIBITED](crate::ffi::CU_COMPUTEMODE_PROHIBITED). The function [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)()\n can be used with [CU_DEVICE_ATTRIBUTE_COMPUTE_MODE](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE) to determine the\n compute mode of the device. The <i>nvidia-smi</i> tool can be used to set\n the compute mode for * devices.\n Documentation for <i>nvidia-smi</i> can be obtained by passing a\n -h option to it.\n#### pctx:\n- Returned context handle of the new context\n#### paramsArray:\n- Execution affinity parameters\n#### numParams:\n- Number of execution affinity parameters\n#### flags:\n- Context creation flags\n#### dev:\n- Device to create context on\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY](crate::ffi::CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal),\n [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute),\n [CUexecAffinityParam](crate::ffi::CUexecAffinityParam)\n"]
    pub fn cuCtxCreate_v3(
        pctx: *mut CUcontext,
        paramsArray: *mut CUexecAffinityParam,
        numParams: ::std::ffi::c_int,
        flags: ::std::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a CUDA context\n\n Creates a new CUDA context and associates it with the calling thread. The\n `flags` parameter is described below. The context is created with a usage\n count of 1 and the caller of [cuCtxCreate](crate::ffi::cuCtxCreate)() must call [cuCtxDestroy](crate::ffi::cuCtxDestroy)()\n when done using the context. If a context is already current to the thread,\n it is supplanted by the newly created context and may be restored by a subsequent\n call to [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent)().\n\n CUDA context can be created with execution affinity. The type and the amount of\nexecution resource the context can use is limited by `paramsArray` and `numExecAffinityParams`\nin `execAffinity`. The `paramsArray` is an array of `CUexecAffinityParam` and the `numExecAffinityParams`\n describes the size of the paramsArray. If two `CUexecAffinityParam` in the array have the same type,\n the latter execution affinity parameter overrides the former execution affinity parameter.\n The supported execution affinity types are:\n - [CU_EXEC_AFFINITY_TYPE_SM_COUNT](crate::ffi::CU_EXEC_AFFINITY_TYPE_SM_COUNT) limits the portion of SMs that the context can use. The portion\n   of SMs is specified as the number of SMs via `CUexecAffinitySmCount`. This limit will be internally\n   rounded up to the next hardware-supported amount. Hence, it is imperative to query the actual execution\n   affinity of the context via `cuCtxGetExecAffinity` after context creation. Currently, this attribute\n   is only supported under Volta+ MPS.\n\n CUDA context can be created in CIG(CUDA in Graphics) mode by setting `cigParams`.\n Data from graphics client is shared with CUDA via the `sharedData` in `cigParams`.\n Support for D3D12 graphics client can be determined using [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)() with\n [CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED). `sharedData` is a ID3D12CommandQueue handle.\n Either `execAffinityParams` or `cigParams` can be set to a non-null value. Setting both to a\n non-null value will result in an undefined behavior.\n\n The three LSBs of the `flags` parameter can be used to control how the OS\n thread, which owns the CUDA context at the time of an API call, interacts\n with the OS scheduler when waiting for results from the GPU. Only one of\n the scheduling flags can be set when creating a context.\n\n - [CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN): Instruct CUDA to actively spin when waiting for\n results from the GPU. This can decrease latency when waiting for the GPU,\n but may lower the performance of CPU threads if they are performing work in\n parallel with the CUDA thread.\n\n - [CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD): Instruct CUDA to yield its thread when waiting for\n results from the GPU. This can increase latency when waiting for the GPU,\n but can increase the performance of CPU threads performing work in parallel\n with the GPU.\n\n - [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work.\n\n - [CU_CTX_BLOCKING_SYNC](crate::ffi::CU_CTX_BLOCKING_SYNC): Instruct CUDA to block the CPU thread on a\n synchronization primitive when waiting for the GPU to finish work. <br>\n <b>Deprecated:</b> This flag was deprecated as of CUDA 4.0 and was\n replaced with [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC).\n\n - [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO): The default value if the `flags` parameter is zero,\n uses a heuristic based on the number of active CUDA contexts in the\n process \\e C and the number of logical processors in the system \\e P. If\n \\e C > \\e P, then CUDA will yield to other OS threads when waiting for\n the GPU ([CU_CTX_SCHED_YIELD](crate::ffi::CU_CTX_SCHED_YIELD)), otherwise CUDA will not yield while\n waiting for results and actively spin on the processor ([CU_CTX_SCHED_SPIN](crate::ffi::CU_CTX_SCHED_SPIN)).\n Additionally, on Tegra devices, [CU_CTX_SCHED_AUTO](crate::ffi::CU_CTX_SCHED_AUTO) uses a heuristic based on\n the power profile of the platform and may choose [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC)\n for low-powered devices.\n\n - [CU_CTX_MAP_HOST](crate::ffi::CU_CTX_MAP_HOST): Instruct CUDA to support mapped pinned allocations.\n This flag must be set in order to allocate pinned host memory that is\n accessible to the GPU.\n\n - [CU_CTX_LMEM_RESIZE_TO_MAX](crate::ffi::CU_CTX_LMEM_RESIZE_TO_MAX): Instruct CUDA to not reduce local memory\n after resizing local memory for a kernel. This can prevent thrashing by\n local memory allocations when launching many kernels with high local\n memory usage at the cost of potentially increased memory usage. <br>\n <b>Deprecated:</b> This flag is deprecated and the behavior enabled\n by this flag is now the default and cannot be disabled.\n Instead, the per-thread stack size can be controlled with [cuCtxSetLimit](crate::ffi::cuCtxSetLimit)().\n\n - [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE): If GPU coredumps have not been enabled globally\n with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment variables, this flag can\n be set during context creation to instruct CUDA to create a coredump if\n this context raises an exception during execution. These environment variables\n are described in the CUDA-GDB user guide under the \"GPU core dump support\"\n section.\n The initial attributes will be taken from the global attributes at the time of\n context creation. The other attributes that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current. This flag is not supported when CUDA context is created in\n CIG(CUDA in Graphics) mode.\n\n - [CU_CTX_USER_COREDUMP_ENABLE](crate::ffi::CU_CTX_USER_COREDUMP_ENABLE): If user-triggered GPU coredumps have not\n been enabled globally with [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) or environment\n variables, this flag can be set during context creation to instruct CUDA to\n create a coredump if data is written to a certain pipe that is present in the\n OS space. These environment variables are described in the CUDA-GDB user\n guide under the \"GPU core dump support\" section.\n It is important to note that the pipe name *must* be set with\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal) before creating the context if this flag is\n used. Setting this flag implies that [CU_CTX_COREDUMP_ENABLE](crate::ffi::CU_CTX_COREDUMP_ENABLE) is set.\n The initial attributes will be taken from the global attributes at the time of\n context creation. The other attributes that control coredump output can be\n modified by calling [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute) from the created context after\n it becomes current.\n Setting this flag on any context creation is equivalent to setting the\n [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER) attribute to `true` globally.\n This flag is not supported when CUDA context is created in\n CIG(CUDA in Graphics) mode.\n\n - [CU_CTX_SYNC_MEMOPS](crate::ffi::CU_CTX_SYNC_MEMOPS): Ensures that synchronous memory operations initiated\n on this context will always synchronize. See further documentation in the\n section titled \"API Synchronization behavior\" to learn more about cases when\n synchronous memory operations can exhibit asynchronous behavior.\n\n Context creation will fail with [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN) if the compute mode of\n the device is [CU_COMPUTEMODE_PROHIBITED](crate::ffi::CU_COMPUTEMODE_PROHIBITED). The function [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)()\n can be used with [CU_DEVICE_ATTRIBUTE_COMPUTE_MODE](crate::ffi::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE) to determine the\n compute mode of the device. The <i>nvidia-smi</i> tool can be used to set\n the compute mode for * devices.\n Documentation for <i>nvidia-smi</i> can be obtained by passing a\n -h option to it.\n\n Context creation will fail with :: CUDA_ERROR_INVALID_VALUE if invalid parameter was\n passed by client to create the CUDA context.\n\n Context creation in CIG mode will fail with [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED) if CIG is not supported\n by the device or the driver.\n#### pctx:\n- Returned context handle of the new context\n#### ctxCreateParams:\n- Context creation parameters\n#### flags:\n- Context creation flags\n#### dev:\n- Device to create context on\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal),\n [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxCreate_v4(
        pctx: *mut CUcontext,
        ctxCreateParams: *mut CUctxCreateParams,
        flags: ::std::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroy a CUDA context\n\n Destroys the CUDA context specified by `ctx`.  The context `ctx` will be\n destroyed regardless of how many threads it is current to.\n It is the responsibility of the calling function to ensure that no API\n call issues using `ctx` while [cuCtxDestroy](crate::ffi::cuCtxDestroy)() is executing.\n\n Destroys and cleans up all resources associated with the context.\n It is the caller's responsibility to ensure that the context or its resources\n are not accessed or passed in subsequent API calls and doing so will result in undefined behavior.\n These resources include CUDA types [CUmodule](crate::ffi::CUmodule), [CUfunction](crate::ffi::CUfunction), [CUstream](crate::ffi::CUstream), [CUevent](crate::ffi::CUevent),\n [CUarray](crate::ffi::CUarray), [CUmipmappedArray](crate::ffi::CUmipmappedArray), [CUtexObject](crate::ffi::CUtexObject), [CUsurfObject](crate::ffi::CUsurfObject), [CUtexref](crate::ffi::CUtexref), [CUsurfref](crate::ffi::CUsurfref),\n [CUgraphicsResource](crate::ffi::CUgraphicsResource), [CUlinkState](crate::ffi::CUlinkState), [CUexternalMemory](crate::ffi::CUexternalMemory) and [CUexternalSemaphore](crate::ffi::CUexternalSemaphore).\n These resources also include memory allocations by [cuMemAlloc](crate::ffi::cuMemAlloc)(), [cuMemAllocHost](crate::ffi::cuMemAllocHost)(),\n [cuMemAllocManaged](crate::ffi::cuMemAllocManaged)() and [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n\n If `ctx` is current to the calling thread then `ctx` will also be\n popped from the current thread's context stack (as though [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent)()\n were called).  If `ctx` is current to other threads, then `ctx` will\n remain current to those threads, and attempting to access `ctx` from\n those threads will result in the error [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED).\n\n### Note:\n ### Note:\n[cuCtxDestroy](crate::ffi::cuCtxDestroy)() will not destroy memory allocations by [cuMemCreate](crate::ffi::cuMemCreate)(), [cuMemAllocAsync](crate::ffi::cuMemAllocAsync)() and\n [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync)(). These memory allocations are not associated with any CUDA context and need to\n be destroyed explicitly.\n#### ctx:\n- Context to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxDestroy_v2(ctx: CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Pushes a context on the current CPU thread\n\n Pushes the given context `ctx` onto the CPU thread's stack of current\n contexts. The specified context becomes the CPU thread's current context, so\n all CUDA functions that operate on the current context are affected.\n\n The previous current context may be made current again by calling\n [cuCtxDestroy](crate::ffi::cuCtxDestroy)() or [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent)().\n#### ctx:\n- Context to push\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxPushCurrent_v2(ctx: CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Pops the current CUDA context from the current CPU thread.\n\n Pops the current CUDA context from the CPU thread and passes back the\n old context handle in `*pctx`. That context may then be made current\n to a different CPU thread by calling [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent)().\n\n If a context was current to the CPU thread before [cuCtxCreate](crate::ffi::cuCtxCreate)() or\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent)() was called, this function makes that context current to\n the CPU thread again.\n#### pctx:\n- Returned popped context handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxPopCurrent_v2(pctx: *mut CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Binds the specified CUDA context to the calling CPU thread\n\n Binds the specified CUDA context to the calling CPU thread.\n If `ctx` is NULL then the CUDA context previously bound to the\n calling CPU thread is unbound and [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) is returned.\n\n If there exists a CUDA context stack on the calling CPU thread, this\n will replace the top of that stack with `ctx`.\n If `ctx` is NULL then this will be equivalent to popping the top\n of the calling CPU thread's CUDA context stack (or a no-op if the\n calling CPU thread's CUDA context stack is empty).\n#### ctx:\n- Context to bind to the calling CPU thread\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuCtxGetCurrent](crate::ffi::cuCtxGetCurrent),\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cudaSetDevice](crate::ffi::cudaSetDevice)\n"]
    pub fn cuCtxSetCurrent(ctx: CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the CUDA context bound to the calling CPU thread.\n\n Returns in `*pctx` the CUDA context bound to the calling CPU thread.\n If no context is bound to the calling CPU thread then `*pctx` is\n set to NULL and [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) is returned.\n#### pctx:\n- Returned context handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuCtxSetCurrent](crate::ffi::cuCtxSetCurrent),\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cudaGetDevice](crate::ffi::cudaGetDevice)\n"]
    pub fn cuCtxGetCurrent(pctx: *mut CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the device handle for the current context\n\n Returns in `*device` the handle of the current context's device.\n#### device:\n- Returned device handle for the current context\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cudaGetDevice](crate::ffi::cudaGetDevice)\n"]
    pub fn cuCtxGetDevice(device: *mut CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the flags for the current context\n\n Returns in `*flags` the flags of the current context. See [cuCtxCreate](crate::ffi::cuCtxCreate)\n for flag values.\n#### flags:\n- Pointer to store flags of current context\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetCurrent](crate::ffi::cuCtxGetCurrent),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxGetSharedMemConfig](crate::ffi::cuCtxGetSharedMemConfig),\n [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n [cuCtxSetFlags](crate::ffi::cuCtxSetFlags),\n [cudaGetDeviceFlags](crate::ffi::cudaGetDeviceFlags)\n"]
    pub fn cuCtxGetFlags(flags: *mut ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the flags for the current context\n\n Sets the flags for the current context overwriting previously set ones. See\n [cuDevicePrimaryCtxSetFlags](crate::ffi::cuDevicePrimaryCtxSetFlags) for flag values.\n#### flags:\n- Flags to set on the current context\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetCurrent](crate::ffi::cuCtxGetCurrent),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxGetSharedMemConfig](crate::ffi::cuCtxGetSharedMemConfig),\n [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cudaGetDeviceFlags](crate::ffi::cudaGetDeviceFlags),\n [cuDevicePrimaryCtxSetFlags](crate::ffi::cuDevicePrimaryCtxSetFlags),\n"]
    pub fn cuCtxSetFlags(flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the unique Id associated with the context supplied\n\n Returns in `ctxId` the unique Id which is associated with a given context.\n The Id is unique for the life of the program for this instance of CUDA.\n If context is supplied as NULL and there is one current, the Id of the\n current context is returned.\n#### ctx:\n- Context for which to obtain the Id\n#### ctxId:\n- Pointer to store the Id of the context\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent)\n"]
    pub fn cuCtxGetId(ctx: CUcontext, ctxId: *mut ::std::ffi::c_ulonglong) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Block for the current context's tasks to complete\n\n Blocks until the current context has completed all preceding requested tasks.\n If the current context is the primary context, green contexts that have been\n created will also be synchronized.\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)() returns an error if one of the preceding tasks failed.\n If the context was created with the [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC) flag, the\n CPU thread will block until the GPU context has finished its work.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cudaDeviceSynchronize](crate::ffi::cudaDeviceSynchronize)\n"]
    pub fn cuCtxSynchronize() -> CUresult;
}
unsafe extern "C" {
    #[doc = " Set resource limits\n\n Setting `limit` to `value` is a request by the application to update\n the current limit maintained by the context. The driver is free to\n modify the requested value to meet h/w requirements (this could be\n clamping to minimum or maximum values, rounding up to nearest element\n size, etc). The application can use [cuCtxGetLimit](crate::ffi::cuCtxGetLimit)() to find out exactly\n what the limit has been set to.\n\n Setting each [CUlimit](crate::ffi::CUlimit) has its own specific restrictions, so each is\n discussed here.\n\n - [CU_LIMIT_STACK_SIZE](crate::ffi::CU_LIMIT_STACK_SIZE) controls the stack size in bytes of each GPU thread.\n   The driver automatically increases the per-thread stack size\n   for each kernel launch as needed. This size isn't reset back to the\n   original value after each launch. Setting this value will take effect\n   immediately, and if necessary, the device will block until all preceding\n   requested tasks are complete.\n\n - [CU_LIMIT_PRINTF_FIFO_SIZE](crate::ffi::CU_LIMIT_PRINTF_FIFO_SIZE) controls the size in bytes of the FIFO used\n   by the [printf](crate::ffi::printf)() device system call. Setting [CU_LIMIT_PRINTF_FIFO_SIZE](crate::ffi::CU_LIMIT_PRINTF_FIFO_SIZE)\n   must be performed before launching any kernel that uses the [printf](crate::ffi::printf)()\n   device system call, otherwise [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned.\n\n - [CU_LIMIT_MALLOC_HEAP_SIZE](crate::ffi::CU_LIMIT_MALLOC_HEAP_SIZE) controls the size in bytes of the heap used\n   by the [malloc](crate::ffi::malloc)() and [free](crate::ffi::free)() device system calls. Setting\n   [CU_LIMIT_MALLOC_HEAP_SIZE](crate::ffi::CU_LIMIT_MALLOC_HEAP_SIZE) must be performed before launching any kernel\n   that uses the [malloc](crate::ffi::malloc)() or [free](crate::ffi::free)() device system calls, otherwise\n   [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned.\n\n - [CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH](crate::ffi::CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH) controls the maximum nesting depth of\n   a grid at which a thread can safely call [cudaDeviceSynchronize](crate::ffi::cudaDeviceSynchronize)(). Setting\n   this limit must be performed before any launch of a kernel that uses the\n   device runtime and calls [cudaDeviceSynchronize](crate::ffi::cudaDeviceSynchronize)() above the default sync\n   depth, two levels of grids. Calls to [cudaDeviceSynchronize](crate::ffi::cudaDeviceSynchronize)() will fail\n   with error code [cudaErrorSyncDepthExceeded](crate::ffi::cudaErrorSyncDepthExceeded) if the limitation is\n   violated. This limit can be set smaller than the default or up the maximum\n   launch depth of 24. When setting this limit, keep in mind that additional\n   levels of sync depth require the driver to reserve large amounts of device\n   memory which can no longer be used for user allocations. If these\n   reservations of device memory fail, [cuCtxSetLimit](crate::ffi::cuCtxSetLimit)() will return\n   [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY), and the limit can be reset to a lower value.\n   This limit is only applicable to devices of compute capability < 9.0.\n   Attempting to set this limit on devices of other compute capability\n   versions will result in the error [CUDA_ERROR_UNSUPPORTED_LIMIT](crate::ffi::CUDA_ERROR_UNSUPPORTED_LIMIT) being\n   returned.\n\n - [CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT](crate::ffi::CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT) controls the maximum number of\n   outstanding device runtime launches that can be made from the current\n   context. A grid is outstanding from the point of launch up until the grid\n   is known to have been completed. Device runtime launches which violate\n   this limitation fail and return [cudaErrorLaunchPendingCountExceeded](crate::ffi::cudaErrorLaunchPendingCountExceeded) when\n   [cudaGetLastError](crate::ffi::cudaGetLastError)() is called after launch. If more pending launches than\n   the default (2048 launches) are needed for a module using the device\n   runtime, this limit can be increased. Keep in mind that being able to\n   sustain additional pending launches will require the driver to reserve\n   larger amounts of device memory upfront which can no longer be used for\n   allocations. If these reservations fail, [cuCtxSetLimit](crate::ffi::cuCtxSetLimit)() will return\n   [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY), and the limit can be reset to a lower value.\n   This limit is only applicable to devices of compute capability 3.5 and\n   higher. Attempting to set this limit on devices of compute capability less\n   than 3.5 will result in the error [CUDA_ERROR_UNSUPPORTED_LIMIT](crate::ffi::CUDA_ERROR_UNSUPPORTED_LIMIT) being\n   returned.\n\n - [CU_LIMIT_MAX_L2_FETCH_GRANULARITY](crate::ffi::CU_LIMIT_MAX_L2_FETCH_GRANULARITY) controls the L2 cache fetch granularity.\n   Values can range from 0B to 128B. This is purely a performance hint and\n   it can be ignored or clamped depending on the platform.\n\n - [CU_LIMIT_PERSISTING_L2_CACHE_SIZE](crate::ffi::CU_LIMIT_PERSISTING_L2_CACHE_SIZE) controls size in bytes available for\n   persisting L2 cache. This is purely a performance hint and it can be\n   ignored or clamped depending on the platform.\n#### limit:\n- Limit to set\n#### value:\n- Size of limit\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNSUPPORTED_LIMIT](crate::ffi::CUDA_ERROR_UNSUPPORTED_LIMIT),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cudaDeviceSetLimit](crate::ffi::cudaDeviceSetLimit)\n"]
    pub fn cuCtxSetLimit(limit: CUlimit, value: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns resource limits\n\n Returns in `*pvalue` the current size of `limit`.  The supported\n [CUlimit](crate::ffi::CUlimit) values are:\n - [CU_LIMIT_STACK_SIZE](crate::ffi::CU_LIMIT_STACK_SIZE): stack size in bytes of each GPU thread.\n - [CU_LIMIT_PRINTF_FIFO_SIZE](crate::ffi::CU_LIMIT_PRINTF_FIFO_SIZE): size in bytes of the FIFO used by the\n   [printf](crate::ffi::printf)() device system call.\n - [CU_LIMIT_MALLOC_HEAP_SIZE](crate::ffi::CU_LIMIT_MALLOC_HEAP_SIZE): size in bytes of the heap used by the\n   [malloc](crate::ffi::malloc)() and [free](crate::ffi::free)() device system calls.\n - [CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH](crate::ffi::CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH): maximum grid depth at which a thread\n   can issue the device runtime call [cudaDeviceSynchronize](crate::ffi::cudaDeviceSynchronize)() to wait on\n   child grid launches to complete.\n - [CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT](crate::ffi::CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT): maximum number of outstanding\n   device runtime launches that can be made from this context.\n - [CU_LIMIT_MAX_L2_FETCH_GRANULARITY](crate::ffi::CU_LIMIT_MAX_L2_FETCH_GRANULARITY): L2 cache fetch granularity.\n - [CU_LIMIT_PERSISTING_L2_CACHE_SIZE](crate::ffi::CU_LIMIT_PERSISTING_L2_CACHE_SIZE): Persisting L2 cache size in bytes\n#### limit:\n- Limit to query\n#### pvalue:\n- Returned size of limit\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNSUPPORTED_LIMIT](crate::ffi::CUDA_ERROR_UNSUPPORTED_LIMIT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cudaDeviceGetLimit](crate::ffi::cudaDeviceGetLimit)\n"]
    pub fn cuCtxGetLimit(pvalue: *mut usize, limit: CUlimit) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the preferred cache configuration for the current context.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this function returns through `pconfig` the preferred cache configuration\n for the current context. This is only a preference. The driver will use\n the requested configuration if possible, but it is free to choose a different\n configuration if required to execute functions.\n\n This will return a `pconfig` of [CU_FUNC_CACHE_PREFER_NONE](crate::ffi::CU_FUNC_CACHE_PREFER_NONE) on devices\n where the size of the L1 cache and shared memory are fixed.\n\n The supported cache configurations are:\n - [CU_FUNC_CACHE_PREFER_NONE](crate::ffi::CU_FUNC_CACHE_PREFER_NONE): no preference for shared memory or L1 (default)\n - [CU_FUNC_CACHE_PREFER_SHARED](crate::ffi::CU_FUNC_CACHE_PREFER_SHARED): prefer larger shared memory and smaller L1 cache\n - [CU_FUNC_CACHE_PREFER_L1](crate::ffi::CU_FUNC_CACHE_PREFER_L1): prefer larger L1 cache and smaller shared memory\n - [CU_FUNC_CACHE_PREFER_EQUAL](crate::ffi::CU_FUNC_CACHE_PREFER_EQUAL): prefer equal sized L1 cache and shared memory\n#### pconfig:\n- Returned cache configuration\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cudaDeviceGetCacheConfig](crate::ffi::cudaDeviceGetCacheConfig)\n"]
    pub fn cuCtxGetCacheConfig(pconfig: *mut CUfunc_cache) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the preferred cache configuration for the current context.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through `config` the preferred cache configuration for\n the current context. This is only a preference. The driver will use\n the requested configuration if possible, but it is free to choose a different\n configuration if required to execute the function. Any function preference\n set via [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig)() or [cuKernelSetCacheConfig](crate::ffi::cuKernelSetCacheConfig)() will be preferred over this context-wide\n setting. Setting the context-wide cache configuration to\n [CU_FUNC_CACHE_PREFER_NONE](crate::ffi::CU_FUNC_CACHE_PREFER_NONE) will cause subsequent kernel launches to prefer\n to not change the cache configuration unless required to launch the kernel.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n The supported cache configurations are:\n - [CU_FUNC_CACHE_PREFER_NONE](crate::ffi::CU_FUNC_CACHE_PREFER_NONE): no preference for shared memory or L1 (default)\n - [CU_FUNC_CACHE_PREFER_SHARED](crate::ffi::CU_FUNC_CACHE_PREFER_SHARED): prefer larger shared memory and smaller L1 cache\n - [CU_FUNC_CACHE_PREFER_L1](crate::ffi::CU_FUNC_CACHE_PREFER_L1): prefer larger L1 cache and smaller shared memory\n - [CU_FUNC_CACHE_PREFER_EQUAL](crate::ffi::CU_FUNC_CACHE_PREFER_EQUAL): prefer equal sized L1 cache and shared memory\n#### config:\n- Requested cache configuration\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cudaDeviceSetCacheConfig](crate::ffi::cudaDeviceSetCacheConfig),\n [cuKernelSetCacheConfig](crate::ffi::cuKernelSetCacheConfig)\n"]
    pub fn cuCtxSetCacheConfig(config: CUfunc_cache) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the context's API version.\n\n Returns a version number in `version` corresponding to the capabilities of\n the context (e.g. 3010 or 3020), which library developers can use to direct\n callers to a specific API version. If `ctx` is NULL, returns the API version\n used to create the currently bound context.\n\n Note that new API versions are only introduced when context capabilities are\n changed that break binary compatibility, so the API version and driver version\n may be different. For example, it is valid for the API version to be 3020 while\n the driver version is 4020.\n#### ctx:\n- Context to check\n#### version:\n- Pointer to version\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxGetApiVersion(ctx: CUcontext, version: *mut ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns numerical values that correspond to the least and\n greatest stream priorities.\n\n Returns in `*leastPriority` and `*greatestPriority` the numerical values that correspond\n to the least and greatest stream priorities respectively. Stream priorities\n follow a convention where lower numbers imply greater priorities. The range of\n meaningful stream priorities is given by [`*greatestPriority`, `*leastPriority`].\n If the user attempts to create a stream with a priority value that is\n outside the meaningful range as specified by this API, the priority is\n automatically clamped down or up to either `*leastPriority` or `*greatestPriority`\n respectively. See [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority) for details on creating a\n priority stream.\n A NULL may be passed in for `*leastPriority` or `*greatestPriority` if the value\n is not desired.\n\n This function will return '0' in both `*leastPriority` and `*greatestPriority` if\n the current context's device does not support stream priorities\n (see [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)).\n#### leastPriority:\n- Pointer to an int in which the numerical value for least\n                           stream priority is returned\n#### greatestPriority:\n- Pointer to an int in which the numerical value for greatest\n                           stream priority is returned\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cudaDeviceGetStreamPriorityRange](crate::ffi::cudaDeviceGetStreamPriorityRange)\n"]
    pub fn cuCtxGetStreamPriorityRange(
        leastPriority: *mut ::std::ffi::c_int,
        greatestPriority: *mut ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Resets all persisting lines in cache to normal status.\n\n [cuCtxResetPersistingL2Cache](crate::ffi::cuCtxResetPersistingL2Cache) Resets all persisting lines in cache to normal\n status. Takes effect on function return.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow)\n"]
    pub fn cuCtxResetPersistingL2Cache() -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the execution affinity setting for the current context.\n\n Returns in `*pExecAffinity` the current value of `type`. The supported\n [CUexecAffinityType](crate::ffi::CUexecAffinityType) values are:\n - [CU_EXEC_AFFINITY_TYPE_SM_COUNT](crate::ffi::CU_EXEC_AFFINITY_TYPE_SM_COUNT): number of SMs the context is limited to use.\n#### type:\n- Execution affinity type to query\n#### pExecAffinity:\n- Returned execution affinity\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY](crate::ffi::CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUexecAffinityParam](crate::ffi::CUexecAffinityParam)\n"]
    pub fn cuCtxGetExecAffinity(
        pExecAffinity: *mut CUexecAffinityParam,
        type_: CUexecAffinityType,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Records an event.\n\n Captures in `hEvent` all the activities of the context `hCtx`\n at the time of this call. `hEvent` and `hCtx` must be from the same\n CUDA context, otherwise [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) will be returned.\n Calls such as [cuEventQuery](crate::ffi::cuEventQuery)() or [cuCtxWaitEvent](crate::ffi::cuCtxWaitEvent)() will then examine\n or wait for completion of the work that was captured.\n Uses of `hCtx` after this call do not modify `hEvent`.\n If the context passed to `hCtx` is the primary context, `hEvent` will\n capture all the activities of the primary context and its green contexts.\n If the context passed to `hCtx` is a context converted from green context\n via [cuCtxFromGreenCtx](crate::ffi::cuCtxFromGreenCtx)(), `hEvent` will capture only the activities of the green context.\n\n### Note:\n ### Note:\nThe API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED) if the\n specified context `hCtx` has a stream in the capture mode. In such a case,\n the call will invalidate all the conflicting captures.\n#### hCtx:\n- Context to record event for\n#### hEvent:\n- Event to record\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED)\n\n ### See also:\n\n [cuCtxWaitEvent](crate::ffi::cuCtxWaitEvent),\n [cuGreenCtxRecordEvent](crate::ffi::cuGreenCtxRecordEvent),\n [cuGreenCtxWaitEvent](crate::ffi::cuGreenCtxWaitEvent),\n [cuEventRecord](crate::ffi::cuEventRecord)\n"]
    pub fn cuCtxRecordEvent(hCtx: CUcontext, hEvent: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Make a context wait on an event\n\n Makes all future work submitted to context `hCtx` wait for all work\n captured in `hEvent`. The synchronization will be performed on the device\n and will not block the calling CPU thread. See [cuCtxRecordEvent](crate::ffi::cuCtxRecordEvent)()\n for details on what is captured by an event.\n If the context passed to `hCtx` is the primary context, the primary context\n and its green contexts will wait for `hEvent`.\n If the context passed to `hCtx` is a context converted from green context\n via [cuCtxFromGreenCtx](crate::ffi::cuCtxFromGreenCtx)(), the green context will wait for `hEvent`.\n\n### Note:\n ### Note:\n`hEvent` may be from a different context or device than `hCtx`.\n\n ### Note:\nThe API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED) and\n invalidate the capture if the specified event `hEvent` is part of an ongoing\n capture sequence or if the specified context `hCtx` has a stream in the capture mode.\n#### hCtx:\n- Context to wait\n#### hEvent:\n- Event to wait on\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED)\n\n ### See also:\n\n [cuCtxRecordEvent](crate::ffi::cuCtxRecordEvent),\n [cuGreenCtxRecordEvent](crate::ffi::cuGreenCtxRecordEvent),\n [cuGreenCtxWaitEvent](crate::ffi::cuGreenCtxWaitEvent),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n"]
    pub fn cuCtxWaitEvent(hCtx: CUcontext, hEvent: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Increment a context's usage-count\n\n \\deprecated\n\n Note that this function is deprecated and should not be used.\n\n Increments the usage count of the context and passes back a context handle\n in `*pctx` that must be passed to [cuCtxDetach](crate::ffi::cuCtxDetach)() when the application is\n done with the context. [cuCtxAttach](crate::ffi::cuCtxAttach)() fails if there is no context current\n to the thread.\n\n Currently, the `flags` parameter must be 0.\n#### pctx:\n- Returned context handle of the current context\n#### flags:\n- Context attach flags (must be 0)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxDetach](crate::ffi::cuCtxDetach),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxAttach(pctx: *mut CUcontext, flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Decrement a context's usage-count\n\n \\deprecated\n\n Note that this function is deprecated and should not be used.\n\n Decrements the usage count of the context `ctx`, and destroys the context\n if the usage count goes to 0. The context must be a handle that was passed\n back by [cuCtxCreate](crate::ffi::cuCtxCreate)() or [cuCtxAttach](crate::ffi::cuCtxAttach)(), and must be current to the\n calling thread.\n#### ctx:\n- Context to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize)\n"]
    pub fn cuCtxDetach(ctx: CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the current shared memory configuration for the current context.\n\n \\deprecated\n\n This function will return in `pConfig` the current size of shared memory banks\n in the current context. On devices with configurable shared memory banks,\n [cuCtxSetSharedMemConfig](crate::ffi::cuCtxSetSharedMemConfig) can be used to change this setting, so that all\n subsequent kernel launches will by default use the new bank size. When\n [cuCtxGetSharedMemConfig](crate::ffi::cuCtxGetSharedMemConfig) is called on devices without configurable shared\n memory, it will return the fixed bank size of the hardware.\n\n The returned bank configurations can be either:\n - [CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE):  shared memory bank width is\n   four bytes.\n - [CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE): shared memory bank width will\n   eight bytes.\n#### pConfig:\n- returned shared memory configuration\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cuCtxGetSharedMemConfig](crate::ffi::cuCtxGetSharedMemConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cudaDeviceGetSharedMemConfig](crate::ffi::cudaDeviceGetSharedMemConfig)\n"]
    pub fn cuCtxGetSharedMemConfig(pConfig: *mut CUsharedconfig) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the shared memory configuration for the current context.\n\n \\deprecated\n\n On devices with configurable shared memory banks, this function will set\n the context's shared memory bank size which is used for subsequent kernel\n launches.\n\n Changed the shared memory configuration between launches may insert a device\n side synchronization point between those launches.\n\n Changing the shared memory bank size will not increase shared memory usage\n or affect occupancy of kernels, but may have major effects on performance.\n Larger bank sizes will allow for greater potential bandwidth to shared memory,\n but will change what kinds of accesses to shared memory will result in bank\n conflicts.\n\n This function will do nothing on devices with fixed shared memory bank size.\n\n The supported bank configurations are:\n - [CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE): set bank width to the default initial\n   setting (currently, four bytes).\n - [CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE): set shared memory bank width to\n   be natively four bytes.\n - [CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE): set shared memory bank width to\n   be natively eight bytes.\n#### config:\n- requested shared memory configuration\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy),\n [cuCtxGetApiVersion](crate::ffi::cuCtxGetApiVersion),\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxGetDevice](crate::ffi::cuCtxGetDevice),\n [cuCtxGetFlags](crate::ffi::cuCtxGetFlags),\n [cuCtxGetLimit](crate::ffi::cuCtxGetLimit),\n [cuCtxPopCurrent](crate::ffi::cuCtxPopCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuCtxSetLimit](crate::ffi::cuCtxSetLimit),\n [cuCtxSynchronize](crate::ffi::cuCtxSynchronize),\n [cuCtxGetSharedMemConfig](crate::ffi::cuCtxGetSharedMemConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cudaDeviceSetSharedMemConfig](crate::ffi::cudaDeviceSetSharedMemConfig)\n"]
    pub fn cuCtxSetSharedMemConfig(config: CUsharedconfig) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Loads a compute module\n\n Takes a filename `fname` and loads the corresponding module `module` into\n the current context. The CUDA driver API does not attempt to lazily\n allocate the resources needed by a module; if the memory for functions and\n data (constant and global) needed by the module cannot be allocated,\n [cuModuleLoad](crate::ffi::cuModuleLoad)() fails. The file should be a \\e cubin file as output by\n \\b nvcc, or a \\e PTX file either as output by \\b nvcc or handwritten, or\n a \\e fatbin file as output by \\b nvcc from toolchain 4.0 or later.\n#### module:\n- Returned module\n#### fname:\n- Filename of module to load\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_FILE_NOT_FOUND](crate::ffi::CUDA_ERROR_FILE_NOT_FOUND),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU),\n [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](crate::ffi::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](crate::ffi::CUDA_ERROR_JIT_COMPILER_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuModuleLoad(module: *mut CUmodule, fname: *const ::std::ffi::c_char) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Load a module's data\n\n Takes a pointer `image` and loads the corresponding module `module` into\n the current context. The `image` may be a \\e cubin or \\e fatbin\n as output by \\b nvcc, or a NULL-terminated \\e PTX, either as output by \\b nvcc\n or hand-written.\n#### module:\n- Returned module\n#### image:\n- Module data to load\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU),\n [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](crate::ffi::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](crate::ffi::CUDA_ERROR_JIT_COMPILER_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuModuleLoadData(module: *mut CUmodule, image: *const ::std::ffi::c_void) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Load a module's data with options\n\n Takes a pointer `image` and loads the corresponding module `module` into\n the current context. The `image` may be a \\e cubin or \\e fatbin\n as output by \\b nvcc, or a NULL-terminated \\e PTX, either as output by \\b nvcc\n or hand-written.\n#### module:\n- Returned module\n#### image:\n- Module data to load\n#### numOptions:\n- Number of options\n#### options:\n- Options for JIT\n#### optionValues:\n- Option values for JIT\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU),\n [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](crate::ffi::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](crate::ffi::CUDA_ERROR_JIT_COMPILER_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuModuleLoadDataEx(
        module: *mut CUmodule,
        image: *const ::std::ffi::c_void,
        numOptions: ::std::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Load a module's data\n\n Takes a pointer `fatCubin` and loads the corresponding module `module`\n into the current context. The pointer represents a <i>fat binary</i> object,\n which is a collection of different \\e cubin and/or \\e PTX files, all\n representing the same device code, but compiled and optimized for different\n architectures.\n\n Prior to CUDA 4.0, there was no documented API for constructing and using\n fat binary objects by programmers.  Starting with CUDA 4.0, fat binary\n objects can be constructed by providing the <i>-fatbin option</i> to \\b nvcc.\n More information can be found in the \\b nvcc document.\n#### module:\n- Returned module\n#### fatCubin:\n- Fat binary to load\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU),\n [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](crate::ffi::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](crate::ffi::CUDA_ERROR_JIT_COMPILER_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuModuleLoadFatBinary(
        module: *mut CUmodule,
        fatCubin: *const ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unloads a module\n\n Unloads a module `hmod` from the current context. Attempting to unload\n a module which was obtained from the Library Management API such as\n [cuLibraryGetModule](crate::ffi::cuLibraryGetModule) will return [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED).\n#### hmod:\n- Module to unload\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n \\note_destroy_ub\n\n ### See also:\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary)\n"]
    pub fn cuModuleUnload(hmod: CUmodule) -> CUresult;
}
#[repr(u32)]
#[doc = " CUDA Lazy Loading status\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmoduleLoadingMode_enum {
    #[doc = "< Lazy Kernel Loading is not enabled\n"]
    CU_MODULE_EAGER_LOADING = 1,
    #[doc = "< Lazy Kernel Loading is enabled\n"]
    CU_MODULE_LAZY_LOADING = 2,
}
#[doc = " CUDA Lazy Loading status\n"]
pub use self::CUmoduleLoadingMode_enum as CUmoduleLoadingMode;
unsafe extern "C" {
    #[doc = " Query lazy loading mode\n\n Returns lazy loading mode\n Module loading mode is controlled by CUDA_MODULE_LOADING env variable\n#### mode:\n- Returns the lazy loading mode\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n"]
    pub fn cuModuleGetLoadingMode(mode: *mut CUmoduleLoadingMode) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a function handle\n\n Returns in `*hfunc` the handle of the function of name `name` located in\n module `hmod`. If no function of that name exists, [cuModuleGetFunction](crate::ffi::cuModuleGetFunction)()\n returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n#### hfunc:\n- Returned function handle\n#### hmod:\n- Module to retrieve function from\n#### name:\n- Name of function to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuModuleGetFunction(
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the number of functions within a module\n\n Returns in `count` the number of functions in `mod`.\n#### count:\n- Number of functions found within the module\n#### mod:\n- Module to query\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n"]
    pub fn cuModuleGetFunctionCount(count: *mut ::std::ffi::c_uint, mod_: CUmodule) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the function handles within a module.\n\n Returns in `functions` a maximum number of `numFunctions` function handles within `mod`. When\n function loading mode is set to LAZY the function retrieved may be partially loaded. The loading\n state of a function can be queried using [cuFunctionIsLoaded](crate::ffi::cuFunctionIsLoaded). CUDA APIs may load the function\n automatically when called with partially loaded function handle which may incur additional\n latency. Alternatively, [cuFunctionLoad](crate::ffi::cuFunctionLoad) can be used to explicitly load a function. The returned\n function handles become invalid when the module is unloaded.\n#### functions:\n- Buffer where the function handles are returned to\n#### numFunctions:\n- Maximum number of function handles may be returned to the buffer\n#### mod:\n- Module to query from\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetFunctionCount](crate::ffi::cuModuleGetFunctionCount),\n [cuFuncIsLoaded](crate::ffi::cuFuncIsLoaded),\n [cuFuncLoad](crate::ffi::cuFuncLoad)\n"]
    pub fn cuModuleEnumerateFunctions(
        functions: *mut CUfunction,
        numFunctions: ::std::ffi::c_uint,
        mod_: CUmodule,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a global pointer from a module\n\n Returns in `*dptr` and `*bytes` the base pointer and size of the\n global of name `name` located in module `hmod`. If no variable of that name\n exists, [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal)() returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n One of the parameters `dptr` or `bytes` (not both) can be NULL in which\n case it is ignored.\n#### dptr:\n- Returned global device pointer\n#### bytes:\n- Returned global size in bytes\n#### hmod:\n- Module to retrieve global from\n#### name:\n- Name of global to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary),\n [cuModuleUnload](crate::ffi::cuModuleUnload),\n [cudaGetSymbolAddress](crate::ffi::cudaGetSymbolAddress),\n [cudaGetSymbolSize](crate::ffi::cudaGetSymbolSize)\n"]
    pub fn cuModuleGetGlobal_v2(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        hmod: CUmodule,
        name: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a pending JIT linker invocation.\n\n If the call is successful, the caller owns the returned CUlinkState, which\n should eventually be destroyed with [cuLinkDestroy](crate::ffi::cuLinkDestroy).  The\n device code machine size (32 or 64 bit) will match the calling application.\n\n Both linker and compiler options may be specified.  Compiler options will\n be applied to inputs to this linker action which must be compiled from PTX.\n The options [CU_JIT_WALL_TIME](crate::ffi::CU_JIT_WALL_TIME),\n [CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES](crate::ffi::CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES), and [CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES](crate::ffi::CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES)\n will accumulate data until the CUlinkState is destroyed.\n\n The data passed in via [cuLinkAddData](crate::ffi::cuLinkAddData) and [cuLinkAddFile](crate::ffi::cuLinkAddFile) will be treated\n as relocatable (-rdc=true to nvcc) when linking the final cubin during\n [cuLinkComplete](crate::ffi::cuLinkComplete) and will have similar consequences as offline relocatable\n device code linking.\n\n `optionValues` must remain valid for the life of the CUlinkState if output\n options are used.  No other references to inputs are maintained after this\n call returns.\n\n### Note:\n ### Note:\nFor LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted\n#### numOptions:\nSize of options arrays\n#### options:\nArray of linker and compiler options\n#### optionValues:\nArray of option values, each cast to void *\n#### stateOut:\nOn success, this will contain a CUlinkState to specify\n                     and complete this action\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](crate::ffi::CUDA_ERROR_JIT_COMPILER_NOT_FOUND)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuLinkAddData](crate::ffi::cuLinkAddData),\n [cuLinkAddFile](crate::ffi::cuLinkAddFile),\n [cuLinkComplete](crate::ffi::cuLinkComplete),\n [cuLinkDestroy](crate::ffi::cuLinkDestroy)\n"]
    pub fn cuLinkCreate_v2(
        numOptions: ::std::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::ffi::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Add an input to a pending linker invocation\n\n Ownership of `data` is retained by the caller.  No reference is retained to any\n inputs after this call returns.\n\n This method accepts only compiler options, which are used if the data must\n be compiled from PTX, and does not accept any of\n [CU_JIT_WALL_TIME](crate::ffi::CU_JIT_WALL_TIME), [CU_JIT_INFO_LOG_BUFFER](crate::ffi::CU_JIT_INFO_LOG_BUFFER), [CU_JIT_ERROR_LOG_BUFFER](crate::ffi::CU_JIT_ERROR_LOG_BUFFER),\n [CU_JIT_TARGET_FROM_CUCONTEXT](crate::ffi::CU_JIT_TARGET_FROM_CUCONTEXT), or [CU_JIT_TARGET](crate::ffi::CU_JIT_TARGET).\n\n### Note:\n ### Note:\nFor LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted\n#### state:\nA pending linker action.\n#### type:\nThe type of the input data.\n#### data:\nThe input data.  PTX must be NULL-terminated.\n#### size:\nThe length of the input data.\n#### name:\nAn optional name for this input in log messages.\n#### numOptions:\nSize of options.\n#### options:\nOptions to be applied only for this input (overrides options from [cuLinkCreate](crate::ffi::cuLinkCreate)).\n#### optionValues:\nArray of option values, each cast to void *.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU)\n\n ### See also:\n [cuLinkCreate](crate::ffi::cuLinkCreate),\n [cuLinkAddFile](crate::ffi::cuLinkAddFile),\n [cuLinkComplete](crate::ffi::cuLinkComplete),\n [cuLinkDestroy](crate::ffi::cuLinkDestroy)\n"]
    pub fn cuLinkAddData_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::std::ffi::c_void,
        size: usize,
        name: *const ::std::ffi::c_char,
        numOptions: ::std::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Add a file input to a pending linker invocation\n\n No reference is retained to any inputs after this call returns.\n\n This method accepts only compiler options, which are used if the input\n must be compiled from PTX, and does not accept any of\n [CU_JIT_WALL_TIME](crate::ffi::CU_JIT_WALL_TIME), [CU_JIT_INFO_LOG_BUFFER](crate::ffi::CU_JIT_INFO_LOG_BUFFER), [CU_JIT_ERROR_LOG_BUFFER](crate::ffi::CU_JIT_ERROR_LOG_BUFFER),\n [CU_JIT_TARGET_FROM_CUCONTEXT](crate::ffi::CU_JIT_TARGET_FROM_CUCONTEXT), or [CU_JIT_TARGET](crate::ffi::CU_JIT_TARGET).\n\n This method is equivalent to invoking [cuLinkAddData](crate::ffi::cuLinkAddData) on the contents\n of the file.\n\n### Note:\n ### Note:\nFor LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted\n#### state:\nA pending linker action\n#### type:\nThe type of the input data\n#### path:\nPath to the input file\n#### numOptions:\nSize of options\n#### options:\nOptions to be applied only for this input (overrides options from [cuLinkCreate](crate::ffi::cuLinkCreate))\n#### optionValues:\nArray of option values, each cast to void *\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_FILE_NOT_FOUND](crate::ffi::CUDA_ERROR_FILE_NOT_FOUND)\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU)\n\n ### See also:\n [cuLinkCreate](crate::ffi::cuLinkCreate),\n [cuLinkAddData](crate::ffi::cuLinkAddData),\n [cuLinkComplete](crate::ffi::cuLinkComplete),\n [cuLinkDestroy](crate::ffi::cuLinkDestroy)\n"]
    pub fn cuLinkAddFile_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        path: *const ::std::ffi::c_char,
        numOptions: ::std::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Complete a pending linker invocation\n\n Completes the pending linker action and returns the cubin image for the linked\n device code, which can be used with [cuModuleLoadData](crate::ffi::cuModuleLoadData).  The cubin is owned by\n `state`, so it should be loaded before `state` is destroyed via [cuLinkDestroy](crate::ffi::cuLinkDestroy).\n This call does not destroy `state`.\n#### state:\nA pending linker invocation\n#### cubinOut:\nOn success, this will point to the output image\n#### sizeOut:\nOptional parameter to receive the size of the generated image\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuLinkCreate](crate::ffi::cuLinkCreate),\n [cuLinkAddData](crate::ffi::cuLinkAddData),\n [cuLinkAddFile](crate::ffi::cuLinkAddFile),\n [cuLinkDestroy](crate::ffi::cuLinkDestroy),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData)\n"]
    pub fn cuLinkComplete(
        state: CUlinkState,
        cubinOut: *mut *mut ::std::ffi::c_void,
        sizeOut: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys state for a JIT linker invocation.\n#### state:\nState object for the linker invocation\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n\n ### See also:\n [cuLinkCreate](crate::ffi::cuLinkCreate)\n"]
    pub fn cuLinkDestroy(state: CUlinkState) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a handle to a texture reference\n\n \\deprecated\n\n Returns in `*pTexRef` the handle of the texture reference of name `name`\n in the module `hmod`. If no texture reference of that name exists,\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef)() returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND). This texture reference\n handle should not be destroyed, since it will be destroyed when the module\n is unloaded.\n#### pTexRef:\n- Returned texture reference\n#### hmod:\n- Module to retrieve texture reference from\n#### name:\n- Name of texture reference to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetSurfRef](crate::ffi::cuModuleGetSurfRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuModuleGetTexRef(
        pTexRef: *mut CUtexref,
        hmod: CUmodule,
        name: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a handle to a surface reference\n\n \\deprecated\n\n Returns in `*pSurfRef` the handle of the surface reference of name `name`\n in the module `hmod`. If no surface reference of that name exists,\n [cuModuleGetSurfRef](crate::ffi::cuModuleGetSurfRef)() returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n#### pSurfRef:\n- Returned surface reference\n#### hmod:\n- Module to retrieve surface reference from\n#### name:\n- Name of surface reference to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuModuleGetGlobal](crate::ffi::cuModuleGetGlobal),\n [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx),\n [cuModuleLoadFatBinary](crate::ffi::cuModuleLoadFatBinary),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuModuleGetSurfRef(
        pSurfRef: *mut CUsurfref,
        hmod: CUmodule,
        name: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Load a library with specified code and options\n\n Takes a pointer `code` and loads the corresponding library `library` based on\n the application defined library loading mode:\n - If module loading is set to EAGER, via the environment variables described in \"Module loading\",\n   `library` is loaded eagerly into all contexts at the time of the call and future contexts\n   at the time of creation until the library is unloaded with [cuLibraryUnload](crate::ffi::cuLibraryUnload)().\n - If the environment variables are set to LAZY, `library`\n   is not immediately loaded onto all existent contexts and will only be\n   loaded when a function is needed for that context, such as a kernel launch.\n\n These environment variables are described in the CUDA programming guide under the\n \"CUDA environment variables\" section.\n\n The `code` may be a \\e cubin or \\e fatbin as output by \\b nvcc,\n or a NULL-terminated \\e PTX, either as output by \\b nvcc or hand-written.\n A fatbin should also contain relocatable code when doing separate compilation.\n\n Options are passed as an array via `jitOptions` and any corresponding parameters are passed in\n `jitOptionsValues`. The number of total JIT options is supplied via `numJitOptions`.\n Any outputs will be returned via `jitOptionsValues`.\n\n Library load options are passed as an array via `libraryOptions` and any corresponding parameters are passed in\n `libraryOptionValues`. The number of total library load options is supplied via `numLibraryOptions`.\n\n### Note:\n ### Note:\nIf the library contains managed variables and no device in the system\n supports managed variables this call is expected to return [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n#### library:\n- Returned library\n#### code:\n- Code to load\n#### jitOptions:\n- Options for JIT\n#### jitOptionsValues:\n- Option values for JIT\n#### numJitOptions:\n- Number of options\n#### libraryOptions:\n- Options for loading\n#### libraryOptionValues:\n- Option values for loading\n#### numLibraryOptions:\n- Number of options for loading\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU),\n [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](crate::ffi::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](crate::ffi::CUDA_ERROR_JIT_COMPILER_NOT_FOUND),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx)\n"]
    pub fn cuLibraryLoadData(
        library: *mut CUlibrary,
        code: *const ::std::ffi::c_void,
        jitOptions: *mut CUjit_option,
        jitOptionsValues: *mut *mut ::std::ffi::c_void,
        numJitOptions: ::std::ffi::c_uint,
        libraryOptions: *mut CUlibraryOption,
        libraryOptionValues: *mut *mut ::std::ffi::c_void,
        numLibraryOptions: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Load a library with specified file and options\n\n Takes a pointer `code` and loads the corresponding library `library` based on\n the application defined library loading mode:\n - If module loading is set to EAGER, via the environment variables described in \"Module loading\",\n   `library` is loaded eagerly into all contexts at the time of the call and future contexts\n   at the time of creation until the library is unloaded with [cuLibraryUnload](crate::ffi::cuLibraryUnload)().\n - If the environment variables are set to LAZY, `library`\n   is not immediately loaded onto all existent contexts and will only be\n   loaded when a function is needed for that context, such as a kernel launch.\n\n These environment variables are described in the CUDA programming guide under the\n \"CUDA environment variables\" section.\n\n The file should be a \\e cubin file as output by \\b nvcc, or a \\e PTX file either\n as output by \\b nvcc or handwritten, or a \\e fatbin file as output by \\b nvcc.\n A fatbin should also contain relocatable code when doing separate compilation.\n\n Options are passed as an array via `jitOptions` and any corresponding parameters are\n passed in `jitOptionsValues`. The number of total options is supplied via `numJitOptions`.\n Any outputs will be returned via `jitOptionsValues`.\n\n Library load options are passed as an array via `libraryOptions` and any corresponding parameters are passed in\n `libraryOptionValues`. The number of total library load options is supplied via `numLibraryOptions`.\n\n### Note:\n ### Note:\nIf the library contains managed variables and no device in the system\n supports managed variables this call is expected to return [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n#### library:\n- Returned library\n#### fileName:\n- File to load from\n#### jitOptions:\n- Options for JIT\n#### jitOptionsValues:\n- Option values for JIT\n#### numJitOptions:\n- Number of options\n#### libraryOptions:\n- Options for loading\n#### libraryOptionValues:\n- Option values for loading\n#### numLibraryOptions:\n- Number of options for loading\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_PTX](crate::ffi::CUDA_ERROR_INVALID_PTX),\n [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](crate::ffi::CUDA_ERROR_UNSUPPORTED_PTX_VERSION),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NO_BINARY_FOR_GPU](crate::ffi::CUDA_ERROR_NO_BINARY_FOR_GPU),\n [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](crate::ffi::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](crate::ffi::CUDA_ERROR_JIT_COMPILER_NOT_FOUND),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuModuleLoad](crate::ffi::cuModuleLoad),\n [cuModuleLoadData](crate::ffi::cuModuleLoadData),\n [cuModuleLoadDataEx](crate::ffi::cuModuleLoadDataEx)\n"]
    pub fn cuLibraryLoadFromFile(
        library: *mut CUlibrary,
        fileName: *const ::std::ffi::c_char,
        jitOptions: *mut CUjit_option,
        jitOptionsValues: *mut *mut ::std::ffi::c_void,
        numJitOptions: ::std::ffi::c_uint,
        libraryOptions: *mut CUlibraryOption,
        libraryOptionValues: *mut *mut ::std::ffi::c_void,
        numLibraryOptions: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unloads a library\n\n Unloads the library specified with `library`\n#### library:\n- Library to unload\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuModuleUnload](crate::ffi::cuModuleUnload)\n"]
    pub fn cuLibraryUnload(library: CUlibrary) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a kernel handle\n\n Returns in `pKernel` the handle of the kernel with name `name` located in library `library`.\n If kernel handle is not found, the call returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n#### pKernel:\n- Returned kernel handle\n#### library:\n- Library to retrieve kernel from\n#### name:\n- Name of kernel to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuKernelGetFunction](crate::ffi::cuKernelGetFunction),\n [cuLibraryGetModule](crate::ffi::cuLibraryGetModule),\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction)\n"]
    pub fn cuLibraryGetKernel(
        pKernel: *mut CUkernel,
        library: CUlibrary,
        name: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the number of kernels within a library\n\n Returns in `count` the number of kernels in `lib`.\n#### count:\n- Number of kernels found within the library\n#### lib:\n- Library to query\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n"]
    pub fn cuLibraryGetKernelCount(count: *mut ::std::ffi::c_uint, lib: CUlibrary) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Retrieve the kernel handles within a library.\n\n Returns in `kernels` a maximum number of `numKernels` kernel handles within `lib`.\n The returned kernel handle becomes invalid when the library is unloaded.\n#### kernels:\n- Buffer where the kernel handles are returned to\n#### numKernels:\n- Maximum number of kernel handles may be returned to the buffer\n#### lib:\n- Library to query from\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuLibraryGetKernelCount](crate::ffi::cuLibraryGetKernelCount)\n"]
    pub fn cuLibraryEnumerateKernels(
        kernels: *mut CUkernel,
        numKernels: ::std::ffi::c_uint,
        lib: CUlibrary,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a module handle\n\n Returns in `pMod` the module handle associated with the current context located in\n library `library`. If module handle is not found, the call returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n#### pMod:\n- Returned module handle\n#### library:\n- Library to retrieve module from\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction)\n"]
    pub fn cuLibraryGetModule(pMod: *mut CUmodule, library: CUlibrary) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a function handle\n\n Returns in `pFunc` the handle of the function for the requested kernel `kernel` and\n the current context. If function handle is not found, the call returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n#### pFunc:\n- Returned function handle\n#### kernel:\n- Kernel to retrieve function for the requested context\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel),\n [cuLibraryGetModule](crate::ffi::cuLibraryGetModule),\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction)\n"]
    pub fn cuKernelGetFunction(pFunc: *mut CUfunction, kernel: CUkernel) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a library handle\n\n Returns in `pLib` the handle of the library for the requested kernel `kernel`\n#### pLib:\n- Returned library handle\n#### kernel:\n- Kernel to retrieve library handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)\n"]
    pub fn cuKernelGetLibrary(pLib: *mut CUlibrary, kernel: CUkernel) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a global device pointer\n\n Returns in `*dptr` and `*bytes` the base pointer and size of the global with\n name `name` for the requested library `library` and the current context.\n If no global for the requested name `name` exists, the call returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n One of the parameters `dptr` or `bytes` (not both) can be NULL in which\n case it is ignored.\n#### dptr:\n- Returned global device pointer for the requested context\n#### bytes:\n- Returned global size in bytes\n#### library:\n- Library to retrieve global from\n#### name:\n- Name of global to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuLibraryGetModule](crate::ffi::cuLibraryGetModule),\n cuModuleGetGlobal\n"]
    pub fn cuLibraryGetGlobal(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        library: CUlibrary,
        name: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to managed memory\n\n Returns in `*dptr` and `*bytes` the base pointer and size of the managed memory with\n name `name` for the requested library `library`. If no managed memory with the\n requested name `name` exists, the call returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND). One of the parameters\n `dptr` or `bytes` (not both) can be NULL in which case it is ignored.\n Note that managed memory for library `library` is shared across devices and is registered\n when the library is loaded into atleast one context.\n#### dptr:\n- Returned pointer to the managed memory\n#### bytes:\n- Returned memory size in bytes\n#### library:\n- Library to retrieve managed memory from\n#### name:\n- Name of managed memory to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload)\n"]
    pub fn cuLibraryGetManaged(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        library: CUlibrary,
        name: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to a unified function\n\n Returns in `*fptr` the function pointer to a unified function denoted by `symbol`.\n If no unified function with name `symbol` exists, the call returns [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n If there is no device with attribute [CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS](crate::ffi::CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS) present in the system,\n the call may return [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND).\n#### fptr:\n- Returned pointer to a unified function\n#### library:\n- Library to retrieve function pointer memory from\n#### symbol:\n- Name of function pointer to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload)\n"]
    pub fn cuLibraryGetUnifiedFunction(
        fptr: *mut *mut ::std::ffi::c_void,
        library: CUlibrary,
        symbol: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns information about a kernel\n\n Returns in `*pi` the integer value of the attribute `attrib` for the kernel\n `kernel` for the requested device `dev`. The supported attributes are:\n - [CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK): The maximum number of threads\n   per block, beyond which a launch of the kernel would fail. This number\n   depends on both the kernel and the requested device.\n - [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES): The size in bytes of\n   statically-allocated shared memory per block required by this kernel.\n   This does not include dynamically-allocated shared memory requested by\n   the user at runtime.\n - [CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES): The size in bytes of user-allocated\n   constant memory required by this kernel.\n - [CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES): The size in bytes of local memory\n   used by each thread of this kernel.\n - [CU_FUNC_ATTRIBUTE_NUM_REGS](crate::ffi::CU_FUNC_ATTRIBUTE_NUM_REGS): The number of registers used by each thread\n   of this kernel.\n - [CU_FUNC_ATTRIBUTE_PTX_VERSION](crate::ffi::CU_FUNC_ATTRIBUTE_PTX_VERSION): The PTX virtual architecture version for\n   which the kernel was compiled. This value is the major PTX version * 10\n   + the minor PTX version, so a PTX version 1.3 function would return the\n   value 13. Note that this may return the undefined value of 0 for cubins\n   compiled prior to CUDA 3.0.\n - [CU_FUNC_ATTRIBUTE_BINARY_VERSION](crate::ffi::CU_FUNC_ATTRIBUTE_BINARY_VERSION): The binary architecture version for\n   which the kernel was compiled. This value is the major binary\n   version * 10 + the minor binary version, so a binary version 1.3 function\n   would return the value 13. Note that this will return a value of 10 for\n   legacy cubins that do not have a properly-encoded binary architecture\n   version.\n - [CU_FUNC_CACHE_MODE_CA](crate::ffi::CU_FUNC_CACHE_MODE_CA): The attribute to indicate whether the kernel has\n   been compiled with user specified option \"-Xptxas --dlcm=ca\" set.\n - [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES): The maximum size in bytes of\n   dynamically-allocated shared memory.\n - [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](crate::ffi::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT): Preferred shared memory-L1\n   cache split ratio in percent of total shared memory.\n - [CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET](crate::ffi::CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET): If this attribute is set, the\n   kernel must launch with a valid cluster size specified.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH): The required cluster width in\n   blocks.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT): The required cluster height in\n   blocks.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH): The required cluster depth in\n   blocks.\n - [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](crate::ffi::CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED): Indicates whether\n   the function can be launched with non-portable cluster size. 1 is allowed,\n   0 is disallowed. A non-portable cluster size may only function on the\n   specific SKUs the program is tested on. The launch might fail if the\n   program is run on a different hardware platform. CUDA API provides\n   cudaOccupancyMaxActiveClusters to assist with checking whether the desired\n   size can be launched on the current device. A portable cluster size is\n   guaranteed to be functional on all compute capabilities higher than the\n   target compute capability. The portable cluster size for sm_90 is 8 blocks\n   per cluster. This value may increase for future compute capabilities. The\n   specific hardware unit may support higher cluster sizes thats not\n   guaranteed to be portable.\n - [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](crate::ffi::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE): The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n\n### Note:\n ### Note:\nIf another thread is trying to set the same attribute on the same device using\n [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)() simultaneously, the attribute query will give the old or new\n value depending on the interleavings chosen by the OS scheduler and memory consistency.\n#### pi:\n- Returned attribute value\n#### attrib:\n- Attribute requested\n#### kernel:\n- Kernel to query attribute of\n#### dev:\n- Device to query attribute of\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cuKernelGetFunction](crate::ffi::cuKernelGetFunction),\n [cuLibraryGetModule](crate::ffi::cuLibraryGetModule),\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute)\n"]
    pub fn cuKernelGetAttribute(
        pi: *mut ::std::ffi::c_int,
        attrib: CUfunction_attribute,
        kernel: CUkernel,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets information about a kernel\n\n This call sets the value of a specified attribute `attrib` on the kernel `kernel`\n for the requested device `dev` to an integer value specified by `val`.\n This function returns CUDA_SUCCESS if the new value of the attribute could be\n successfully set. If the set fails, this call will return an error.\n Not all attributes can have values set. Attempting to set a value on a read-only\n attribute will result in an error (CUDA_ERROR_INVALID_VALUE)\n\n Note that attributes set using [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute)() will override the attribute\n set by this API irrespective of whether the call to [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute)() is made\n before or after this API call. However, [cuKernelGetAttribute](crate::ffi::cuKernelGetAttribute)() will always\n return the attribute value set by this API.\n\n Supported attributes are:\n - [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES): This is the maximum size in bytes of\n   dynamically-allocated shared memory. The value should contain the requested\n   maximum size of dynamically-allocated shared memory. The sum of this value and\n   the function attribute [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES) cannot exceed the\n   device attribute [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN).\n   The maximal size of requestable dynamic shared memory may differ by GPU\n   architecture.\n - [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](crate::ffi::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT): On devices where the L1\n   cache and shared memory use the same hardware resources, this sets the shared memory\n   carveout preference, in percent of the total shared memory.\n   See [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR)\n   This is only a hint, and the driver can choose a different ratio if required to execute the function.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH): The required cluster width in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT): The required cluster height in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH): The required cluster depth in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](crate::ffi::CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED): Indicates whether\n   the function can be launched with non-portable cluster size. 1 is allowed,\n   0 is disallowed.\n - [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](crate::ffi::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE): The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n\n### Note:\n ### Note:\nThe API has stricter locking requirements in comparison to its legacy counterpart\n [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute)() due to device-wide semantics. If multiple threads are trying to\n set the same attribute on the same device simultaneously, the attribute setting will depend\n on the interleavings chosen by the OS scheduler and memory consistency.\n#### attrib:\n- Attribute requested\n#### val:\n- Value to set\n#### kernel:\n- Kernel to set attribute of\n#### dev:\n- Device to set attribute of\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuKernelGetAttribute](crate::ffi::cuKernelGetAttribute),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cuKernelGetFunction](crate::ffi::cuKernelGetFunction),\n [cuLibraryGetModule](crate::ffi::cuLibraryGetModule),\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute)\n"]
    pub fn cuKernelSetAttribute(
        attrib: CUfunction_attribute,
        val: ::std::ffi::c_int,
        kernel: CUkernel,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the preferred cache configuration for a device kernel.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through `config` the preferred cache configuration for\n the device kernel `kernel` on the requested device `dev`. This is only a preference.\n The driver will use the requested configuration if possible, but it is free to choose a different\n configuration if required to execute `kernel`.  Any context-wide preference\n set via [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig)() will be overridden by this per-kernel\n setting.\n\n Note that attributes set using [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig)() will override the attribute\n set by this API irrespective of whether the call to [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig)() is made\n before or after this API call.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n\n The supported cache configurations are:\n - [CU_FUNC_CACHE_PREFER_NONE](crate::ffi::CU_FUNC_CACHE_PREFER_NONE): no preference for shared memory or L1 (default)\n - [CU_FUNC_CACHE_PREFER_SHARED](crate::ffi::CU_FUNC_CACHE_PREFER_SHARED): prefer larger shared memory and smaller L1 cache\n - [CU_FUNC_CACHE_PREFER_L1](crate::ffi::CU_FUNC_CACHE_PREFER_L1): prefer larger L1 cache and smaller shared memory\n - [CU_FUNC_CACHE_PREFER_EQUAL](crate::ffi::CU_FUNC_CACHE_PREFER_EQUAL): prefer equal sized L1 cache and shared memory\n\n### Note:\n ### Note:\nThe API has stricter locking requirements in comparison to its legacy counterpart\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig)() due to device-wide semantics. If multiple threads are trying to\n set a config on the same device simultaneously, the cache config setting will depend\n on the interleavings chosen by the OS scheduler and memory consistency.\n#### kernel:\n- Kernel to configure cache for\n#### config:\n- Requested cache configuration\n#### dev:\n- Device to set attribute of\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuLibraryLoadData](crate::ffi::cuLibraryLoadData),\n [cuLibraryLoadFromFile](crate::ffi::cuLibraryLoadFromFile),\n [cuLibraryUnload](crate::ffi::cuLibraryUnload),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel),\n [cuKernelGetFunction](crate::ffi::cuKernelGetFunction),\n [cuLibraryGetModule](crate::ffi::cuLibraryGetModule),\n [cuModuleGetFunction](crate::ffi::cuModuleGetFunction),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuKernelSetCacheConfig(
        kernel: CUkernel,
        config: CUfunc_cache,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the function name for a [CUkernel](crate::ffi::CUkernel) handle\n\n Returns in `*`*name the function name associated with the kernel handle `hfunc` .\n The function name is returned as a null-terminated string. The returned name is only\n valid when the kernel handle is valid. If the library is unloaded or reloaded, one\n must call the API again to get the updated name. This API may return a mangled name if\n the function is not declared as having C linkage. If either `*`*name or `hfunc`\n is NULL, [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n#### name:\n- The returned name of the function\n#### hfunc:\n- The function handle to retrieve the name for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n"]
    pub fn cuKernelGetName(name: *mut *const ::std::ffi::c_char, hfunc: CUkernel) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the offset and size of a kernel parameter in the device-side parameter layout\n\n Queries the kernel parameter at `paramIndex` into `kernel`'s list of parameters, and returns\n in `paramOffset` and `paramSize` the offset and size, respectively, where the parameter\n will reside in the device-side parameter layout. This information can be used to update kernel\n node parameters from the device via [cudaGraphKernelNodeSetParam](crate::ffi::cudaGraphKernelNodeSetParam)() and\n [cudaGraphKernelNodeUpdatesApply](crate::ffi::cudaGraphKernelNodeUpdatesApply)(). `paramIndex` must be less than the number of parameters\n that `kernel` takes. `paramSize` can be set to NULL if only the parameter offset is desired.\n#### kernel:\n- The kernel to query\n#### paramIndex:\n- The parameter index to query\n#### paramOffset:\n- Returns the offset into the device-side parameter layout at which the parameter resides\n#### paramSize:\n- Optionally returns the size of the parameter in the device-side parameter layout\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncGetParamInfo](crate::ffi::cuFuncGetParamInfo)\n"]
    pub fn cuKernelGetParamInfo(
        kernel: CUkernel,
        paramIndex: usize,
        paramOffset: *mut usize,
        paramSize: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets free and total memory\n\n Returns in `*total` the total amount of memory available to the the current context.\n Returns in `*free` the amount of memory on the device that is free according to the OS.\n CUDA is not guaranteed to be able to allocate all of the memory that the OS reports as free.\n In a multi-tenet situation, free estimate returned is prone to race condition where\n a new allocation/free done by a different process or a different thread in the same\n process between the time when free memory was estimated and reported, will result in\n deviation in free value reported and actual free memory.\n\n The integrated GPU on Tegra shares memory with CPU and other component\n of the SoC. The free and total values returned by the API excludes\n the SWAP memory space maintained by the OS on some platforms.\n The OS may move some of the memory pages into swap area as the GPU or\n CPU allocate or access memory. See Tegra app note on how to calculate\n total and free memory on Tegra.\n#### free:\n- Returned free memory in bytes\n#### total:\n- Returned total memory in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemGetInfo](crate::ffi::cudaMemGetInfo)\n"]
    pub fn cuMemGetInfo_v2(free: *mut usize, total: *mut usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocates device memory\n\n Allocates `bytesize` bytes of linear memory on the device and returns in\n `*dptr` a pointer to the allocated memory. The allocated memory is suitably\n aligned for any kind of variable. The memory is not cleared. If `bytesize`\n is 0, [cuMemAlloc](crate::ffi::cuMemAlloc)() returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n#### dptr:\n- Returned device pointer\n#### bytesize:\n- Requested allocation size in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMalloc](crate::ffi::cudaMalloc)\n"]
    pub fn cuMemAlloc_v2(dptr: *mut CUdeviceptr, bytesize: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocates pitched device memory\n\n Allocates at least `WidthInBytes` * `Height` bytes of linear memory on\n the device and returns in `*dptr` a pointer to the allocated memory. The\n function may pad the allocation to ensure that corresponding pointers in\n any given row will continue to meet the alignment requirements for\n coalescing as the address is updated from row to row. `ElementSizeBytes`\n specifies the size of the largest reads and writes that will be performed\n on the memory range. `ElementSizeBytes` may be 4, 8 or 16 (since coalesced\n memory transactions are not possible on other data sizes). If\n `ElementSizeBytes` is smaller than the actual read/write size of a kernel,\n the kernel will run correctly, but possibly at reduced speed. The pitch\n returned in `*pPitch` by [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)() is the width in bytes of the\n allocation. The intended usage of pitch is as a separate parameter of the\n allocation, used to compute addresses within the 2D array. Given the row\n and column of an array element of type \\b T, the address is computed as:\n \\code\nT* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;\n \\endcode\n\n The pitch returned by [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)() is guaranteed to work with\n [cuMemcpy2D](crate::ffi::cuMemcpy2D)() under all circumstances. For allocations of 2D arrays, it is\n recommended that programmers consider performing pitch allocations using\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)(). Due to alignment restrictions in the hardware, this is\n especially true if the application will be performing 2D memory copies\n between different regions of device memory (whether linear memory or CUDA\n arrays).\n\n The byte alignment of the pitch returned by [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)() is guaranteed\n to match or exceed the alignment requirement for texture binding with\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D)().\n#### dptr:\n- Returned device pointer\n#### pPitch:\n- Returned pitch of allocation in bytes\n#### WidthInBytes:\n- Requested allocation width in bytes\n#### Height:\n- Requested allocation height in rows\n#### ElementSizeBytes:\n- Size of largest reads/writes for range\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMallocPitch](crate::ffi::cudaMallocPitch)\n"]
    pub fn cuMemAllocPitch_v2(
        dptr: *mut CUdeviceptr,
        pPitch: *mut usize,
        WidthInBytes: usize,
        Height: usize,
        ElementSizeBytes: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Frees device memory\n\n Frees the memory space pointed to by `dptr`, which must have been returned\n by a previous call to one of the following memory allocation APIs - [cuMemAlloc](crate::ffi::cuMemAlloc)(),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)(), [cuMemAllocManaged](crate::ffi::cuMemAllocManaged)(), [cuMemAllocAsync](crate::ffi::cuMemAllocAsync)(), [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync)()\n\n Note - This API will not perform any implict synchronization when the pointer was allocated with\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) or [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync). Callers must ensure that all accesses to these\n pointer have completed before invoking [cuMemFree](crate::ffi::cuMemFree). For best performance and memory reuse, users\n should use [cuMemFreeAsync](crate::ffi::cuMemFreeAsync) to free memory allocated via the stream ordered memory allocator.\n For all other pointers, this API may perform implicit synchronization.\n#### dptr:\n- Pointer to memory to free\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemAllocManaged](crate::ffi::cuMemAllocManaged), [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync),\n [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned), [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync),\n [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD), [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA),\n [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync), [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA),\n [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync), [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaFree](crate::ffi::cudaFree)\n"]
    pub fn cuMemFree_v2(dptr: CUdeviceptr) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get information on memory allocations\n\n Returns the base address in `*pbase` and size in `*psize` of the\n allocation by [cuMemAlloc](crate::ffi::cuMemAlloc)() or [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)() that contains the input\n pointer `dptr`. Both parameters `pbase` and `psize` are optional. If one\n of them is NULL, it is ignored.\n#### pbase:\n- Returned base address\n#### psize:\n- Returned size of device memory allocation\n#### dptr:\n- Device pointer to query\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32)\n"]
    pub fn cuMemGetAddressRange_v2(
        pbase: *mut CUdeviceptr,
        psize: *mut usize,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocates page-locked host memory\n\n Allocates `bytesize` bytes of host memory that is page-locked and\n accessible to the device. The driver tracks the virtual memory ranges\n allocated with this function and automatically accelerates calls to\n functions such as [cuMemcpy](crate::ffi::cuMemcpy)(). Since the memory can be accessed directly by\n the device, it can be read or written with much higher bandwidth than\n pageable memory obtained with functions such as [malloc](crate::ffi::malloc)().\n\n On systems where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES)\n is true, [cuMemAllocHost](crate::ffi::cuMemAllocHost) may not page-lock the allocated memory.\n\n Page-locking excessive amounts of memory with [cuMemAllocHost](crate::ffi::cuMemAllocHost)() may degrade system\n performance, since it reduces the amount of memory available to the system\n for paging. As a result, this function is best used sparingly to allocate\n staging areas for data exchange between host and device.\n\n Note all host memory allocated using [cuMemAllocHost](crate::ffi::cuMemAllocHost)() will automatically\n be immediately accessible to all contexts on all devices which support unified\n addressing (as may be queried using [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](crate::ffi::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING)).\n The device pointer that may be used to access this host memory from those\n contexts is always equal to the returned host pointer `*pp`.\n See \\ref CUDA_UNIFIED for additional details.\n#### pp:\n- Returned pointer to host memory\n#### bytesize:\n- Requested allocation size in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMallocHost](crate::ffi::cudaMallocHost)\n"]
    pub fn cuMemAllocHost_v2(pp: *mut *mut ::std::ffi::c_void, bytesize: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Frees page-locked host memory\n\n Frees the memory space pointed to by `p`, which must have been returned by\n a previous call to [cuMemAllocHost](crate::ffi::cuMemAllocHost)().\n#### p:\n- Pointer to memory to free\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaFreeHost](crate::ffi::cudaFreeHost)\n"]
    pub fn cuMemFreeHost(p: *mut ::std::ffi::c_void) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocates page-locked host memory\n\n Allocates `bytesize` bytes of host memory that is page-locked and accessible\n to the device. The driver tracks the virtual memory ranges allocated with\n this function and automatically accelerates calls to functions such as\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD)(). Since the memory can be accessed directly by the device,\n it can be read or written with much higher bandwidth than pageable memory\n obtained with functions such as [malloc](crate::ffi::malloc)().\n\n On systems where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES)\n is true, [cuMemHostAlloc](crate::ffi::cuMemHostAlloc) may not page-lock the allocated memory.\n\n Page-locking excessive amounts of memory may degrade system performance,\n since it reduces the amount of memory available to the system for paging.\n As a result, this function is best used sparingly to allocate staging areas\n for data exchange between host and device.\n\n The `Flags` parameter enables different options to be specified that\n affect the allocation, as follows.\n\n - [CU_MEMHOSTALLOC_PORTABLE](crate::ffi::CU_MEMHOSTALLOC_PORTABLE): The memory returned by this call will be\n   considered as pinned memory by all CUDA contexts, not just the one that\n   performed the allocation.\n\n - [CU_MEMHOSTALLOC_DEVICEMAP](crate::ffi::CU_MEMHOSTALLOC_DEVICEMAP): Maps the allocation into the CUDA address\n   space. The device pointer to the memory may be obtained by calling\n   [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)().\n\n - [CU_MEMHOSTALLOC_WRITECOMBINED](crate::ffi::CU_MEMHOSTALLOC_WRITECOMBINED): Allocates the memory as write-combined\n   (WC). WC memory can be transferred across the PCI Express bus more\n   quickly on some system configurations, but cannot be read efficiently by\n   most CPUs. WC memory is a good option for buffers that will be written by\n   the CPU and read by the GPU via mapped pinned memory or host->device\n   transfers.\n\n All of these flags are orthogonal to one another: a developer may allocate\n memory that is portable, mapped and/or write-combined with no restrictions.\n\n The [CU_MEMHOSTALLOC_DEVICEMAP](crate::ffi::CU_MEMHOSTALLOC_DEVICEMAP) flag may be specified on CUDA contexts for\n devices that do not support mapped pinned memory. The failure is deferred\n to [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() because the memory may be mapped into\n other CUDA contexts via the [CU_MEMHOSTALLOC_PORTABLE](crate::ffi::CU_MEMHOSTALLOC_PORTABLE) flag.\n\n The memory allocated by this function must be freed with [cuMemFreeHost](crate::ffi::cuMemFreeHost)().\n\n Note all host memory allocated using [cuMemHostAlloc](crate::ffi::cuMemHostAlloc)() will automatically\n be immediately accessible to all contexts on all devices which support unified\n addressing (as may be queried using [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](crate::ffi::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING)).\n Unless the flag [CU_MEMHOSTALLOC_WRITECOMBINED](crate::ffi::CU_MEMHOSTALLOC_WRITECOMBINED) is specified, the device pointer\n that may be used to access this host memory from those contexts is always equal\n to the returned host pointer `*pp`.  If the flag [CU_MEMHOSTALLOC_WRITECOMBINED](crate::ffi::CU_MEMHOSTALLOC_WRITECOMBINED)\n is specified, then the function [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() must be used\n to query the device pointer, even if the context supports unified addressing.\n See \\ref CUDA_UNIFIED for additional details.\n#### pp:\n- Returned pointer to host memory\n#### bytesize:\n- Requested allocation size in bytes\n#### Flags:\n- Flags for allocation request\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaHostAlloc](crate::ffi::cudaHostAlloc)\n"]
    pub fn cuMemHostAlloc(
        pp: *mut *mut ::std::ffi::c_void,
        bytesize: usize,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Passes back device pointer of mapped pinned memory\n\n Passes back the device pointer `pdptr` corresponding to the mapped, pinned\n host buffer `p` allocated by [cuMemHostAlloc](crate::ffi::cuMemHostAlloc).\n\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() will fail if the [CU_MEMHOSTALLOC_DEVICEMAP](crate::ffi::CU_MEMHOSTALLOC_DEVICEMAP)\n flag was not specified at the time the memory was allocated, or if the\n function is called on a GPU that does not support mapped pinned memory.\n\n For devices that have a non-zero value for the device attribute\n [CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM), the memory\n can also be accessed from the device using the host pointer `p`.\n The device pointer returned by [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() may or may not\n match the original host pointer `p` and depends on the devices visible to the\n application. If all devices visible to the application have a non-zero value for the\n device attribute, the device pointer returned by [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)()\n will match the original pointer `p`. If any device visible to the application\n has a zero value for the device attribute, the device pointer returned by\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() will not match the original host pointer `p`,\n but it will be suitable for use on all devices provided Unified Virtual Addressing\n is enabled. In such systems, it is valid to access the memory using either pointer\n on devices that have a non-zero value for the device attribute. Note however that\n such devices should access the memory using only one of the two pointers and not both.\n\n `Flags` provides for future releases. For now, it must be set to 0.\n#### pdptr:\n- Returned device pointer\n#### p:\n- Host pointer\n#### Flags:\n- Options (must be 0)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaHostGetDevicePointer](crate::ffi::cudaHostGetDevicePointer)\n"]
    pub fn cuMemHostGetDevicePointer_v2(
        pdptr: *mut CUdeviceptr,
        p: *mut ::std::ffi::c_void,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Passes back flags that were used for a pinned allocation\n\n Passes back the flags `pFlags` that were specified when allocating\n the pinned host buffer `p` allocated by [cuMemHostAlloc](crate::ffi::cuMemHostAlloc).\n\n [cuMemHostGetFlags](crate::ffi::cuMemHostGetFlags)() will fail if the pointer does not reside in\n an allocation performed by [cuMemAllocHost](crate::ffi::cuMemAllocHost)() or [cuMemHostAlloc](crate::ffi::cuMemHostAlloc)().\n#### pFlags:\n- Returned flags word\n#### p:\n- Host pointer\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cudaHostGetFlags](crate::ffi::cudaHostGetFlags)\n"]
    pub fn cuMemHostGetFlags(
        pFlags: *mut ::std::ffi::c_uint,
        p: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocates memory that will be automatically managed by the Unified Memory system\n\n Allocates `bytesize` bytes of managed memory on the device and returns in\n `*dptr` a pointer to the allocated memory. If the device doesn't support\n allocating managed memory, [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED) is returned. Support\n for managed memory can be queried using the device attribute\n [CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY](crate::ffi::CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY). The allocated memory is suitably\n aligned for any kind of variable. The memory is not cleared. If `bytesize`\n is 0, [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE). The pointer\n is valid on the CPU and on all GPUs in the system that support managed memory.\n All accesses to this pointer must obey the Unified Memory programming model.\n\n `flags` specifies the default stream association for this allocation.\n `flags` must be one of [CU_MEM_ATTACH_GLOBAL](crate::ffi::CU_MEM_ATTACH_GLOBAL) or [CU_MEM_ATTACH_HOST](crate::ffi::CU_MEM_ATTACH_HOST). If\n [CU_MEM_ATTACH_GLOBAL](crate::ffi::CU_MEM_ATTACH_GLOBAL) is specified, then this memory is accessible from\n any stream on any device. If [CU_MEM_ATTACH_HOST](crate::ffi::CU_MEM_ATTACH_HOST) is specified, then the\n allocation should not be accessed from devices that have a zero value for the\n device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS); an explicit call to\n [cuStreamAttachMemAsync](crate::ffi::cuStreamAttachMemAsync) will be required to enable access on such devices.\n\n If the association is later changed via [cuStreamAttachMemAsync](crate::ffi::cuStreamAttachMemAsync) to\n a single stream, the default association as specified during [cuMemAllocManaged](crate::ffi::cuMemAllocManaged)\n is restored when that stream is destroyed. For __managed__ variables, the\n default association is always [CU_MEM_ATTACH_GLOBAL](crate::ffi::CU_MEM_ATTACH_GLOBAL). Note that destroying a\n stream is an asynchronous operation, and as a result, the change to default\n association won't happen until all work in the stream has completed.\n\n Memory allocated with [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) should be released with [cuMemFree](crate::ffi::cuMemFree).\n\n Device memory oversubscription is possible for GPUs that have a non-zero value for the\n device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS). Managed memory on\n such GPUs may be evicted from device memory to host memory at any time by the Unified\n Memory driver in order to make room for other allocations.\n\n In a system where all GPUs have a non-zero value for the device attribute\n [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS), managed memory may not be populated when this\n API returns and instead may be populated on access. In such systems, managed memory can\n migrate to any processor's memory at any time. The Unified Memory driver will employ heuristics to\n maintain data locality and prevent excessive page faults to the extent possible. The application\n can also guide the driver about memory usage patterns via [cuMemAdvise](crate::ffi::cuMemAdvise). The application\n can also explicitly migrate memory to a desired processor's memory via\n [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync).\n\n In a multi-GPU system where all of the GPUs have a zero value for the device attribute\n [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS) and all the GPUs have peer-to-peer support\n with each other, the physical storage for managed memory is created on the GPU which is active\n at the time [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) is called. All other GPUs will reference the data at reduced\n bandwidth via peer mappings over the PCIe bus. The Unified Memory driver does not migrate\n memory among such GPUs.\n\n In a multi-GPU system where not all GPUs have peer-to-peer support with each other and\n where the value of the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS)\n is zero for at least one of those GPUs, the location chosen for physical storage of managed\n memory is system-dependent.\n - On Linux, the location chosen will be device memory as long as the current set of active\n contexts are on devices that either have peer-to-peer support with each other or have a\n non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS).\n If there is an active context on a GPU that does not have a non-zero value for that device\n attribute and it does not have peer-to-peer support with the other devices that have active\n contexts on them, then the location for physical storage will be 'zero-copy' or host memory.\n Note that this means that managed memory that is located in device memory is migrated to\n host memory if a new context is created on a GPU that doesn't have a non-zero value for\n the device attribute and does not support peer-to-peer with at least one of the other devices\n that has an active context. This in turn implies that context creation may fail if there is\n insufficient host memory to migrate all managed allocations.\n - On Windows, the physical storage is always created in 'zero-copy' or host memory.\n All GPUs will reference the data at reduced bandwidth over the PCIe bus. In these\n circumstances, use of the environment variable CUDA_VISIBLE_DEVICES is recommended to\n restrict CUDA to only use those GPUs that have peer-to-peer support.\n Alternatively, users can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a\n non-zero value to force the driver to always use device memory for physical storage.\n When this environment variable is set to a non-zero value, all contexts created in\n that process on devices that support managed memory have to be peer-to-peer compatible\n with each other. Context creation will fail if a context is created on a device that\n supports managed memory and is not peer-to-peer compatible with any of the other\n managed memory supporting devices on which contexts were previously created, even if\n those contexts have been destroyed. These environment variables are described\n in the CUDA programming guide under the \"CUDA environment variables\" section.\n - On ARM, managed memory is not available on discrete gpu with Drive PX-2.\n#### dptr:\n- Returned device pointer\n#### bytesize:\n- Requested allocation size in bytes\n#### flags:\n- Must be one of [CU_MEM_ATTACH_GLOBAL](crate::ffi::CU_MEM_ATTACH_GLOBAL) or [CU_MEM_ATTACH_HOST](crate::ffi::CU_MEM_ATTACH_HOST)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute), [cuStreamAttachMemAsync](crate::ffi::cuStreamAttachMemAsync),\n [cudaMallocManaged](crate::ffi::cudaMallocManaged)\n"]
    pub fn cuMemAllocManaged(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Registers a callback function to receive async notifications\n\n Registers `callbackFunc` to receive async notifications.\n\n The `userData` parameter is passed to the callback function at async notification time.\n Likewise, `callback` is also passed to the callback function to distinguish between\n multiple registered callbacks.\n\n The callback function being registered should be designed to return quickly (~10ms).\n Any long running tasks should be queued for execution on an application thread.\n\n Callbacks may not call cuDeviceRegisterAsyncNotification or cuDeviceUnregisterAsyncNotification.\n Doing so will result in [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED). Async notification callbacks execute\n in an undefined order and may be serialized.\n\n Returns in `*callback` a handle representing the registered callback instance.\n#### device:\n- The device on which to register the callback\n#### callbackFunc:\n- The function to register as a callback\n#### userData:\n- A generic pointer to user data. This is passed into the callback function.\n#### callback:\n- A handle representing the registered callback instance\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED)\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceUnregisterAsyncNotification](crate::ffi::cuDeviceUnregisterAsyncNotification)\n"]
    pub fn cuDeviceRegisterAsyncNotification(
        device: CUdevice,
        callbackFunc: CUasyncCallback,
        userData: *mut ::std::ffi::c_void,
        callback: *mut CUasyncCallbackHandle,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unregisters an async notification callback\n\n Unregisters `callback` so that the corresponding callback function will stop receiving\n async notifications.\n#### device:\n- The device from which to remove `callback`.\n#### callback:\n- The callback instance to unregister from receiving async notifications.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED)\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceRegisterAsyncNotification](crate::ffi::cuDeviceRegisterAsyncNotification)\n"]
    pub fn cuDeviceUnregisterAsyncNotification(
        device: CUdevice,
        callback: CUasyncCallbackHandle,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a handle to a compute device\n\n Returns in `*device` a device handle given a PCI bus ID string.\n#### dev:\n- Returned device handle\n#### pciBusId:\n- String in one of the following forms:\n [domain]:[bus]:[device].[function]\n [domain]:[bus]:[device]\n [bus]:[device].[function]\n where `domain`, `bus`, `device`, and `function` are all hexadecimal values\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetPCIBusId](crate::ffi::cuDeviceGetPCIBusId),\n [cudaDeviceGetByPCIBusId](crate::ffi::cudaDeviceGetByPCIBusId)\n"]
    pub fn cuDeviceGetByPCIBusId(
        dev: *mut CUdevice,
        pciBusId: *const ::std::ffi::c_char,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a PCI Bus Id string for the device\n\n Returns an ASCII string identifying the device `dev` in the NULL-terminated\n string pointed to by `pciBusId`. `len` specifies the maximum length of the\n string that may be returned.\n#### pciBusId:\n- Returned identifier string for the device in the following format\n [domain]:[bus]:[device].[function]\n where `domain`, `bus`, `device`, and `function` are all hexadecimal values.\n pciBusId should be large enough to store 13 characters including the NULL-terminator.\n#### len:\n- Maximum length of string to store in `name`\n#### dev:\n- Device to get identifier string for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceGet](crate::ffi::cuDeviceGet),\n [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute),\n [cuDeviceGetByPCIBusId](crate::ffi::cuDeviceGetByPCIBusId),\n [cudaDeviceGetPCIBusId](crate::ffi::cudaDeviceGetPCIBusId)\n"]
    pub fn cuDeviceGetPCIBusId(
        pciBusId: *mut ::std::ffi::c_char,
        len: ::std::ffi::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets an interprocess handle for a previously allocated event\n\n Takes as input a previously allocated event. This event must have been\n created with the [CU_EVENT_INTERPROCESS](crate::ffi::CU_EVENT_INTERPROCESS) and [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING)\n flags set. This opaque handle may be copied into other processes and\n opened with [cuIpcOpenEventHandle](crate::ffi::cuIpcOpenEventHandle) to allow efficient hardware\n synchronization between GPU work in different processes.\n\n After the event has been opened in the importing process,\n [cuEventRecord](crate::ffi::cuEventRecord), [cuEventSynchronize](crate::ffi::cuEventSynchronize), [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent) and\n [cuEventQuery](crate::ffi::cuEventQuery) may be used in either process. Performing operations\n on the imported event after the exported event has been freed\n with [cuEventDestroy](crate::ffi::cuEventDestroy) will result in undefined behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is supported for compatibility purposes\n but not recommended as it comes with performance cost.\n Users can test their device for IPC functionality by calling\n [cuapiDeviceGetAttribute](crate::ffi::cuapiDeviceGetAttribute) with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED)\n#### pHandle:\n- Pointer to a user allocated CUipcEventHandle\n                    in which to return the opaque event handle\n#### event:\n- Event allocated with [CU_EVENT_INTERPROCESS](crate::ffi::CU_EVENT_INTERPROCESS) and\n                    [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING) flags.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_MAP_FAILED](crate::ffi::CUDA_ERROR_MAP_FAILED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuIpcOpenEventHandle](crate::ffi::cuIpcOpenEventHandle),\n [cuIpcGetMemHandle](crate::ffi::cuIpcGetMemHandle),\n [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle),\n [cuIpcCloseMemHandle](crate::ffi::cuIpcCloseMemHandle),\n [cudaIpcGetEventHandle](crate::ffi::cudaIpcGetEventHandle)\n"]
    pub fn cuIpcGetEventHandle(pHandle: *mut CUipcEventHandle, event: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Opens an interprocess event handle for use in the current process\n\n Opens an interprocess event handle exported from another process with\n [cuIpcGetEventHandle](crate::ffi::cuIpcGetEventHandle). This function returns a [CUevent](crate::ffi::CUevent) that behaves like\n a locally created event with the [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING) flag specified.\n This event must be freed with [cuEventDestroy](crate::ffi::cuEventDestroy).\n\n Performing operations on the imported event after the exported event has\n been freed with [cuEventDestroy](crate::ffi::cuEventDestroy) will result in undefined behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is supported for compatibility purposes\n but not recommended as it comes with performance cost.\n Users can test their device for IPC functionality by calling\n [cuapiDeviceGetAttribute](crate::ffi::cuapiDeviceGetAttribute) with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED)\n#### phEvent:\n- Returns the imported event\n#### handle:\n- Interprocess handle to open\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_MAP_FAILED](crate::ffi::CUDA_ERROR_MAP_FAILED),\n [CUDA_ERROR_PEER_ACCESS_UNSUPPORTED](crate::ffi::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuIpcGetEventHandle](crate::ffi::cuIpcGetEventHandle),\n [cuIpcGetMemHandle](crate::ffi::cuIpcGetMemHandle),\n [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle),\n [cuIpcCloseMemHandle](crate::ffi::cuIpcCloseMemHandle),\n [cudaIpcOpenEventHandle](crate::ffi::cudaIpcOpenEventHandle)\n"]
    pub fn cuIpcOpenEventHandle(phEvent: *mut CUevent, handle: CUipcEventHandle) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets an interprocess memory handle for an existing device memory\n allocation\n\n Takes a pointer to the base of an existing device memory allocation created\n with [cuMemAlloc](crate::ffi::cuMemAlloc) and exports it for use in another process. This is a\n lightweight operation and may be called multiple times on an allocation\n without adverse effects.\n\n If a region of memory is freed with [cuMemFree](crate::ffi::cuMemFree) and a subsequent call\n to [cuMemAlloc](crate::ffi::cuMemAlloc) returns memory with the same device address,\n [cuIpcGetMemHandle](crate::ffi::cuIpcGetMemHandle) will return a unique handle for the\n new memory.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is supported for compatibility purposes\n but not recommended as it comes with performance cost.\n Users can test their device for IPC functionality by calling\n [cuapiDeviceGetAttribute](crate::ffi::cuapiDeviceGetAttribute) with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED)\n#### pHandle:\n- Pointer to user allocated [CUipcMemHandle](crate::ffi::CUipcMemHandle) to return\n                    the handle in.\n#### dptr:\n- Base pointer to previously allocated device memory\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_MAP_FAILED](crate::ffi::CUDA_ERROR_MAP_FAILED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuMemAlloc](crate::ffi::cuMemAlloc),\n [cuMemFree](crate::ffi::cuMemFree),\n [cuIpcGetEventHandle](crate::ffi::cuIpcGetEventHandle),\n [cuIpcOpenEventHandle](crate::ffi::cuIpcOpenEventHandle),\n [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle),\n [cuIpcCloseMemHandle](crate::ffi::cuIpcCloseMemHandle),\n [cudaIpcGetMemHandle](crate::ffi::cudaIpcGetMemHandle)\n"]
    pub fn cuIpcGetMemHandle(pHandle: *mut CUipcMemHandle, dptr: CUdeviceptr) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Opens an interprocess memory handle exported from another process\n and returns a device pointer usable in the local process.\n\n Maps memory exported from another process with [cuIpcGetMemHandle](crate::ffi::cuIpcGetMemHandle) into\n the current device address space. For contexts on different devices\n [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle) can attempt to enable peer access between the\n devices as if the user called [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess). This behavior is\n controlled by the [CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS](crate::ffi::CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS) flag.\n [cuDeviceCanAccessPeer](crate::ffi::cuDeviceCanAccessPeer) can determine if a mapping is possible.\n\n Contexts that may open [CUipcMemHandles](crate::ffi::CUipcMemHandles) are restricted in the following way.\n [CUipcMemHandles](crate::ffi::CUipcMemHandles) from each [CUdevice](crate::ffi::CUdevice) in a given process may only be opened\n by one [CUcontext](crate::ffi::CUcontext) per [CUdevice](crate::ffi::CUdevice) per other process.\n\n If the memory handle has already been opened by the current context, the\n reference count on the handle is incremented by 1 and the existing device pointer\n is returned.\n\n Memory returned from [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle) must be freed with\n [cuIpcCloseMemHandle](crate::ffi::cuIpcCloseMemHandle).\n\n Calling [cuMemFree](crate::ffi::cuMemFree) on an exported memory region before calling\n [cuIpcCloseMemHandle](crate::ffi::cuIpcCloseMemHandle) in the importing context will result in undefined\n behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is supported for compatibility purposes\n but not recommended as it comes with performance cost.\n Users can test their device for IPC functionality by calling\n [cuapiDeviceGetAttribute](crate::ffi::cuapiDeviceGetAttribute) with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED)\n#### pdptr:\n- Returned device pointer\n#### handle:\n- [CUipcMemHandle](crate::ffi::CUipcMemHandle) to open\n#### Flags:\n- Flags for this operation. Must be specified as [CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS](crate::ffi::CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_MAP_FAILED](crate::ffi::CUDA_ERROR_MAP_FAILED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_TOO_MANY_PEERS](crate::ffi::CUDA_ERROR_TOO_MANY_PEERS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n### Note:\n ### Note:\nNo guarantees are made about the address returned in `*pdptr`.\n In particular, multiple processes may not receive the same address for the same `handle`.\n\n ### See also:\n\n [cuMemAlloc](crate::ffi::cuMemAlloc),\n [cuMemFree](crate::ffi::cuMemFree),\n [cuIpcGetEventHandle](crate::ffi::cuIpcGetEventHandle),\n [cuIpcOpenEventHandle](crate::ffi::cuIpcOpenEventHandle),\n [cuIpcGetMemHandle](crate::ffi::cuIpcGetMemHandle),\n [cuIpcCloseMemHandle](crate::ffi::cuIpcCloseMemHandle),\n [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess),\n [cuDeviceCanAccessPeer](crate::ffi::cuDeviceCanAccessPeer),\n [cudaIpcOpenMemHandle](crate::ffi::cudaIpcOpenMemHandle)\n"]
    pub fn cuIpcOpenMemHandle_v2(
        pdptr: *mut CUdeviceptr,
        handle: CUipcMemHandle,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Attempts to close memory mapped with [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle)\n\n Decrements the reference count of the memory returned by [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle) by 1.\n When the reference count reaches 0, this API unmaps the memory. The original allocation\n in the exporting process as well as imported mappings in other processes\n will be unaffected.\n\n Any resources used to enable peer access will be freed if this is the\n last mapping using them.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is supported for compatibility purposes\n but not recommended as it comes with performance cost.\n Users can test their device for IPC functionality by calling\n [cuapiDeviceGetAttribute](crate::ffi::cuapiDeviceGetAttribute) with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED)\n#### dptr:\n- Device pointer returned by [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_MAP_FAILED](crate::ffi::CUDA_ERROR_MAP_FAILED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n ### See also:\n\n [cuMemAlloc](crate::ffi::cuMemAlloc),\n [cuMemFree](crate::ffi::cuMemFree),\n [cuIpcGetEventHandle](crate::ffi::cuIpcGetEventHandle),\n [cuIpcOpenEventHandle](crate::ffi::cuIpcOpenEventHandle),\n [cuIpcGetMemHandle](crate::ffi::cuIpcGetMemHandle),\n [cuIpcOpenMemHandle](crate::ffi::cuIpcOpenMemHandle),\n [cudaIpcCloseMemHandle](crate::ffi::cudaIpcCloseMemHandle)\n"]
    pub fn cuIpcCloseMemHandle(dptr: CUdeviceptr) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Registers an existing host memory range for use by CUDA\n\n Page-locks the memory range specified by `p` and `bytesize` and maps it\n for the device(s) as specified by `Flags`. This memory range also is added\n to the same tracking mechanism as [cuMemHostAlloc](crate::ffi::cuMemHostAlloc) to automatically accelerate\n calls to functions such as [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD)(). Since the memory can be accessed\n directly by the device, it can be read or written with much higher bandwidth\n than pageable memory that has not been registered.  Page-locking excessive\n amounts of memory may degrade system performance, since it reduces the amount\n of memory available to the system for paging. As a result, this function is\n best used sparingly to register staging areas for data exchange between\n host and device.\n\n On systems where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES)\n is true, [cuMemHostRegister](crate::ffi::cuMemHostRegister) will not page-lock the memory range specified\n by `ptr` but only populate unpopulated pages.\n\n The `Flags` parameter enables different options to be specified that\n affect the allocation, as follows.\n\n - [CU_MEMHOSTREGISTER_PORTABLE](crate::ffi::CU_MEMHOSTREGISTER_PORTABLE): The memory returned by this call will be\n   considered as pinned memory by all CUDA contexts, not just the one that\n   performed the allocation.\n\n - [CU_MEMHOSTREGISTER_DEVICEMAP](crate::ffi::CU_MEMHOSTREGISTER_DEVICEMAP): Maps the allocation into the CUDA address\n   space. The device pointer to the memory may be obtained by calling\n   [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)().\n\n - [CU_MEMHOSTREGISTER_IOMEMORY](crate::ffi::CU_MEMHOSTREGISTER_IOMEMORY): The pointer is treated as pointing to some\n   I/O memory space, e.g. the PCI Express resource of a 3rd party device.\n\n - [CU_MEMHOSTREGISTER_READ_ONLY](crate::ffi::CU_MEMHOSTREGISTER_READ_ONLY): The pointer is treated as pointing to memory\n   that is considered read-only by the device.  On platforms without\n   [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES), this flag is\n   required in order to register memory mapped to the CPU as read-only.  Support\n   for the use of this flag can be queried from the device attribute\n   [CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED).  Using this flag with\n   a current context associated with a device that does not have this attribute\n   set will cause [cuMemHostRegister](crate::ffi::cuMemHostRegister) to error with CUDA_ERROR_NOT_SUPPORTED.\n\n All of these flags are orthogonal to one another: a developer may page-lock\n memory that is portable or mapped with no restrictions.\n\n The [CU_MEMHOSTREGISTER_DEVICEMAP](crate::ffi::CU_MEMHOSTREGISTER_DEVICEMAP) flag may be specified on CUDA contexts for\n devices that do not support mapped pinned memory. The failure is deferred\n to [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() because the memory may be mapped into\n other CUDA contexts via the [CU_MEMHOSTREGISTER_PORTABLE](crate::ffi::CU_MEMHOSTREGISTER_PORTABLE) flag.\n\n For devices that have a non-zero value for the device attribute\n [CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM), the memory\n can also be accessed from the device using the host pointer `p`.\n The device pointer returned by [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() may or may not\n match the original host pointer `ptr` and depends on the devices visible to the\n application. If all devices visible to the application have a non-zero value for the\n device attribute, the device pointer returned by [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)()\n will match the original pointer `ptr`. If any device visible to the application\n has a zero value for the device attribute, the device pointer returned by\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)() will not match the original host pointer `ptr`,\n but it will be suitable for use on all devices provided Unified Virtual Addressing\n is enabled. In such systems, it is valid to access the memory using either pointer\n on devices that have a non-zero value for the device attribute. Note however that\n such devices should access the memory using only of the two pointers and not both.\n\n The memory page-locked by this function must be unregistered with\n [cuMemHostUnregister](crate::ffi::cuMemHostUnregister)().\n#### p:\n- Host pointer to memory to page-lock\n#### bytesize:\n- Size in bytes of the address range to page-lock\n#### Flags:\n- Flags for allocation request\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED](crate::ffi::CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMemHostUnregister](crate::ffi::cuMemHostUnregister),\n [cuMemHostGetFlags](crate::ffi::cuMemHostGetFlags),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer),\n [cudaHostRegister](crate::ffi::cudaHostRegister)\n"]
    pub fn cuMemHostRegister_v2(
        p: *mut ::std::ffi::c_void,
        bytesize: usize,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unregisters a memory range that was registered with cuMemHostRegister.\n\n Unmaps the memory range whose base address is specified by `p`, and makes\n it pageable again.\n\n The base address must be the same one specified to [cuMemHostRegister](crate::ffi::cuMemHostRegister)().\n#### p:\n- Host pointer to memory to unregister\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED](crate::ffi::CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMemHostRegister](crate::ffi::cuMemHostRegister),\n [cudaHostUnregister](crate::ffi::cudaHostUnregister)\n"]
    pub fn cuMemHostUnregister(p: *mut ::std::ffi::c_void) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory\n\n Copies data between two pointers.\n `dst` and `src` are base pointers of the destination and source, respectively.\n `ByteCount` specifies the number of bytes to copy.\n Note that this function infers the type of the transfer (host to host, host to\n   device, device to device, or device to host) from the pointer values.  This\n   function is only allowed in contexts which support unified addressing.\n#### dst:\n- Destination unified virtual address space pointer\n#### src:\n- Source unified virtual address space pointer\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpy](crate::ffi::cudaMemcpy),\n [cudaMemcpyToSymbol](crate::ffi::cudaMemcpyToSymbol),\n [cudaMemcpyFromSymbol](crate::ffi::cudaMemcpyFromSymbol)\n"]
    pub fn cuMemcpy(dst: CUdeviceptr, src: CUdeviceptr, ByteCount: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies device memory between two contexts\n\n Copies from device memory in one context to device memory in another\n context. `dstDevice` is the base device pointer of the destination memory\n and `dstContext` is the destination context.  `srcDevice` is the base\n device pointer of the source memory and `srcContext` is the source pointer.\n `ByteCount` specifies the number of bytes to copy.\n#### dstDevice:\n- Destination device pointer\n#### dstContext:\n- Destination context\n#### srcDevice:\n- Source device pointer\n#### srcContext:\n- Source context\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpy3DPeer](crate::ffi::cuMemcpy3DPeer), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync), [cuMemcpyPeerAsync](crate::ffi::cuMemcpyPeerAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync),\n [cudaMemcpyPeer](crate::ffi::cudaMemcpyPeer)\n"]
    pub fn cuMemcpyPeer(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Host to Device\n\n Copies from host memory to device memory. `dstDevice` and `srcHost` are\n the base addresses of the destination and source, respectively. `ByteCount`\n specifies the number of bytes to copy.\n#### dstDevice:\n- Destination device pointer\n#### srcHost:\n- Source host pointer\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpy](crate::ffi::cudaMemcpy),\n [cudaMemcpyToSymbol](crate::ffi::cudaMemcpyToSymbol)\n"]
    pub fn cuMemcpyHtoD_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::ffi::c_void,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Device to Host\n\n Copies from device to host memory. `dstHost` and `srcDevice` specify the\n base pointers of the destination and source, respectively. `ByteCount`\n specifies the number of bytes to copy.\n#### dstHost:\n- Destination host pointer\n#### srcDevice:\n- Source device pointer\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpy](crate::ffi::cudaMemcpy),\n [cudaMemcpyFromSymbol](crate::ffi::cudaMemcpyFromSymbol)\n"]
    pub fn cuMemcpyDtoH_v2(
        dstHost: *mut ::std::ffi::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Device to Device\n\n Copies from device memory to device memory. `dstDevice` and `srcDevice`\n are the base pointers of the destination and source, respectively.\n `ByteCount` specifies the number of bytes to copy.\n#### dstDevice:\n- Destination device pointer\n#### srcDevice:\n- Source device pointer\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpy](crate::ffi::cudaMemcpy),\n [cudaMemcpyToSymbol](crate::ffi::cudaMemcpyToSymbol),\n [cudaMemcpyFromSymbol](crate::ffi::cudaMemcpyFromSymbol)\n"]
    pub fn cuMemcpyDtoD_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Device to Array\n\n Copies from device memory to a 1D CUDA array. `dstArray` and `dstOffset`\n specify the CUDA array handle and starting index of the destination data.\n `srcDevice` specifies the base pointer of the source. `ByteCount`\n specifies the number of bytes to copy.\n#### dstArray:\n- Destination array\n#### dstOffset:\n- Offset in bytes of destination array\n#### srcDevice:\n- Source device pointer\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpyToArray](crate::ffi::cudaMemcpyToArray)\n"]
    pub fn cuMemcpyDtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Array to Device\n\n Copies from one 1D CUDA array to device memory. `dstDevice` specifies the\n base pointer of the destination and must be naturally aligned with the CUDA\n array elements. `srcArray` and `srcOffset` specify the CUDA array handle\n and the offset in bytes into the array where the copy is to begin.\n `ByteCount` specifies the number of bytes to copy and must be evenly\n divisible by the array element size.\n#### dstDevice:\n- Destination device pointer\n#### srcArray:\n- Source array\n#### srcOffset:\n- Offset in bytes of source array\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpyFromArray](crate::ffi::cudaMemcpyFromArray)\n"]
    pub fn cuMemcpyAtoD_v2(
        dstDevice: CUdeviceptr,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Host to Array\n\n Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`\n specify the CUDA array handle and starting offset in bytes of the destination\n data.  `pSrc` specifies the base address of the source. `ByteCount` specifies\n the number of bytes to copy.\n#### dstArray:\n- Destination array\n#### dstOffset:\n- Offset in bytes of destination array\n#### srcHost:\n- Source host pointer\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpyToArray](crate::ffi::cudaMemcpyToArray)\n"]
    pub fn cuMemcpyHtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::std::ffi::c_void,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Array to Host\n\n Copies from one 1D CUDA array to host memory. `dstHost` specifies the base\n pointer of the destination. `srcArray` and `srcOffset` specify the CUDA\n array handle and starting offset in bytes of the source data.\n `ByteCount` specifies the number of bytes to copy.\n#### dstHost:\n- Destination device pointer\n#### srcArray:\n- Source array\n#### srcOffset:\n- Offset in bytes of source array\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpyFromArray](crate::ffi::cudaMemcpyFromArray)\n"]
    pub fn cuMemcpyAtoH_v2(
        dstHost: *mut ::std::ffi::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Array to Array\n\n Copies from one 1D CUDA array to another. `dstArray` and `srcArray`\n specify the handles of the destination and source CUDA arrays for the copy,\n respectively. `dstOffset` and `srcOffset` specify the destination and\n source offsets in bytes into the CUDA arrays. `ByteCount` is the number of\n bytes to be copied. The size of the elements in the CUDA arrays need not be\n the same format, but the elements must be the same size; and count must be\n evenly divisible by that size.\n#### dstArray:\n- Destination array\n#### dstOffset:\n- Offset in bytes of destination array\n#### srcArray:\n- Source array\n#### srcOffset:\n- Offset in bytes of source array\n#### ByteCount:\n- Size of memory copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpyArrayToArray](crate::ffi::cudaMemcpyArrayToArray)\n"]
    pub fn cuMemcpyAtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory for 2D arrays\n\n Perform a 2D memory copy according to the parameters specified in `pCopy`.\n The [CUDA_MEMCPY2D](crate::ffi::CUDA_MEMCPY2D) structure is defined as:\n\n \\code\ntypedef struct CUDA_MEMCPY2D_st {\nunsigned int srcXInBytes, srcY;\nCUmemorytype srcMemoryType;\nconst void *srcHost;\nCUdeviceptr srcDevice;\nCUarray srcArray;\nunsigned int srcPitch;\n\nunsigned int dstXInBytes, dstY;\nCUmemorytype dstMemoryType;\nvoid *dstHost;\nCUdeviceptr dstDevice;\nCUarray dstArray;\nunsigned int dstPitch;\n\nunsigned int WidthInBytes;\nunsigned int Height;\n} CUDA_MEMCPY2D;\n \\endcode\n where:\n - [srcMemoryType](crate::ffi::srcMemoryType) and [dstMemoryType](crate::ffi::dstMemoryType) specify the type of memory of the\n   source and destination, respectively; [CUmemorytype_enum](crate::ffi::CUmemorytype_enum) is defined as:\n\n \\code\ntypedef enum CUmemorytype_enum {\nCU_MEMORYTYPE_HOST = 0x01,\nCU_MEMORYTYPE_DEVICE = 0x02,\nCU_MEMORYTYPE_ARRAY = 0x03,\nCU_MEMORYTYPE_UNIFIED = 0x04\n} CUmemorytype;\n \\endcode\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [srcArray](crate::ffi::srcArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [srcHost](crate::ffi::srcHost) and [srcPitch](crate::ffi::srcPitch)\n specify the (host) base address of the source data and the bytes per row to\n apply. [srcArray](crate::ffi::srcArray) is ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n specify the (device) base address of the source data and the bytes per row\n to apply. [srcArray](crate::ffi::srcArray) is ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [srcArray](crate::ffi::srcArray) specifies the\n handle of the source data. [srcHost](crate::ffi::srcHost), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch) are\n ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [dstHost](crate::ffi::dstHost) and [dstPitch](crate::ffi::dstPitch)\n specify the (host) base address of the destination data and the bytes per\n row to apply. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [dstArray](crate::ffi::dstArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n specify the (device) base address of the destination data and the bytes per\n row to apply. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [dstArray](crate::ffi::dstArray) specifies the\n handle of the destination data. [dstHost](crate::ffi::dstHost), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch) are\n ignored.\n\n - [srcXInBytes](crate::ffi::srcXInBytes) and [srcY](crate::ffi::srcY) specify the base address of the source data for\n   the copy.\n\n `ar`\n For host pointers, the starting address is\n \\code\nvoid* Start = (void*)((char*)srcHost+srcY*srcPitch + srcXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr Start = srcDevice+srcY*srcPitch+srcXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [srcXInBytes](crate::ffi::srcXInBytes) must be evenly divisible by the array\n element size.\n\n - [dstXInBytes](crate::ffi::dstXInBytes) and [dstY](crate::ffi::dstY) specify the base address of the destination data\n   for the copy.\n\n `ar`\n For host pointers, the base address is\n \\code\nvoid* dstStart = (void*)((char*)dstHost+dstY*dstPitch + dstXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr dstStart = dstDevice+dstY*dstPitch+dstXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [dstXInBytes](crate::ffi::dstXInBytes) must be evenly divisible by the array\n element size.\n\n - [WidthInBytes](crate::ffi::WidthInBytes) and [Height](crate::ffi::Height) specify the width (in bytes) and height of\n   the 2D copy being performed.\n - If specified, [srcPitch](crate::ffi::srcPitch) must be greater than or equal to [WidthInBytes](crate::ffi::WidthInBytes) +\n   [srcXInBytes](crate::ffi::srcXInBytes), and [dstPitch](crate::ffi::dstPitch) must be greater than or equal to\n   [WidthInBytes](crate::ffi::WidthInBytes) + dstXInBytes.\n\n `ar`\n [cuMemcpy2D](crate::ffi::cuMemcpy2D)() returns an error if any pitch is greater than the maximum\n allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_PITCH)). [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)() passes back\n pitches that always work with [cuMemcpy2D](crate::ffi::cuMemcpy2D)(). On intra-device memory copies\n (device to device, CUDA array to device, CUDA array to CUDA array),\n [cuMemcpy2D](crate::ffi::cuMemcpy2D)() may fail for pitches not computed by [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned)() does not have this restriction, but may run\n significantly slower in the cases where [cuMemcpy2D](crate::ffi::cuMemcpy2D)() would have returned\n an error code.\n#### pCopy:\n- Parameters for the memory copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpy2D](crate::ffi::cudaMemcpy2D),\n [cudaMemcpy2DToArray](crate::ffi::cudaMemcpy2DToArray),\n [cudaMemcpy2DFromArray](crate::ffi::cudaMemcpy2DFromArray)\n"]
    pub fn cuMemcpy2D_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory for 2D arrays\n\n Perform a 2D memory copy according to the parameters specified in `pCopy`.\n The [CUDA_MEMCPY2D](crate::ffi::CUDA_MEMCPY2D) structure is defined as:\n\n \\code\ntypedef struct CUDA_MEMCPY2D_st {\nunsigned int srcXInBytes, srcY;\nCUmemorytype srcMemoryType;\nconst void *srcHost;\nCUdeviceptr srcDevice;\nCUarray srcArray;\nunsigned int srcPitch;\nunsigned int dstXInBytes, dstY;\nCUmemorytype dstMemoryType;\nvoid *dstHost;\nCUdeviceptr dstDevice;\nCUarray dstArray;\nunsigned int dstPitch;\nunsigned int WidthInBytes;\nunsigned int Height;\n} CUDA_MEMCPY2D;\n \\endcode\n where:\n - [srcMemoryType](crate::ffi::srcMemoryType) and [dstMemoryType](crate::ffi::dstMemoryType) specify the type of memory of the\n   source and destination, respectively; [CUmemorytype_enum](crate::ffi::CUmemorytype_enum) is defined as:\n\n \\code\ntypedef enum CUmemorytype_enum {\nCU_MEMORYTYPE_HOST = 0x01,\nCU_MEMORYTYPE_DEVICE = 0x02,\nCU_MEMORYTYPE_ARRAY = 0x03,\nCU_MEMORYTYPE_UNIFIED = 0x04\n} CUmemorytype;\n \\endcode\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [srcArray](crate::ffi::srcArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [srcHost](crate::ffi::srcHost) and [srcPitch](crate::ffi::srcPitch)\n specify the (host) base address of the source data and the bytes per row to\n apply. [srcArray](crate::ffi::srcArray) is ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n specify the (device) base address of the source data and the bytes per row\n to apply. [srcArray](crate::ffi::srcArray) is ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [srcArray](crate::ffi::srcArray) specifies the\n handle of the source data. [srcHost](crate::ffi::srcHost), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch) are\n ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [dstArray](crate::ffi::dstArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [dstHost](crate::ffi::dstHost) and [dstPitch](crate::ffi::dstPitch)\n specify the (host) base address of the destination data and the bytes per\n row to apply. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n specify the (device) base address of the destination data and the bytes per\n row to apply. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [dstArray](crate::ffi::dstArray) specifies the\n handle of the destination data. [dstHost](crate::ffi::dstHost), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch) are\n ignored.\n\n - [srcXInBytes](crate::ffi::srcXInBytes) and [srcY](crate::ffi::srcY) specify the base address of the source data for\n   the copy.\n\n `ar`\n For host pointers, the starting address is\n \\code\nvoid* Start = (void*)((char*)srcHost+srcY*srcPitch + srcXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr Start = srcDevice+srcY*srcPitch+srcXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [srcXInBytes](crate::ffi::srcXInBytes) must be evenly divisible by the array\n element size.\n\n - [dstXInBytes](crate::ffi::dstXInBytes) and [dstY](crate::ffi::dstY) specify the base address of the destination data\n   for the copy.\n\n `ar`\n For host pointers, the base address is\n \\code\nvoid* dstStart = (void*)((char*)dstHost+dstY*dstPitch + dstXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr dstStart = dstDevice+dstY*dstPitch+dstXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [dstXInBytes](crate::ffi::dstXInBytes) must be evenly divisible by the array\n element size.\n\n - [WidthInBytes](crate::ffi::WidthInBytes) and [Height](crate::ffi::Height) specify the width (in bytes) and height of\n   the 2D copy being performed.\n - If specified, [srcPitch](crate::ffi::srcPitch) must be greater than or equal to [WidthInBytes](crate::ffi::WidthInBytes) +\n   [srcXInBytes](crate::ffi::srcXInBytes), and [dstPitch](crate::ffi::dstPitch) must be greater than or equal to\n   [WidthInBytes](crate::ffi::WidthInBytes) + dstXInBytes.\n\n `ar`\n [cuMemcpy2D](crate::ffi::cuMemcpy2D)() returns an error if any pitch is greater than the maximum\n allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_PITCH)). [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)() passes back\n pitches that always work with [cuMemcpy2D](crate::ffi::cuMemcpy2D)(). On intra-device memory copies\n (device to device, CUDA array to device, CUDA array to CUDA array),\n [cuMemcpy2D](crate::ffi::cuMemcpy2D)() may fail for pitches not computed by [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned)() does not have this restriction, but may run\n significantly slower in the cases where [cuMemcpy2D](crate::ffi::cuMemcpy2D)() would have returned\n an error code.\n#### pCopy:\n- Parameters for the memory copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpy2D](crate::ffi::cudaMemcpy2D),\n [cudaMemcpy2DToArray](crate::ffi::cudaMemcpy2DToArray),\n [cudaMemcpy2DFromArray](crate::ffi::cudaMemcpy2DFromArray)\n"]
    pub fn cuMemcpy2DUnaligned_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory for 3D arrays\n\n Perform a 3D memory copy according to the parameters specified in\n `pCopy`. The [CUDA_MEMCPY3D](crate::ffi::CUDA_MEMCPY3D) structure is defined as:\n\n \\code\ntypedef struct CUDA_MEMCPY3D_st {\n\nunsigned int srcXInBytes, srcY, srcZ;\nunsigned int srcLOD;\nCUmemorytype srcMemoryType;\nconst void *srcHost;\nCUdeviceptr srcDevice;\nCUarray srcArray;\nunsigned int srcPitch;  // ignored when src is array\nunsigned int srcHeight; // ignored when src is array; may be 0 if Depth==1\n\nunsigned int dstXInBytes, dstY, dstZ;\nunsigned int dstLOD;\nCUmemorytype dstMemoryType;\nvoid *dstHost;\nCUdeviceptr dstDevice;\nCUarray dstArray;\nunsigned int dstPitch;  // ignored when dst is array\nunsigned int dstHeight; // ignored when dst is array; may be 0 if Depth==1\n\nunsigned int WidthInBytes;\nunsigned int Height;\nunsigned int Depth;\n} CUDA_MEMCPY3D;\n \\endcode\n where:\n - [srcMemoryType](crate::ffi::srcMemoryType) and [dstMemoryType](crate::ffi::dstMemoryType) specify the type of memory of the\n   source and destination, respectively; [CUmemorytype_enum](crate::ffi::CUmemorytype_enum) is defined as:\n\n \\code\ntypedef enum CUmemorytype_enum {\nCU_MEMORYTYPE_HOST = 0x01,\nCU_MEMORYTYPE_DEVICE = 0x02,\nCU_MEMORYTYPE_ARRAY = 0x03,\nCU_MEMORYTYPE_UNIFIED = 0x04\n} CUmemorytype;\n \\endcode\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [srcArray](crate::ffi::srcArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [srcHost](crate::ffi::srcHost), [srcPitch](crate::ffi::srcPitch) and\n [srcHeight](crate::ffi::srcHeight) specify the (host) base address of the source data, the bytes\n per row, and the height of each 2D slice of the 3D array. [srcArray](crate::ffi::srcArray) is\n ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [srcDevice](crate::ffi::srcDevice), [srcPitch](crate::ffi::srcPitch) and\n [srcHeight](crate::ffi::srcHeight) specify the (device) base address of the source data, the bytes\n per row, and the height of each 2D slice of the 3D array. [srcArray](crate::ffi::srcArray) is\n ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [srcArray](crate::ffi::srcArray) specifies the\n handle of the source data. [srcHost](crate::ffi::srcHost), [srcDevice](crate::ffi::srcDevice), [srcPitch](crate::ffi::srcPitch) and\n [srcHeight](crate::ffi::srcHeight) are ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [dstArray](crate::ffi::dstArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [dstHost](crate::ffi::dstHost) and [dstPitch](crate::ffi::dstPitch)\n specify the (host) base address of the destination data, the bytes per row,\n and the height of each 2D slice of the 3D array. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n specify the (device) base address of the destination data, the bytes per\n row, and the height of each 2D slice of the 3D array. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [dstArray](crate::ffi::dstArray) specifies the\n handle of the destination data. [dstHost](crate::ffi::dstHost), [dstDevice](crate::ffi::dstDevice), [dstPitch](crate::ffi::dstPitch) and\n [dstHeight](crate::ffi::dstHeight) are ignored.\n\n - [srcXInBytes](crate::ffi::srcXInBytes), [srcY](crate::ffi::srcY) and [srcZ](crate::ffi::srcZ) specify the base address of the source\n   data for the copy.\n\n `ar`\n For host pointers, the starting address is\n \\code\nvoid* Start = (void*)((char*)srcHost+(srcZ*srcHeight+srcY)*srcPitch + srcXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr Start = srcDevice+(srcZ*srcHeight+srcY)*srcPitch+srcXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [srcXInBytes](crate::ffi::srcXInBytes) must be evenly divisible by the array\n element size.\n\n - dstXInBytes, [dstY](crate::ffi::dstY) and [dstZ](crate::ffi::dstZ) specify the base address of the\n   destination data for the copy.\n\n `ar`\n For host pointers, the base address is\n \\code\nvoid* dstStart = (void*)((char*)dstHost+(dstZ*dstHeight+dstY)*dstPitch + dstXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr dstStart = dstDevice+(dstZ*dstHeight+dstY)*dstPitch+dstXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [dstXInBytes](crate::ffi::dstXInBytes) must be evenly divisible by the array\n element size.\n\n - [WidthInBytes](crate::ffi::WidthInBytes), [Height](crate::ffi::Height) and [Depth](crate::ffi::Depth) specify the width (in bytes), height\n   and depth of the 3D copy being performed.\n - If specified, [srcPitch](crate::ffi::srcPitch) must be greater than or equal to [WidthInBytes](crate::ffi::WidthInBytes) +\n   [srcXInBytes](crate::ffi::srcXInBytes), and [dstPitch](crate::ffi::dstPitch) must be greater than or equal to\n   [WidthInBytes](crate::ffi::WidthInBytes) + dstXInBytes.\n - If specified, [srcHeight](crate::ffi::srcHeight) must be greater than or equal to [Height](crate::ffi::Height) +\n   [srcY](crate::ffi::srcY), and [dstHeight](crate::ffi::dstHeight) must be greater than or equal to [Height](crate::ffi::Height) + [dstY](crate::ffi::dstY).\n\n `ar`\n [cuMemcpy3D](crate::ffi::cuMemcpy3D)() returns an error if any pitch is greater than the maximum\n allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_PITCH)).\n\n The [srcLOD](crate::ffi::srcLOD) and [dstLOD](crate::ffi::dstLOD) members of the [CUDA_MEMCPY3D](crate::ffi::CUDA_MEMCPY3D) structure must be\n set to 0.\n#### pCopy:\n- Parameters for the memory copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemcpy3D](crate::ffi::cudaMemcpy3D)\n"]
    pub fn cuMemcpy3D_v2(pCopy: *const CUDA_MEMCPY3D) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory between contexts\n\n Perform a 3D memory copy according to the parameters specified in\n `pCopy`.  See the definition of the [CUDA_MEMCPY3D_PEER](crate::ffi::CUDA_MEMCPY3D_PEER) structure\n for documentation of its parameters.\n#### pCopy:\n- Parameters for the memory copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyPeer](crate::ffi::cuMemcpyPeer), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync), [cuMemcpyPeerAsync](crate::ffi::cuMemcpyPeerAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync),\n [cudaMemcpy3DPeer](crate::ffi::cudaMemcpy3DPeer)\n"]
    pub fn cuMemcpy3DPeer(pCopy: *const CUDA_MEMCPY3D_PEER) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory asynchronously\n\n Copies data between two pointers.\n `dst` and `src` are base pointers of the destination and source, respectively.\n `ByteCount` specifies the number of bytes to copy.\n Note that this function infers the type of the transfer (host to host, host to\n   device, device to device, or device to host) from the pointer values.  This\n   function is only allowed in contexts which support unified addressing.\n#### dst:\n- Destination unified virtual address space pointer\n#### src:\n- Source unified virtual address space pointer\n#### ByteCount:\n- Size of memory copy in bytes\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpyAsync](crate::ffi::cudaMemcpyAsync),\n [cudaMemcpyToSymbolAsync](crate::ffi::cudaMemcpyToSymbolAsync),\n [cudaMemcpyFromSymbolAsync](crate::ffi::cudaMemcpyFromSymbolAsync)\n"]
    pub fn cuMemcpyAsync(
        dst: CUdeviceptr,
        src: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies device memory between two contexts asynchronously.\n\n Copies from device memory in one context to device memory in another\n context. `dstDevice` is the base device pointer of the destination memory\n and `dstContext` is the destination context.  `srcDevice` is the base\n device pointer of the source memory and `srcContext` is the source pointer.\n `ByteCount` specifies the number of bytes to copy.\n#### dstDevice:\n- Destination device pointer\n#### dstContext:\n- Destination context\n#### srcDevice:\n- Source device pointer\n#### srcContext:\n- Source context\n#### ByteCount:\n- Size of memory copy in bytes\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyPeer](crate::ffi::cuMemcpyPeer), [cuMemcpy3DPeer](crate::ffi::cuMemcpy3DPeer), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync),\n [cudaMemcpyPeerAsync](crate::ffi::cudaMemcpyPeerAsync)\n"]
    pub fn cuMemcpyPeerAsync(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Host to Device\n\n Copies from host memory to device memory. `dstDevice` and `srcHost` are\n the base addresses of the destination and source, respectively. `ByteCount`\n specifies the number of bytes to copy.\n#### dstDevice:\n- Destination device pointer\n#### srcHost:\n- Source host pointer\n#### ByteCount:\n- Size of memory copy in bytes\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpyAsync](crate::ffi::cudaMemcpyAsync),\n [cudaMemcpyToSymbolAsync](crate::ffi::cudaMemcpyToSymbolAsync)\n"]
    pub fn cuMemcpyHtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::ffi::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Device to Host\n\n Copies from device to host memory. `dstHost` and `srcDevice` specify the\n base pointers of the destination and source, respectively. `ByteCount`\n specifies the number of bytes to copy.\n#### dstHost:\n- Destination host pointer\n#### srcDevice:\n- Source device pointer\n#### ByteCount:\n- Size of memory copy in bytes\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpyAsync](crate::ffi::cudaMemcpyAsync),\n [cudaMemcpyFromSymbolAsync](crate::ffi::cudaMemcpyFromSymbolAsync)\n"]
    pub fn cuMemcpyDtoHAsync_v2(
        dstHost: *mut ::std::ffi::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Device to Device\n\n Copies from device memory to device memory. `dstDevice` and `srcDevice`\n are the base pointers of the destination and source, respectively.\n `ByteCount` specifies the number of bytes to copy.\n#### dstDevice:\n- Destination device pointer\n#### srcDevice:\n- Source device pointer\n#### ByteCount:\n- Size of memory copy in bytes\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpyAsync](crate::ffi::cudaMemcpyAsync),\n [cudaMemcpyToSymbolAsync](crate::ffi::cudaMemcpyToSymbolAsync),\n [cudaMemcpyFromSymbolAsync](crate::ffi::cudaMemcpyFromSymbolAsync)\n"]
    pub fn cuMemcpyDtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Host to Array\n\n Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`\n specify the CUDA array handle and starting offset in bytes of the\n destination data. `srcHost` specifies the base address of the source.\n `ByteCount` specifies the number of bytes to copy.\n#### dstArray:\n- Destination array\n#### dstOffset:\n- Offset in bytes of destination array\n#### srcHost:\n- Source host pointer\n#### ByteCount:\n- Size of memory copy in bytes\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpyToArrayAsync](crate::ffi::cudaMemcpyToArrayAsync)\n"]
    pub fn cuMemcpyHtoAAsync_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::std::ffi::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory from Array to Host\n\n Copies from one 1D CUDA array to host memory. `dstHost` specifies the base\n pointer of the destination. `srcArray` and `srcOffset` specify the CUDA\n array handle and starting offset in bytes of the source data.\n `ByteCount` specifies the number of bytes to copy.\n#### dstHost:\n- Destination pointer\n#### srcArray:\n- Source array\n#### srcOffset:\n- Offset in bytes of source array\n#### ByteCount:\n- Size of memory copy in bytes\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpyFromArrayAsync](crate::ffi::cudaMemcpyFromArrayAsync)\n"]
    pub fn cuMemcpyAtoHAsync_v2(
        dstHost: *mut ::std::ffi::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory for 2D arrays\n\n Perform a 2D memory copy according to the parameters specified in `pCopy`.\n The [CUDA_MEMCPY2D](crate::ffi::CUDA_MEMCPY2D) structure is defined as:\n\n \\code\ntypedef struct CUDA_MEMCPY2D_st {\nunsigned int srcXInBytes, srcY;\nCUmemorytype srcMemoryType;\nconst void *srcHost;\nCUdeviceptr srcDevice;\nCUarray srcArray;\nunsigned int srcPitch;\nunsigned int dstXInBytes, dstY;\nCUmemorytype dstMemoryType;\nvoid *dstHost;\nCUdeviceptr dstDevice;\nCUarray dstArray;\nunsigned int dstPitch;\nunsigned int WidthInBytes;\nunsigned int Height;\n} CUDA_MEMCPY2D;\n \\endcode\n where:\n - [srcMemoryType](crate::ffi::srcMemoryType) and [dstMemoryType](crate::ffi::dstMemoryType) specify the type of memory of the\n   source and destination, respectively; [CUmemorytype_enum](crate::ffi::CUmemorytype_enum) is defined as:\n\n \\code\ntypedef enum CUmemorytype_enum {\nCU_MEMORYTYPE_HOST = 0x01,\nCU_MEMORYTYPE_DEVICE = 0x02,\nCU_MEMORYTYPE_ARRAY = 0x03,\nCU_MEMORYTYPE_UNIFIED = 0x04\n} CUmemorytype;\n \\endcode\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [srcHost](crate::ffi::srcHost) and [srcPitch](crate::ffi::srcPitch)\n specify the (host) base address of the source data and the bytes per row to\n apply. [srcArray](crate::ffi::srcArray) is ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [srcArray](crate::ffi::srcArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n specify the (device) base address of the source data and the bytes per row\n to apply. [srcArray](crate::ffi::srcArray) is ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [srcArray](crate::ffi::srcArray) specifies the\n handle of the source data. [srcHost](crate::ffi::srcHost), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch) are\n ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [dstArray](crate::ffi::dstArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [dstHost](crate::ffi::dstHost) and [dstPitch](crate::ffi::dstPitch)\n specify the (host) base address of the destination data and the bytes per\n row to apply. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n specify the (device) base address of the destination data and the bytes per\n row to apply. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [dstArray](crate::ffi::dstArray) specifies the\n handle of the destination data. [dstHost](crate::ffi::dstHost), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch) are\n ignored.\n\n - [srcXInBytes](crate::ffi::srcXInBytes) and [srcY](crate::ffi::srcY) specify the base address of the source data for\n   the copy.\n\n `ar`\n For host pointers, the starting address is\n \\code\nvoid* Start = (void*)((char*)srcHost+srcY*srcPitch + srcXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr Start = srcDevice+srcY*srcPitch+srcXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [srcXInBytes](crate::ffi::srcXInBytes) must be evenly divisible by the array\n element size.\n\n - [dstXInBytes](crate::ffi::dstXInBytes) and [dstY](crate::ffi::dstY) specify the base address of the destination data\n   for the copy.\n\n `ar`\n For host pointers, the base address is\n \\code\nvoid* dstStart = (void*)((char*)dstHost+dstY*dstPitch + dstXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr dstStart = dstDevice+dstY*dstPitch+dstXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [dstXInBytes](crate::ffi::dstXInBytes) must be evenly divisible by the array\n element size.\n\n - [WidthInBytes](crate::ffi::WidthInBytes) and [Height](crate::ffi::Height) specify the width (in bytes) and height of\n   the 2D copy being performed.\n - If specified, [srcPitch](crate::ffi::srcPitch) must be greater than or equal to [WidthInBytes](crate::ffi::WidthInBytes) +\n   [srcXInBytes](crate::ffi::srcXInBytes), and [dstPitch](crate::ffi::dstPitch) must be greater than or equal to\n   [WidthInBytes](crate::ffi::WidthInBytes) + dstXInBytes.\n - If specified, [srcPitch](crate::ffi::srcPitch) must be greater than or equal to [WidthInBytes](crate::ffi::WidthInBytes) +\n   [srcXInBytes](crate::ffi::srcXInBytes), and [dstPitch](crate::ffi::dstPitch) must be greater than or equal to\n   [WidthInBytes](crate::ffi::WidthInBytes) + dstXInBytes.\n - If specified, [srcHeight](crate::ffi::srcHeight) must be greater than or equal to [Height](crate::ffi::Height) +\n   [srcY](crate::ffi::srcY), and [dstHeight](crate::ffi::dstHeight) must be greater than or equal to [Height](crate::ffi::Height) + [dstY](crate::ffi::dstY).\n\n `ar`\n [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync)() returns an error if any pitch is greater than the maximum\n allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_PITCH)). [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)() passes back\n pitches that always work with [cuMemcpy2D](crate::ffi::cuMemcpy2D)(). On intra-device memory copies\n (device to device, CUDA array to device, CUDA array to CUDA array),\n [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync)() may fail for pitches not computed by [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n#### pCopy:\n- Parameters for the memory copy\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpy2DAsync](crate::ffi::cudaMemcpy2DAsync),\n [cudaMemcpy2DToArrayAsync](crate::ffi::cudaMemcpy2DToArrayAsync),\n [cudaMemcpy2DFromArrayAsync](crate::ffi::cudaMemcpy2DFromArrayAsync)\n"]
    pub fn cuMemcpy2DAsync_v2(pCopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory for 3D arrays\n\n Perform a 3D memory copy according to the parameters specified in\n `pCopy`. The [CUDA_MEMCPY3D](crate::ffi::CUDA_MEMCPY3D) structure is defined as:\n\n \\code\ntypedef struct CUDA_MEMCPY3D_st {\n\nunsigned int srcXInBytes, srcY, srcZ;\nunsigned int srcLOD;\nCUmemorytype srcMemoryType;\nconst void *srcHost;\nCUdeviceptr srcDevice;\nCUarray srcArray;\nunsigned int srcPitch;  // ignored when src is array\nunsigned int srcHeight; // ignored when src is array; may be 0 if Depth==1\n\nunsigned int dstXInBytes, dstY, dstZ;\nunsigned int dstLOD;\nCUmemorytype dstMemoryType;\nvoid *dstHost;\nCUdeviceptr dstDevice;\nCUarray dstArray;\nunsigned int dstPitch;  // ignored when dst is array\nunsigned int dstHeight; // ignored when dst is array; may be 0 if Depth==1\n\nunsigned int WidthInBytes;\nunsigned int Height;\nunsigned int Depth;\n} CUDA_MEMCPY3D;\n \\endcode\n where:\n - [srcMemoryType](crate::ffi::srcMemoryType) and [dstMemoryType](crate::ffi::dstMemoryType) specify the type of memory of the\n   source and destination, respectively; [CUmemorytype_enum](crate::ffi::CUmemorytype_enum) is defined as:\n\n \\code\ntypedef enum CUmemorytype_enum {\nCU_MEMORYTYPE_HOST = 0x01,\nCU_MEMORYTYPE_DEVICE = 0x02,\nCU_MEMORYTYPE_ARRAY = 0x03,\nCU_MEMORYTYPE_UNIFIED = 0x04\n} CUmemorytype;\n \\endcode\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [srcDevice](crate::ffi::srcDevice) and [srcPitch](crate::ffi::srcPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [srcArray](crate::ffi::srcArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [srcHost](crate::ffi::srcHost), [srcPitch](crate::ffi::srcPitch) and\n [srcHeight](crate::ffi::srcHeight) specify the (host) base address of the source data, the bytes\n per row, and the height of each 2D slice of the 3D array. [srcArray](crate::ffi::srcArray) is\n ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [srcDevice](crate::ffi::srcDevice), [srcPitch](crate::ffi::srcPitch) and\n [srcHeight](crate::ffi::srcHeight) specify the (device) base address of the source data, the bytes\n per row, and the height of each 2D slice of the 3D array. [srcArray](crate::ffi::srcArray) is\n ignored.\n\n `ar`\n If [srcMemoryType](crate::ffi::srcMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [srcArray](crate::ffi::srcArray) specifies the\n handle of the source data. [srcHost](crate::ffi::srcHost), [srcDevice](crate::ffi::srcDevice), [srcPitch](crate::ffi::srcPitch) and\n [srcHeight](crate::ffi::srcHeight) are ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n   specify the (unified virtual address space) base address of the source data\n   and the bytes per row to apply.  [dstArray](crate::ffi::dstArray) is ignored.\n This value may be used only if unified addressing is supported in the calling\n   context.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST), [dstHost](crate::ffi::dstHost) and [dstPitch](crate::ffi::dstPitch)\n specify the (host) base address of the destination data, the bytes per row,\n and the height of each 2D slice of the 3D array. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE), [dstDevice](crate::ffi::dstDevice) and [dstPitch](crate::ffi::dstPitch)\n specify the (device) base address of the destination data, the bytes per\n row, and the height of each 2D slice of the 3D array. [dstArray](crate::ffi::dstArray) is ignored.\n\n `ar`\n If [dstMemoryType](crate::ffi::dstMemoryType) is [CU_MEMORYTYPE_ARRAY](crate::ffi::CU_MEMORYTYPE_ARRAY), [dstArray](crate::ffi::dstArray) specifies the\n handle of the destination data. [dstHost](crate::ffi::dstHost), [dstDevice](crate::ffi::dstDevice), [dstPitch](crate::ffi::dstPitch) and\n [dstHeight](crate::ffi::dstHeight) are ignored.\n\n - [srcXInBytes](crate::ffi::srcXInBytes), [srcY](crate::ffi::srcY) and [srcZ](crate::ffi::srcZ) specify the base address of the source\n   data for the copy.\n\n `ar`\n For host pointers, the starting address is\n \\code\nvoid* Start = (void*)((char*)srcHost+(srcZ*srcHeight+srcY)*srcPitch + srcXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr Start = srcDevice+(srcZ*srcHeight+srcY)*srcPitch+srcXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [srcXInBytes](crate::ffi::srcXInBytes) must be evenly divisible by the array\n element size.\n\n - dstXInBytes, [dstY](crate::ffi::dstY) and [dstZ](crate::ffi::dstZ) specify the base address of the\n   destination data for the copy.\n\n `ar`\n For host pointers, the base address is\n \\code\nvoid* dstStart = (void*)((char*)dstHost+(dstZ*dstHeight+dstY)*dstPitch + dstXInBytes);\n \\endcode\n\n `ar`\n For device pointers, the starting address is\n \\code\nCUdeviceptr dstStart = dstDevice+(dstZ*dstHeight+dstY)*dstPitch+dstXInBytes;\n \\endcode\n\n `ar`\n For CUDA arrays, [dstXInBytes](crate::ffi::dstXInBytes) must be evenly divisible by the array\n element size.\n\n - [WidthInBytes](crate::ffi::WidthInBytes), [Height](crate::ffi::Height) and [Depth](crate::ffi::Depth) specify the width (in bytes), height\n   and depth of the 3D copy being performed.\n - If specified, [srcPitch](crate::ffi::srcPitch) must be greater than or equal to [WidthInBytes](crate::ffi::WidthInBytes) +\n   [srcXInBytes](crate::ffi::srcXInBytes), and [dstPitch](crate::ffi::dstPitch) must be greater than or equal to\n   [WidthInBytes](crate::ffi::WidthInBytes) + dstXInBytes.\n - If specified, [srcHeight](crate::ffi::srcHeight) must be greater than or equal to [Height](crate::ffi::Height) +\n   [srcY](crate::ffi::srcY), and [dstHeight](crate::ffi::dstHeight) must be greater than or equal to [Height](crate::ffi::Height) + [dstY](crate::ffi::dstY).\n\n `ar`\n [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync)() returns an error if any pitch is greater than the maximum\n allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_PITCH)).\n\n The [srcLOD](crate::ffi::srcLOD) and [dstLOD](crate::ffi::dstLOD) members of the [CUDA_MEMCPY3D](crate::ffi::CUDA_MEMCPY3D) structure must be\n set to 0.\n#### pCopy:\n- Parameters for the memory copy\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemcpy3DAsync](crate::ffi::cudaMemcpy3DAsync)\n"]
    pub fn cuMemcpy3DAsync_v2(pCopy: *const CUDA_MEMCPY3D, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies memory between contexts asynchronously.\n\n Perform a 3D memory copy according to the parameters specified in\n `pCopy`.  See the definition of the [CUDA_MEMCPY3D_PEER](crate::ffi::CUDA_MEMCPY3D_PEER) structure\n for documentation of its parameters.\n#### pCopy:\n- Parameters for the memory copy\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyPeer](crate::ffi::cuMemcpyPeer), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync), [cuMemcpyPeerAsync](crate::ffi::cuMemcpyPeerAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync),\n [cudaMemcpy3DPeerAsync](crate::ffi::cudaMemcpy3DPeerAsync)\n"]
    pub fn cuMemcpy3DPeerAsync(pCopy: *const CUDA_MEMCPY3D_PEER, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Performs a batch of memory copies asynchronously.\n\n Performs a batch of memory copies. The batch as a whole executes in stream order but copies within a\n batch are not guaranteed to execute in any specific order. This API only supports pointer-to-pointer copies.\n For copies involving CUDA arrays, please see [cuMemcpy3DBatchAsync](crate::ffi::cuMemcpy3DBatchAsync).\n\n Performs memory copies from source buffers specified in `srcs` to destination buffers specified in `dsts`.\n The size of each copy is specified in `sizes`. All three arrays must be of the same length as specified\n by `count`. Since there are no ordering guarantees for copies within a batch, specifying any dependent copies\n within a batch will result in undefined behavior.\n\n Every copy in the batch has to be associated with a set of attributes specified in the `attrs` array.\n Each entry in this array can apply to more than one copy. This can be done by specifying in the `attrsIdxs` array,\n the index of the first copy that the corresponding entry in the `attrs` array applies to. Both `attrs` and\n `attrsIdxs` must be of the same length as specified by `numAttrs`. For example, if a batch has 10 copies listed\n in dst/src/sizes, the first 6 of which have one set of attributes and the remaining 4 another, then `numAttrs`\n will be 2, `attrsIdxs` will be {0, 6} and `attrs` will contains the two sets of attributes. Note that the first entry\n in `attrsIdxs` must always be 0. Also, each entry must be greater than the previous entry and the last entry should be\n less than `count`. Furthermore, `numAttrs` must be lesser than or equal to `count`.\n\n The [CUmemcpyAttributes](crate::ffi::CUmemcpyAttributes)[srcAccessOrder](crate::ffi::srcAccessOrder) indicates the source access ordering to be observed for copies associated\n with the attribute. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_STREAM](crate::ffi::CU_MEMCPY_SRC_ACCESS_ORDER_STREAM), then the source will\n be accessed in stream order. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL](crate::ffi::CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL) then\n it indicates that access to the source pointer can be out of stream order and all accesses must be complete before\n the API call returns. This flag is suited for ephemeral sources (ex., stack variables) when it's known that no prior\n operations in the stream can be accessing the memory and also that the lifetime of the memory is limited to the scope\n that the source variable was declared in. Specifying this flag allows the driver to optimize the copy and removes the\n need for the user to synchronize the stream after the API call. If the source access order is set to\n [CU_MEMCPY_SRC_ACCESS_ORDER_ANY](crate::ffi::CU_MEMCPY_SRC_ACCESS_ORDER_ANY) then it indicates that access to the source pointer can be out of stream order and the\n accesses can happen even after the API call returns. This flag is suited for host pointers allocated\n outside CUDA (ex., via malloc) when it's known that no prior operations in the stream can be accessing the memory.\n Specifying this flag allows the driver to optimize the copy on certain platforms. Each memcpy operation in the batch must\n have a valid [CUmemcpyAttributes](crate::ffi::CUmemcpyAttributes) corresponding to it including the appropriate srcAccessOrder setting, otherwise the API\n will return [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n\n The [CUmemcpyAttributes](crate::ffi::CUmemcpyAttributes)[srcLocHint](crate::ffi::srcLocHint) and [CUmemcpyAttributes](crate::ffi::CUmemcpyAttributes)[dstLocHint](crate::ffi::dstLocHint) allows applications to specify hint locations\n for operands of a copy when the operand doesn't have a fixed location. That is, these hints are\n only applicable for managed memory pointers on devices where [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS) is true or\n system-allocated pageable memory on devices where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS) is true.\n For other cases, these hints are ignored.\n\n The [CUmemcpyAttributes](crate::ffi::CUmemcpyAttributes)[flags](crate::ffi::flags) field can be used to specify certain flags for copies. Setting the\n [CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE](crate::ffi::CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE) flag indicates that the associated copies should preferably overlap with\n any compute work. Note that this flag is a hint and can be ignored depending on the platform and other parameters of the copy.\n\n If any error is encountered while parsing the batch, the index within the batch where the error was encountered\n will be returned in `failIdx`.\n#### dsts:\n- Array of destination pointers.\n#### srcs:\n- Array of memcpy source pointers.\n#### sizes:\n- Array of sizes for memcpy operations.\n#### count:\n- Size of `dsts`, `srcs` and `sizes` arrays\n#### attrs:\n- Array of memcpy attributes.\n#### attrsIdxs:\n- Array of indices to specify which copies each entry in the `attrs` array applies to.\nThe attributes specified in attrs[k] will be applied to copies starting from attrsIdxs[k]\nthrough attrsIdxs[k+1] - 1. Also attrs[numAttrs-1] will apply to copies starting from\nattrsIdxs[numAttrs-1] through count - 1.\n#### numAttrs:\n- Size of `attrs` and `attrsIdxs` arrays.\n#### failIdx:\n- Pointer to a location to return the index of the copy where a failure was encountered.\nThe value will be SIZE_MAX if the error doesn't pertain to any specific copy.\n#### hStream:\n- The stream to enqueue the operations in. Must not be legacy NULL stream.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n"]
    pub fn cuMemcpyBatchAsync(
        dsts: *mut CUdeviceptr,
        srcs: *mut CUdeviceptr,
        sizes: *mut usize,
        count: usize,
        attrs: *mut CUmemcpyAttributes,
        attrsIdxs: *mut usize,
        numAttrs: usize,
        failIdx: *mut usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Performs a batch of 3D memory copies asynchronously.\n\n Performs a batch of memory copies. The batch as a whole executes in stream order but copies within a\n batch are not guaranteed to execute in any specific order. Note that this means specifying any dependent\n copies within a batch will result in undefined behavior.\n\n Performs memory copies as specified in the `opList` array. The length of this array is specified in `numOps`.\n Each entry in this array describes a copy operation. This includes among other things, the source and destination\n operands for the copy as specified in [CUDA_MEMCPY3D_BATCH_OP](crate::ffi::CUDA_MEMCPY3D_BATCH_OP)[src](crate::ffi::src) and [CUDA_MEMCPY3D_BATCH_OP](crate::ffi::CUDA_MEMCPY3D_BATCH_OP)[dst](crate::ffi::dst) respectively.\n The source and destination operands of a copy can either be a pointer or a CUDA array. The width, height and depth\n of a copy is specified in [CUDA_MEMCPY3D_BATCH_OP](crate::ffi::CUDA_MEMCPY3D_BATCH_OP)[extent](crate::ffi::extent). The width, height and depth of a copy are specified in\n elements and must not be zero. For pointer-to-pointer copies, the element size is considered to be 1. For pointer\n to CUDA array or vice versa copies, the element size is determined by the CUDA array. For CUDA array to CUDA array copies,\n the element size of the two CUDA arrays must match.\n\n For a given operand, if [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[type](crate::ffi::type) is specified as [CU_MEMCPY_OPERAND_TYPE_POINTER](crate::ffi::CU_MEMCPY_OPERAND_TYPE_POINTER), then\n [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[ptr](crate::ffi::ptr) will be used. The [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[ptr](crate::ffi::ptr)[ptr](crate::ffi::ptr) field must contain the pointer where\n the copy should begin. The [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[ptr](crate::ffi::ptr)[rowLength](crate::ffi::rowLength) field specifies the length of each row in elements and\n must either be zero or be greater than or equal to the width of the copy specified in [CUDA_MEMCPY3D_BATCH_OP](crate::ffi::CUDA_MEMCPY3D_BATCH_OP)[extent](crate::ffi::extent)[width](crate::ffi::width).\n The [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[ptr](crate::ffi::ptr)[layerHeight](crate::ffi::layerHeight) field specifies the height of each layer and must either be zero or be greater than\n or equal to the height of the copy specified in [CUDA_MEMCPY3D_BATCH_OP](crate::ffi::CUDA_MEMCPY3D_BATCH_OP)[extent](crate::ffi::extent)[height](crate::ffi::height). When either of these values is zero,\n that aspect of the operand is considered to be tightly packed according to the copy extent. For managed memory pointers on devices where\n [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS) is true or system-allocated pageable memory on devices where\n [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS) is true, the [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[ptr](crate::ffi::ptr)[locHint](crate::ffi::locHint) field can be used to hint\n the location of the operand.\n\n If an operand's type is specified as [CU_MEMCPY_OPERAND_TYPE_ARRAY](crate::ffi::CU_MEMCPY_OPERAND_TYPE_ARRAY), then [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[array](crate::ffi::array) will be used.\n The [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[array](crate::ffi::array)[array](crate::ffi::array) field specifies the CUDA array and [CUmemcpy3DOperand](crate::ffi::CUmemcpy3DOperand)[op](crate::ffi::op)[array](crate::ffi::array)[offset](crate::ffi::offset) specifies\n the 3D offset into that array where the copy begins.\n\n The [CUmemcpyAttributes](crate::ffi::CUmemcpyAttributes)[srcAccessOrder](crate::ffi::srcAccessOrder) indicates the source access ordering to be observed for copies associated\n with the attribute. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_STREAM](crate::ffi::CU_MEMCPY_SRC_ACCESS_ORDER_STREAM), then the source will\n be accessed in stream order. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL](crate::ffi::CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL) then\n it indicates that access to the source pointer can be out of stream order and all accesses must be complete before\n the API call returns. This flag is suited for ephemeral sources (ex., stack variables) when it's known that no prior\n operations in the stream can be accessing the memory and also that the lifetime of the memory is limited to the scope\n that the source variable was declared in. Specifying this flag allows the driver to optimize the copy and removes the\n need for the user to synchronize the stream after the API call. If the source access order is set to\n [CU_MEMCPY_SRC_ACCESS_ORDER_ANY](crate::ffi::CU_MEMCPY_SRC_ACCESS_ORDER_ANY) then it indicates that access to the source pointer can be out of stream order and the\n accesses can happen even after the API call returns. This flag is suited for host pointers allocated\n outside CUDA (ex., via malloc) when it's known that no prior operations in the stream can be accessing the memory.\n Specifying this flag allows the driver to optimize the copy on certain platforms. Each memcopy operation in `opList` must\n have a valid srcAccessOrder setting, otherwise this API will return [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n\n The [CUmemcpyAttributes](crate::ffi::CUmemcpyAttributes)[flags](crate::ffi::flags) field can be used to specify certain flags for copies. Setting the\n [CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE](crate::ffi::CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE) flag indicates that the associated copies should preferably overlap with\n any compute work. Note that this flag is a hint and can be ignored depending on the platform and other parameters of the copy.\n\n If any error is encountered while parsing the batch, the index within the batch where the error was encountered\n will be returned in `failIdx`.\n#### numOps:\n- Total number of memcpy operations.\n#### opList:\n- Array of size `numOps` containing the actual memcpy operations.\n#### failIdx:\n- Pointer to a location to return the index of the copy where a failure was encountered.\n                     The value will be SIZE_MAX if the error doesn't pertain to any specific copy.\n#### flags:\n- Flags for future use, must be zero now.\n#### hStream:\n- The stream to enqueue the operations in. Must not be default NULL stream.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.\n\n"]
    pub fn cuMemcpy3DBatchAsync(
        numOps: usize,
        opList: *mut CUDA_MEMCPY3D_BATCH_OP,
        failIdx: *mut usize,
        flags: ::std::ffi::c_ulonglong,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Initializes device memory\n\n Sets the memory range of `N` 8-bit values to the specified value\n `uc`.\n#### dstDevice:\n- Destination device pointer\n#### uc:\n- Value to set\n#### N:\n- Number of elements\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset](crate::ffi::cudaMemset)\n"]
    pub fn cuMemsetD8_v2(dstDevice: CUdeviceptr, uc: ::std::ffi::c_uchar, N: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Initializes device memory\n\n Sets the memory range of `N` 16-bit values to the specified value\n `us`. The `dstDevice` pointer must be two byte aligned.\n#### dstDevice:\n- Destination device pointer\n#### us:\n- Value to set\n#### N:\n- Number of elements\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset](crate::ffi::cudaMemset)\n"]
    pub fn cuMemsetD16_v2(dstDevice: CUdeviceptr, us: ::std::ffi::c_ushort, N: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Initializes device memory\n\n Sets the memory range of `N` 32-bit values to the specified value\n `ui`. The `dstDevice` pointer must be four byte aligned.\n#### dstDevice:\n- Destination device pointer\n#### ui:\n- Value to set\n#### N:\n- Number of elements\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset](crate::ffi::cudaMemset)\n"]
    pub fn cuMemsetD32_v2(dstDevice: CUdeviceptr, ui: ::std::ffi::c_uint, N: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Initializes device memory\n\n Sets the 2D memory range of `Width` 8-bit values to the specified value\n `uc`. `Height` specifies the number of rows to set, and `dstPitch`\n specifies the number of bytes between each row. This function performs\n fastest when the pitch is one that has been passed back by\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n#### dstDevice:\n- Destination device pointer\n#### dstPitch:\n- Pitch of destination device pointer(Unused if `Height` is 1)\n#### uc:\n- Value to set\n#### Width:\n- Width of row\n#### Height:\n- Number of rows\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset2D](crate::ffi::cudaMemset2D)\n"]
    pub fn cuMemsetD2D8_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::std::ffi::c_uchar,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Initializes device memory\n\n Sets the 2D memory range of `Width` 16-bit values to the specified value\n `us`. `Height` specifies the number of rows to set, and `dstPitch`\n specifies the number of bytes between each row. The `dstDevice` pointer\n and `dstPitch` offset must be two byte aligned. This function performs\n fastest when the pitch is one that has been passed back by\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n#### dstDevice:\n- Destination device pointer\n#### dstPitch:\n- Pitch of destination device pointer(Unused if `Height` is 1)\n#### us:\n- Value to set\n#### Width:\n- Width of row\n#### Height:\n- Number of rows\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset2D](crate::ffi::cudaMemset2D)\n"]
    pub fn cuMemsetD2D16_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::std::ffi::c_ushort,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Initializes device memory\n\n Sets the 2D memory range of `Width` 32-bit values to the specified value\n `ui`. `Height` specifies the number of rows to set, and `dstPitch`\n specifies the number of bytes between each row. The `dstDevice` pointer\n and `dstPitch` offset must be four byte aligned. This function performs\n fastest when the pitch is one that has been passed back by\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n#### dstDevice:\n- Destination device pointer\n#### dstPitch:\n- Pitch of destination device pointer(Unused if `Height` is 1)\n#### ui:\n- Value to set\n#### Width:\n- Width of row\n#### Height:\n- Number of rows\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset2D](crate::ffi::cudaMemset2D)\n"]
    pub fn cuMemsetD2D32_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::std::ffi::c_uint,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets device memory\n\n Sets the memory range of `N` 8-bit values to the specified value\n `uc`.\n#### dstDevice:\n- Destination device pointer\n#### uc:\n- Value to set\n#### N:\n- Number of elements\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemsetAsync](crate::ffi::cudaMemsetAsync)\n"]
    pub fn cuMemsetD8Async(
        dstDevice: CUdeviceptr,
        uc: ::std::ffi::c_uchar,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets device memory\n\n Sets the memory range of `N` 16-bit values to the specified value\n `us`. The `dstDevice` pointer must be two byte aligned.\n#### dstDevice:\n- Destination device pointer\n#### us:\n- Value to set\n#### N:\n- Number of elements\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemsetAsync](crate::ffi::cudaMemsetAsync)\n"]
    pub fn cuMemsetD16Async(
        dstDevice: CUdeviceptr,
        us: ::std::ffi::c_ushort,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets device memory\n\n Sets the memory range of `N` 32-bit values to the specified value\n `ui`. The `dstDevice` pointer must be four byte aligned.\n#### dstDevice:\n- Destination device pointer\n#### ui:\n- Value to set\n#### N:\n- Number of elements\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMemsetAsync](crate::ffi::cudaMemsetAsync)\n"]
    pub fn cuMemsetD32Async(
        dstDevice: CUdeviceptr,
        ui: ::std::ffi::c_uint,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets device memory\n\n Sets the 2D memory range of `Width` 8-bit values to the specified value\n `uc`. `Height` specifies the number of rows to set, and `dstPitch`\n specifies the number of bytes between each row. This function performs\n fastest when the pitch is one that has been passed back by\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n#### dstDevice:\n- Destination device pointer\n#### dstPitch:\n- Pitch of destination device pointer(Unused if `Height` is 1)\n#### uc:\n- Value to set\n#### Width:\n- Width of row\n#### Height:\n- Number of rows\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset2DAsync](crate::ffi::cudaMemset2DAsync)\n"]
    pub fn cuMemsetD2D8Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::std::ffi::c_uchar,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets device memory\n\n Sets the 2D memory range of `Width` 16-bit values to the specified value\n `us`. `Height` specifies the number of rows to set, and `dstPitch`\n specifies the number of bytes between each row. The `dstDevice` pointer\n and `dstPitch` offset must be two byte aligned. This function performs\n fastest when the pitch is one that has been passed back by\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n#### dstDevice:\n- Destination device pointer\n#### dstPitch:\n- Pitch of destination device pointer(Unused if `Height` is 1)\n#### us:\n- Value to set\n#### Width:\n- Width of row\n#### Height:\n- Number of rows\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD2D32Async](crate::ffi::cuMemsetD2D32Async),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset2DAsync](crate::ffi::cudaMemset2DAsync)\n"]
    pub fn cuMemsetD2D16Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::std::ffi::c_ushort,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets device memory\n\n Sets the 2D memory range of `Width` 32-bit values to the specified value\n `ui`. `Height` specifies the number of rows to set, and `dstPitch`\n specifies the number of bytes between each row. The `dstDevice` pointer\n and `dstPitch` offset must be four byte aligned. This function performs\n fastest when the pitch is one that has been passed back by\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch)().\n#### dstDevice:\n- Destination device pointer\n#### dstPitch:\n- Pitch of destination device pointer(Unused if `Height` is 1)\n#### ui:\n- Value to set\n#### Width:\n- Width of row\n#### Height:\n- Number of rows\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n See also [memset synchronization details](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memset).\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D8Async](crate::ffi::cuMemsetD2D8Async),\n [cuMemsetD2D16](crate::ffi::cuMemsetD2D16), [cuMemsetD2D16Async](crate::ffi::cuMemsetD2D16Async), [cuMemsetD2D32](crate::ffi::cuMemsetD2D32),\n [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD8Async](crate::ffi::cuMemsetD8Async), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD16Async](crate::ffi::cuMemsetD16Async),\n [cuMemsetD32](crate::ffi::cuMemsetD32), [cuMemsetD32Async](crate::ffi::cuMemsetD32Async),\n [cudaMemset2DAsync](crate::ffi::cudaMemset2DAsync)\n"]
    pub fn cuMemsetD2D32Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::std::ffi::c_uint,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a 1D or 2D CUDA array\n\n Creates a CUDA array according to the [CUDA_ARRAY_DESCRIPTOR](crate::ffi::CUDA_ARRAY_DESCRIPTOR) structure\n `pAllocateArray` and returns a handle to the new CUDA array in `*pHandle`.\n The [CUDA_ARRAY_DESCRIPTOR](crate::ffi::CUDA_ARRAY_DESCRIPTOR) is defined as:\n\n \\code\ntypedef struct {\nunsigned int Width;\nunsigned int Height;\nCUarray_format Format;\nunsigned int NumChannels;\n} CUDA_ARRAY_DESCRIPTOR;\n \\endcode\n where:\n\n - `Width`, and `Height` are the width, and height of the CUDA array (in\n elements); the CUDA array is one-dimensional if height is 0, two-dimensional\n otherwise;\n - [Format](crate::ffi::Format) specifies the format of the elements; [CUarray_format](crate::ffi::CUarray_format) is\n defined as:\n \\code\ntypedef enum CUarray_format_enum {\nCU_AD_FORMAT_UNSIGNED_INT8 = 0x01,\nCU_AD_FORMAT_UNSIGNED_INT16 = 0x02,\nCU_AD_FORMAT_UNSIGNED_INT32 = 0x03,\nCU_AD_FORMAT_SIGNED_INT8 = 0x08,\nCU_AD_FORMAT_SIGNED_INT16 = 0x09,\nCU_AD_FORMAT_SIGNED_INT32 = 0x0a,\nCU_AD_FORMAT_HALF = 0x10,\nCU_AD_FORMAT_FLOAT = 0x20,\nCU_AD_FORMAT_NV12 = 0xb0,\nCU_AD_FORMAT_UNORM_INT8X1 = 0xc0,\nCU_AD_FORMAT_UNORM_INT8X2 = 0xc1,\nCU_AD_FORMAT_UNORM_INT8X4 = 0xc2,\nCU_AD_FORMAT_UNORM_INT16X1 = 0xc3,\nCU_AD_FORMAT_UNORM_INT16X2 = 0xc4,\nCU_AD_FORMAT_UNORM_INT16X4 = 0xc5,\nCU_AD_FORMAT_SNORM_INT8X1 = 0xc6,\nCU_AD_FORMAT_SNORM_INT8X2 = 0xc7,\nCU_AD_FORMAT_SNORM_INT8X4 = 0xc8,\nCU_AD_FORMAT_SNORM_INT16X1 = 0xc9,\nCU_AD_FORMAT_SNORM_INT16X2 = 0xca,\nCU_AD_FORMAT_SNORM_INT16X4 = 0xcb,\nCU_AD_FORMAT_BC1_UNORM = 0x91,\nCU_AD_FORMAT_BC1_UNORM_SRGB = 0x92,\nCU_AD_FORMAT_BC2_UNORM = 0x93,\nCU_AD_FORMAT_BC2_UNORM_SRGB = 0x94,\nCU_AD_FORMAT_BC3_UNORM = 0x95,\nCU_AD_FORMAT_BC3_UNORM_SRGB = 0x96,\nCU_AD_FORMAT_BC4_UNORM = 0x97,\nCU_AD_FORMAT_BC4_SNORM = 0x98,\nCU_AD_FORMAT_BC5_UNORM = 0x99,\nCU_AD_FORMAT_BC5_SNORM = 0x9a,\nCU_AD_FORMAT_BC6H_UF16 = 0x9b,\nCU_AD_FORMAT_BC6H_SF16 = 0x9c,\nCU_AD_FORMAT_BC7_UNORM = 0x9d,\nCU_AD_FORMAT_BC7_UNORM_SRGB = 0x9e,\nCU_AD_FORMAT_P010 = 0x9f,\nCU_AD_FORMAT_P016 = 0xa1,\nCU_AD_FORMAT_NV16 = 0xa2,\nCU_AD_FORMAT_P210 = 0xa3,\nCU_AD_FORMAT_P216 = 0xa4,\nCU_AD_FORMAT_YUY2 = 0xa5,\nCU_AD_FORMAT_Y210 = 0xa6,\nCU_AD_FORMAT_Y216 = 0xa7,\nCU_AD_FORMAT_AYUV = 0xa8,\nCU_AD_FORMAT_Y410 = 0xa9,\nCU_AD_FORMAT_Y416 = 0xb1,\nCU_AD_FORMAT_Y444_PLANAR8 = 0xb2,\nCU_AD_FORMAT_Y444_PLANAR10 = 0xb3,\nCU_AD_FORMAT_YUV444_8bit_SemiPlanar = 0xb4,\nCU_AD_FORMAT_YUV444_16bit_SemiPlanar = 0xb5,\nCU_AD_FORMAT_UNORM_INT_101010_2 = 0x50,\n} CUarray_format;\n  \\endcode\n - `NumChannels` specifies the number of packed components per CUDA array\n element; it may be 1, 2, or 4;\n\n Here are examples of CUDA array descriptions:\n\n Description for a CUDA array of 2048 floats:\n \\code\nCUDA_ARRAY_DESCRIPTOR desc;\ndesc.Format = CU_AD_FORMAT_FLOAT;\ndesc.NumChannels = 1;\ndesc.Width = 2048;\ndesc.Height = 1;\n \\endcode\n\n Description for a 64 x 64 CUDA array of floats:\n \\code\nCUDA_ARRAY_DESCRIPTOR desc;\ndesc.Format = CU_AD_FORMAT_FLOAT;\ndesc.NumChannels = 1;\ndesc.Width = 64;\ndesc.Height = 64;\n \\endcode\n\n Description for a `width` x `height` CUDA array of 64-bit, 4x16-bit\n float16's:\n \\code\nCUDA_ARRAY_DESCRIPTOR desc;\ndesc.Format = CU_AD_FORMAT_HALF;\ndesc.NumChannels = 4;\ndesc.Width = width;\ndesc.Height = height;\n \\endcode\n\n Description for a `width` x `height` CUDA array of 16-bit elements, each\n of which is two 8-bit unsigned chars:\n \\code\nCUDA_ARRAY_DESCRIPTOR arrayDesc;\ndesc.Format = CU_AD_FORMAT_UNSIGNED_INT8;\ndesc.NumChannels = 2;\ndesc.Width = width;\ndesc.Height = height;\n \\endcode\n#### pHandle:\n- Returned array\n#### pAllocateArray:\n- Array descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMallocArray](crate::ffi::cudaMallocArray)\n"]
    pub fn cuArrayCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get a 1D or 2D CUDA array descriptor\n\n Returns in `*pArrayDescriptor` a descriptor containing information on the\n format and dimensions of the CUDA array `hArray`. It is useful for\n subroutines that have been passed a CUDA array, but need to know the CUDA\n array parameters for validation or other purposes.\n#### pArrayDescriptor:\n- Returned array descriptor\n#### hArray:\n- Array to get descriptor of\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaArrayGetInfo](crate::ffi::cudaArrayGetInfo)\n"]
    pub fn cuArrayGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the layout properties of a sparse CUDA array\n\n Returns the layout properties of a sparse CUDA array in `sparseProperties`\n If the CUDA array is not allocated with flag [CUDA_ARRAY3D_SPARSE](crate::ffi::CUDA_ARRAY3D_SPARSE)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned.\n\n If the returned value in [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[flags](crate::ffi::flags) contains [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](crate::ffi::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL),\n then [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[miptailSize](crate::ffi::miptailSize) represents the total size of the array. Otherwise, it will be zero.\n Also, the returned value in [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[miptailFirstLevel](crate::ffi::miptailFirstLevel) is always zero.\n Note that the `array` must have been allocated using [cuArrayCreate](crate::ffi::cuArrayCreate) or [cuArray3DCreate](crate::ffi::cuArray3DCreate). For CUDA arrays obtained\n using [cuMipmappedArrayGetLevel](crate::ffi::cuMipmappedArrayGetLevel), [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned. Instead, [cuMipmappedArrayGetSparseProperties](crate::ffi::cuMipmappedArrayGetSparseProperties)\n must be used to obtain the sparse properties of the entire CUDA mipmapped array to which `array` belongs to.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n `aram`[out] sparseProperties - Pointer to [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)\n `aram`[in] array - CUDA array to get the sparse properties of\n ### See also:\n [cuMipmappedArrayGetSparseProperties](crate::ffi::cuMipmappedArrayGetSparseProperties), [cuMemMapArrayAsync](crate::ffi::cuMemMapArrayAsync)\n"]
    pub fn cuArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        array: CUarray,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the layout properties of a sparse CUDA mipmapped array\n\n Returns the sparse array layout properties in `sparseProperties`\n If the CUDA mipmapped array is not allocated with flag [CUDA_ARRAY3D_SPARSE](crate::ffi::CUDA_ARRAY3D_SPARSE)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned.\n\n For non-layered CUDA mipmapped arrays, [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[miptailSize](crate::ffi::miptailSize) returns the\n size of the mip tail region. The mip tail region includes all mip levels whose width, height or depth\n is less than that of the tile.\n For layered CUDA mipmapped arrays, if [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[flags](crate::ffi::flags) contains [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](crate::ffi::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL),\n then [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[miptailSize](crate::ffi::miptailSize) specifies the size of the mip tail of all layers combined.\n Otherwise, [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[miptailSize](crate::ffi::miptailSize) specifies mip tail size per layer.\n The returned value of [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[miptailFirstLevel](crate::ffi::miptailFirstLevel) is valid only if [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[miptailSize](crate::ffi::miptailSize) is non-zero.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n `aram`[out] sparseProperties - Pointer to [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)\n `aram`[in] mipmap - CUDA mipmapped array to get the sparse properties of\n ### See also:\n [cuArrayGetSparseProperties](crate::ffi::cuArrayGetSparseProperties), [cuMemMapArrayAsync](crate::ffi::cuMemMapArrayAsync)\n"]
    pub fn cuMipmappedArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        mipmap: CUmipmappedArray,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the memory requirements of a CUDA array\n\n Returns the memory requirements of a CUDA array in `memoryRequirements`\n If the CUDA array is not allocated with flag [CUDA_ARRAY3D_DEFERRED_MAPPING](crate::ffi::CUDA_ARRAY3D_DEFERRED_MAPPING)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned.\n\n The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS](crate::ffi::CUDA_ARRAY_MEMORY_REQUIREMENTS)[size](crate::ffi::size)\n represents the total size of the CUDA array.\n The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS](crate::ffi::CUDA_ARRAY_MEMORY_REQUIREMENTS)[alignment](crate::ffi::alignment)\n represents the alignment necessary for mapping the CUDA array.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n `aram`[out] memoryRequirements - Pointer to [CUDA_ARRAY_MEMORY_REQUIREMENTS](crate::ffi::CUDA_ARRAY_MEMORY_REQUIREMENTS)\n `aram`[in] array - CUDA array to get the memory requirements of\n `aram`[in] device - Device to get the memory requirements for\n ### See also:\n [cuMipmappedArrayGetMemoryRequirements](crate::ffi::cuMipmappedArrayGetMemoryRequirements), [cuMemMapArrayAsync](crate::ffi::cuMemMapArrayAsync)\n"]
    pub fn cuArrayGetMemoryRequirements(
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        array: CUarray,
        device: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the memory requirements of a CUDA mipmapped array\n\n Returns the memory requirements of a CUDA mipmapped array in `memoryRequirements`\n If the CUDA mipmapped array is not allocated with flag [CUDA_ARRAY3D_DEFERRED_MAPPING](crate::ffi::CUDA_ARRAY3D_DEFERRED_MAPPING)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned.\n\n The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS](crate::ffi::CUDA_ARRAY_MEMORY_REQUIREMENTS)[size](crate::ffi::size)\n represents the total size of the CUDA mipmapped array.\n The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS](crate::ffi::CUDA_ARRAY_MEMORY_REQUIREMENTS)[alignment](crate::ffi::alignment)\n represents the alignment necessary for mapping the CUDA mipmapped\n array.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n `aram`[out] memoryRequirements - Pointer to [CUDA_ARRAY_MEMORY_REQUIREMENTS](crate::ffi::CUDA_ARRAY_MEMORY_REQUIREMENTS)\n `aram`[in] mipmap - CUDA mipmapped array to get the memory requirements of\n `aram`[in] device - Device to get the memory requirements for\n ### See also:\n [cuArrayGetMemoryRequirements](crate::ffi::cuArrayGetMemoryRequirements), [cuMemMapArrayAsync](crate::ffi::cuMemMapArrayAsync)\n"]
    pub fn cuMipmappedArrayGetMemoryRequirements(
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        mipmap: CUmipmappedArray,
        device: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets a CUDA array plane from a CUDA array\n\n Returns in `pPlaneArray` a CUDA array that represents a single format plane\n of the CUDA array `hArray`.\n\n If `planeIdx` is greater than the maximum number of planes in this array or if the array does\n not have a multi-planar format e.g: [CU_AD_FORMAT_NV12](crate::ffi::CU_AD_FORMAT_NV12), then [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n Note that if the `hArray` has format [CU_AD_FORMAT_NV12](crate::ffi::CU_AD_FORMAT_NV12), then passing in 0 for `planeIdx` returns\n a CUDA array of the same size as `hArray` but with one channel and [CU_AD_FORMAT_UNSIGNED_INT8](crate::ffi::CU_AD_FORMAT_UNSIGNED_INT8) as its format.\n If 1 is passed for `planeIdx`, then the returned CUDA array has half the height and width\n of `hArray` with two channels and [CU_AD_FORMAT_UNSIGNED_INT8](crate::ffi::CU_AD_FORMAT_UNSIGNED_INT8) as its format.\n#### pPlaneArray:\n- Returned CUDA array referenced by the `planeIdx`\n#### hArray:\n- Multiplanar CUDA array\n#### planeIdx:\n- Plane index\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cudaArrayGetPlane](crate::ffi::cudaArrayGetPlane)\n"]
    pub fn cuArrayGetPlane(
        pPlaneArray: *mut CUarray,
        hArray: CUarray,
        planeIdx: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a CUDA array\n\n Destroys the CUDA array `hArray`.\n#### hArray:\n- Array to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_ARRAY_IS_MAPPED](crate::ffi::CUDA_ERROR_ARRAY_IS_MAPPED),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaFreeArray](crate::ffi::cudaFreeArray)\n"]
    pub fn cuArrayDestroy(hArray: CUarray) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a 3D CUDA array\n\n Creates a CUDA array according to the [CUDA_ARRAY3D_DESCRIPTOR](crate::ffi::CUDA_ARRAY3D_DESCRIPTOR) structure\n `pAllocateArray` and returns a handle to the new CUDA array in `*pHandle`.\n The [CUDA_ARRAY3D_DESCRIPTOR](crate::ffi::CUDA_ARRAY3D_DESCRIPTOR) is defined as:\n\n \\code\ntypedef struct {\nunsigned int Width;\nunsigned int Height;\nunsigned int Depth;\nCUarray_format Format;\nunsigned int NumChannels;\nunsigned int Flags;\n} CUDA_ARRAY3D_DESCRIPTOR;\n \\endcode\n where:\n\n - `Width`, `Height`, and `Depth` are the width, height, and depth of the\n CUDA array (in elements); the following types of CUDA arrays can be allocated:\n     - A 1D array is allocated if `Height` and `Depth` extents are both zero.\n     - A 2D array is allocated if only `Depth` extent is zero.\n     - A 3D array is allocated if all three extents are non-zero.\n     - A 1D layered CUDA array is allocated if only `Height` is zero and the\n       [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flag is set. Each layer is a 1D array. The number\n       of layers is determined by the depth extent.\n     - A 2D layered CUDA array is allocated if all three extents are non-zero and\n       the [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flag is set. Each layer is a 2D array. The number\n       of layers is determined by the depth extent.\n     - A cubemap CUDA array is allocated if all three extents are non-zero and the\n       [CUDA_ARRAY3D_CUBEMAP](crate::ffi::CUDA_ARRAY3D_CUBEMAP) flag is set. `Width` must be equal to `Height`, and\n       `Depth` must be six. A cubemap is a special type of 2D layered CUDA array,\n       where the six layers represent the six faces of a cube. The order of the six\n       layers in memory is the same as that listed in [CUarray_cubemap_face](crate::ffi::CUarray_cubemap_face).\n     - A cubemap layered CUDA array is allocated if all three extents are non-zero,\n       and both, [CUDA_ARRAY3D_CUBEMAP](crate::ffi::CUDA_ARRAY3D_CUBEMAP) and [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flags are set.\n       `Width` must be equal to `Height`, and `Depth` must be a multiple of six.\n       A cubemap layered CUDA array is a special type of 2D layered CUDA array that\n       consists of a collection of cubemaps. The first six layers represent the first\n       cubemap, the next six layers form the second cubemap, and so on.\n\n - [Format](crate::ffi::Format) specifies the format of the elements; [CUarray_format](crate::ffi::CUarray_format) is\n defined as:\n \\code\ntypedef enum CUarray_format_enum {\nCU_AD_FORMAT_UNSIGNED_INT8 = 0x01,\nCU_AD_FORMAT_UNSIGNED_INT16 = 0x02,\nCU_AD_FORMAT_UNSIGNED_INT32 = 0x03,\nCU_AD_FORMAT_SIGNED_INT8 = 0x08,\nCU_AD_FORMAT_SIGNED_INT16 = 0x09,\nCU_AD_FORMAT_SIGNED_INT32 = 0x0a,\nCU_AD_FORMAT_HALF = 0x10,\nCU_AD_FORMAT_FLOAT = 0x20,\nCU_AD_FORMAT_NV12 = 0xb0,\nCU_AD_FORMAT_UNORM_INT8X1 = 0xc0,\nCU_AD_FORMAT_UNORM_INT8X2 = 0xc1,\nCU_AD_FORMAT_UNORM_INT8X4 = 0xc2,\nCU_AD_FORMAT_UNORM_INT16X1 = 0xc3,\nCU_AD_FORMAT_UNORM_INT16X2 = 0xc4,\nCU_AD_FORMAT_UNORM_INT16X4 = 0xc5,\nCU_AD_FORMAT_SNORM_INT8X1 = 0xc6,\nCU_AD_FORMAT_SNORM_INT8X2 = 0xc7,\nCU_AD_FORMAT_SNORM_INT8X4 = 0xc8,\nCU_AD_FORMAT_SNORM_INT16X1 = 0xc9,\nCU_AD_FORMAT_SNORM_INT16X2 = 0xca,\nCU_AD_FORMAT_SNORM_INT16X4 = 0xcb,\nCU_AD_FORMAT_BC1_UNORM = 0x91,\nCU_AD_FORMAT_BC1_UNORM_SRGB = 0x92,\nCU_AD_FORMAT_BC2_UNORM = 0x93,\nCU_AD_FORMAT_BC2_UNORM_SRGB = 0x94,\nCU_AD_FORMAT_BC3_UNORM = 0x95,\nCU_AD_FORMAT_BC3_UNORM_SRGB = 0x96,\nCU_AD_FORMAT_BC4_UNORM = 0x97,\nCU_AD_FORMAT_BC4_SNORM = 0x98,\nCU_AD_FORMAT_BC5_UNORM = 0x99,\nCU_AD_FORMAT_BC5_SNORM = 0x9a,\nCU_AD_FORMAT_BC6H_UF16 = 0x9b,\nCU_AD_FORMAT_BC6H_SF16 = 0x9c,\nCU_AD_FORMAT_BC7_UNORM = 0x9d,\nCU_AD_FORMAT_BC7_UNORM_SRGB = 0x9e,\nCU_AD_FORMAT_P010 = 0x9f,\nCU_AD_FORMAT_P016 = 0xa1,\nCU_AD_FORMAT_NV16 = 0xa2,\nCU_AD_FORMAT_P210 = 0xa3,\nCU_AD_FORMAT_P216 = 0xa4,\nCU_AD_FORMAT_YUY2 = 0xa5,\nCU_AD_FORMAT_Y210 = 0xa6,\nCU_AD_FORMAT_Y216 = 0xa7,\nCU_AD_FORMAT_AYUV = 0xa8,\nCU_AD_FORMAT_Y410 = 0xa9,\nCU_AD_FORMAT_Y416 = 0xb1,\nCU_AD_FORMAT_Y444_PLANAR8 = 0xb2,\nCU_AD_FORMAT_Y444_PLANAR10 = 0xb3,\nCU_AD_FORMAT_YUV444_8bit_SemiPlanar = 0xb4,\nCU_AD_FORMAT_YUV444_16bit_SemiPlanar = 0xb5,\nCU_AD_FORMAT_UNORM_INT_101010_2 = 0x50,\n} CUarray_format;\n  \\endcode\n\n - `NumChannels` specifies the number of packed components per CUDA array\n element; it may be 1, 2, or 4;\n\n - [Flags](crate::ffi::Flags) may be set to\n   - [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) to enable creation of layered CUDA arrays. If this flag is set,\n     `Depth` specifies the number of layers, not the depth of a 3D array.\n   - [CUDA_ARRAY3D_SURFACE_LDST](crate::ffi::CUDA_ARRAY3D_SURFACE_LDST) to enable surface references to be bound to the CUDA array.\n     If this flag is not set, [cuSurfRefSetArray](crate::ffi::cuSurfRefSetArray) will fail when attempting to bind the CUDA array\n     to a surface reference.\n   - [CUDA_ARRAY3D_CUBEMAP](crate::ffi::CUDA_ARRAY3D_CUBEMAP) to enable creation of cubemaps. If this flag is set, `Width` must be\n     equal to `Height`, and `Depth` must be six. If the [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flag is also set,\n     then `Depth` must be a multiple of six.\n   - [CUDA_ARRAY3D_TEXTURE_GATHER](crate::ffi::CUDA_ARRAY3D_TEXTURE_GATHER) to indicate that the CUDA array will be used for texture gather.\n     Texture gather can only be performed on 2D CUDA arrays.\n\n `Width`, `Height` and `Depth` must meet certain size requirements as listed in the following table.\n All values are specified in elements. Note that for brevity's sake, the full name of the device attribute\n is not specified. For ex., TEXTURE1D_WIDTH refers to the device attribute\n [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH).\n\n Note that 2D CUDA arrays have different size requirements if the [CUDA_ARRAY3D_TEXTURE_GATHER](crate::ffi::CUDA_ARRAY3D_TEXTURE_GATHER) flag\n is set. `Width` and `Height` must not be greater than [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH)\n and [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT) respectively, in that case.\n\n <table>\n <tr><td><b>CUDA array type</b></td>\n <td><b>Valid extents that must always be met<br>{(width range in elements), (height range),\n (depth range)}</b></td>\n <td><b>Valid extents with CUDA_ARRAY3D_SURFACE_LDST set<br>\n {(width range in elements), (height range), (depth range)}</b></td></tr>\n <tr><td>1D</td>\n <td><small>{ (1,TEXTURE1D_WIDTH), 0, 0 }</small></td>\n <td><small>{ (1,SURFACE1D_WIDTH), 0, 0 }</small></td></tr>\n <tr><td>2D</td>\n <td><small>{ (1,TEXTURE2D_WIDTH), (1,TEXTURE2D_HEIGHT), 0 }</small></td>\n <td><small>{ (1,SURFACE2D_WIDTH), (1,SURFACE2D_HEIGHT), 0 }</small></td></tr>\n <tr><td>3D</td>\n <td><small>{ (1,TEXTURE3D_WIDTH), (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) }\n <br>OR<br>{ (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE),\n (1,TEXTURE3D_DEPTH_ALTERNATE) }</small></td>\n <td><small>{ (1,SURFACE3D_WIDTH), (1,SURFACE3D_HEIGHT),\n (1,SURFACE3D_DEPTH) }</small></td></tr>\n <tr><td>1D Layered</td>\n <td><small>{ (1,TEXTURE1D_LAYERED_WIDTH), 0,\n (1,TEXTURE1D_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACE1D_LAYERED_WIDTH), 0,\n (1,SURFACE1D_LAYERED_LAYERS) }</small></td></tr>\n <tr><td>2D Layered</td>\n <td><small>{ (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT),\n (1,TEXTURE2D_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACE2D_LAYERED_WIDTH), (1,SURFACE2D_LAYERED_HEIGHT),\n (1,SURFACE2D_LAYERED_LAYERS) }</small></td></tr>\n <tr><td>Cubemap</td>\n <td><small>{ (1,TEXTURECUBEMAP_WIDTH), (1,TEXTURECUBEMAP_WIDTH), 6 }</small></td>\n <td><small>{ (1,SURFACECUBEMAP_WIDTH),\n (1,SURFACECUBEMAP_WIDTH), 6 }</small></td></tr>\n <tr><td>Cubemap Layered</td>\n <td><small>{ (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH),\n (1,TEXTURECUBEMAP_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_WIDTH),\n (1,SURFACECUBEMAP_LAYERED_LAYERS) }</small></td></tr>\n </table>\n\n Here are examples of CUDA array descriptions:\n\n Description for a CUDA array of 2048 floats:\n \\code\nCUDA_ARRAY3D_DESCRIPTOR desc;\ndesc.Format = CU_AD_FORMAT_FLOAT;\ndesc.NumChannels = 1;\ndesc.Width = 2048;\ndesc.Height = 0;\ndesc.Depth = 0;\n \\endcode\n\n Description for a 64 x 64 CUDA array of floats:\n \\code\nCUDA_ARRAY3D_DESCRIPTOR desc;\ndesc.Format = CU_AD_FORMAT_FLOAT;\ndesc.NumChannels = 1;\ndesc.Width = 64;\ndesc.Height = 64;\ndesc.Depth = 0;\n \\endcode\n\n Description for a `width` x `height` x `depth` CUDA array of 64-bit,\n 4x16-bit float16's:\n \\code\nCUDA_ARRAY3D_DESCRIPTOR desc;\ndesc.Format = CU_AD_FORMAT_HALF;\ndesc.NumChannels = 4;\ndesc.Width = width;\ndesc.Height = height;\ndesc.Depth = depth;\n \\endcode\n#### pHandle:\n- Returned array\n#### pAllocateArray:\n- 3D array descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DGetDescriptor](crate::ffi::cuArray3DGetDescriptor), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaMalloc3DArray](crate::ffi::cudaMalloc3DArray)\n"]
    pub fn cuArray3DCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get a 3D CUDA array descriptor\n\n Returns in `*pArrayDescriptor` a descriptor containing information on the\n format and dimensions of the CUDA array `hArray`. It is useful for\n subroutines that have been passed a CUDA array, but need to know the CUDA\n array parameters for validation or other purposes.\n\n This function may be called on 1D and 2D arrays, in which case the `Height`\n and/or `Depth` members of the descriptor struct will be set to 0.\n#### pArrayDescriptor:\n- Returned 3D array descriptor\n#### hArray:\n- 3D array to get descriptor of\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cuArrayDestroy](crate::ffi::cuArrayDestroy), [cuArrayGetDescriptor](crate::ffi::cuArrayGetDescriptor), [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemAllocPitch](crate::ffi::cuMemAllocPitch), [cuMemcpy2D](crate::ffi::cuMemcpy2D), [cuMemcpy2DAsync](crate::ffi::cuMemcpy2DAsync), [cuMemcpy2DUnaligned](crate::ffi::cuMemcpy2DUnaligned),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D), [cuMemcpy3DAsync](crate::ffi::cuMemcpy3DAsync), [cuMemcpyAtoA](crate::ffi::cuMemcpyAtoA), [cuMemcpyAtoD](crate::ffi::cuMemcpyAtoD),\n [cuMemcpyAtoH](crate::ffi::cuMemcpyAtoH), [cuMemcpyAtoHAsync](crate::ffi::cuMemcpyAtoHAsync), [cuMemcpyDtoA](crate::ffi::cuMemcpyDtoA), [cuMemcpyDtoD](crate::ffi::cuMemcpyDtoD), [cuMemcpyDtoDAsync](crate::ffi::cuMemcpyDtoDAsync),\n [cuMemcpyDtoH](crate::ffi::cuMemcpyDtoH), [cuMemcpyDtoHAsync](crate::ffi::cuMemcpyDtoHAsync), [cuMemcpyHtoA](crate::ffi::cuMemcpyHtoA), [cuMemcpyHtoAAsync](crate::ffi::cuMemcpyHtoAAsync),\n [cuMemcpyHtoD](crate::ffi::cuMemcpyHtoD), [cuMemcpyHtoDAsync](crate::ffi::cuMemcpyHtoDAsync), [cuMemFree](crate::ffi::cuMemFree), [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange), [cuMemGetInfo](crate::ffi::cuMemGetInfo), [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer), [cuMemsetD2D8](crate::ffi::cuMemsetD2D8), [cuMemsetD2D16](crate::ffi::cuMemsetD2D16),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32), [cuMemsetD8](crate::ffi::cuMemsetD8), [cuMemsetD16](crate::ffi::cuMemsetD16), [cuMemsetD32](crate::ffi::cuMemsetD32),\n [cudaArrayGetInfo](crate::ffi::cudaArrayGetInfo)\n"]
    pub fn cuArray3DGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY3D_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a CUDA mipmapped array\n\n Creates a CUDA mipmapped array according to the [CUDA_ARRAY3D_DESCRIPTOR](crate::ffi::CUDA_ARRAY3D_DESCRIPTOR) structure\n `pMipmappedArrayDesc` and returns a handle to the new CUDA mipmapped array in `*pHandle`.\n `numMipmapLevels` specifies the number of mipmap levels to be allocated. This value is\n clamped to the range [1, 1 + floor(log2(max(width, height, depth)))].\n\n The [CUDA_ARRAY3D_DESCRIPTOR](crate::ffi::CUDA_ARRAY3D_DESCRIPTOR) is defined as:\n\n \\code\ntypedef struct {\nunsigned int Width;\nunsigned int Height;\nunsigned int Depth;\nCUarray_format Format;\nunsigned int NumChannels;\nunsigned int Flags;\n} CUDA_ARRAY3D_DESCRIPTOR;\n \\endcode\n where:\n\n - `Width`, `Height`, and `Depth` are the width, height, and depth of the\n CUDA array (in elements); the following types of CUDA arrays can be allocated:\n     - A 1D mipmapped array is allocated if `Height` and `Depth` extents are both zero.\n     - A 2D mipmapped array is allocated if only `Depth` extent is zero.\n     - A 3D mipmapped array is allocated if all three extents are non-zero.\n     - A 1D layered CUDA mipmapped array is allocated if only `Height` is zero and the\n       [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flag is set. Each layer is a 1D array. The number\n       of layers is determined by the depth extent.\n     - A 2D layered CUDA mipmapped array is allocated if all three extents are non-zero and\n       the [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flag is set. Each layer is a 2D array. The number\n       of layers is determined by the depth extent.\n     - A cubemap CUDA mipmapped array is allocated if all three extents are non-zero and the\n       [CUDA_ARRAY3D_CUBEMAP](crate::ffi::CUDA_ARRAY3D_CUBEMAP) flag is set. `Width` must be equal to `Height`, and\n       `Depth` must be six. A cubemap is a special type of 2D layered CUDA array,\n       where the six layers represent the six faces of a cube. The order of the six\n       layers in memory is the same as that listed in [CUarray_cubemap_face](crate::ffi::CUarray_cubemap_face).\n     - A cubemap layered CUDA mipmapped array is allocated if all three extents are non-zero,\n       and both, [CUDA_ARRAY3D_CUBEMAP](crate::ffi::CUDA_ARRAY3D_CUBEMAP) and [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flags are set.\n       `Width` must be equal to `Height`, and `Depth` must be a multiple of six.\n       A cubemap layered CUDA array is a special type of 2D layered CUDA array that\n       consists of a collection of cubemaps. The first six layers represent the first\n       cubemap, the next six layers form the second cubemap, and so on.\n\n - [Format](crate::ffi::Format) specifies the format of the elements; [CUarray_format](crate::ffi::CUarray_format) is\n defined as:\n \\code\ntypedef enum CUarray_format_enum {\nCU_AD_FORMAT_UNSIGNED_INT8 = 0x01,\nCU_AD_FORMAT_UNSIGNED_INT16 = 0x02,\nCU_AD_FORMAT_UNSIGNED_INT32 = 0x03,\nCU_AD_FORMAT_SIGNED_INT8 = 0x08,\nCU_AD_FORMAT_SIGNED_INT16 = 0x09,\nCU_AD_FORMAT_SIGNED_INT32 = 0x0a,\nCU_AD_FORMAT_HALF = 0x10,\nCU_AD_FORMAT_FLOAT = 0x20,\nCU_AD_FORMAT_NV12 = 0xb0,\nCU_AD_FORMAT_UNORM_INT8X1 = 0xc0,\nCU_AD_FORMAT_UNORM_INT8X2 = 0xc1,\nCU_AD_FORMAT_UNORM_INT8X4 = 0xc2,\nCU_AD_FORMAT_UNORM_INT16X1 = 0xc3,\nCU_AD_FORMAT_UNORM_INT16X2 = 0xc4,\nCU_AD_FORMAT_UNORM_INT16X4 = 0xc5,\nCU_AD_FORMAT_SNORM_INT8X1 = 0xc6,\nCU_AD_FORMAT_SNORM_INT8X2 = 0xc7,\nCU_AD_FORMAT_SNORM_INT8X4 = 0xc8,\nCU_AD_FORMAT_SNORM_INT16X1 = 0xc9,\nCU_AD_FORMAT_SNORM_INT16X2 = 0xca,\nCU_AD_FORMAT_SNORM_INT16X4 = 0xcb,\nCU_AD_FORMAT_BC1_UNORM = 0x91,\nCU_AD_FORMAT_BC1_UNORM_SRGB = 0x92,\nCU_AD_FORMAT_BC2_UNORM = 0x93,\nCU_AD_FORMAT_BC2_UNORM_SRGB = 0x94,\nCU_AD_FORMAT_BC3_UNORM = 0x95,\nCU_AD_FORMAT_BC3_UNORM_SRGB = 0x96,\nCU_AD_FORMAT_BC4_UNORM = 0x97,\nCU_AD_FORMAT_BC4_SNORM = 0x98,\nCU_AD_FORMAT_BC5_UNORM = 0x99,\nCU_AD_FORMAT_BC5_SNORM = 0x9a,\nCU_AD_FORMAT_BC6H_UF16 = 0x9b,\nCU_AD_FORMAT_BC6H_SF16 = 0x9c,\nCU_AD_FORMAT_BC7_UNORM = 0x9d,\nCU_AD_FORMAT_BC7_UNORM_SRGB = 0x9e,\nCU_AD_FORMAT_P010 = 0x9f,\nCU_AD_FORMAT_P016 = 0xa1,\nCU_AD_FORMAT_NV16 = 0xa2,\nCU_AD_FORMAT_P210 = 0xa3,\nCU_AD_FORMAT_P216 = 0xa4,\nCU_AD_FORMAT_YUY2 = 0xa5,\nCU_AD_FORMAT_Y210 = 0xa6,\nCU_AD_FORMAT_Y216 = 0xa7,\nCU_AD_FORMAT_AYUV = 0xa8,\nCU_AD_FORMAT_Y410 = 0xa9,\nCU_AD_FORMAT_Y416 = 0xb1,\nCU_AD_FORMAT_Y444_PLANAR8 = 0xb2,\nCU_AD_FORMAT_Y444_PLANAR10 = 0xb3,\nCU_AD_FORMAT_YUV444_8bit_SemiPlanar = 0xb4,\nCU_AD_FORMAT_YUV444_16bit_SemiPlanar = 0xb5,\nCU_AD_FORMAT_UNORM_INT_101010_2 = 0x50,\n} CUarray_format;\n  \\endcode\n\n - `NumChannels` specifies the number of packed components per CUDA array\n element; it may be 1, 2, or 4;\n\n - [Flags](crate::ffi::Flags) may be set to\n   - [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) to enable creation of layered CUDA mipmapped arrays. If this flag is set,\n     `Depth` specifies the number of layers, not the depth of a 3D array.\n   - [CUDA_ARRAY3D_SURFACE_LDST](crate::ffi::CUDA_ARRAY3D_SURFACE_LDST) to enable surface references to be bound to individual mipmap levels of\n     the CUDA mipmapped array. If this flag is not set, [cuSurfRefSetArray](crate::ffi::cuSurfRefSetArray) will fail when attempting to\n     bind a mipmap level of the CUDA mipmapped array to a surface reference.\n   - [CUDA_ARRAY3D_CUBEMAP](crate::ffi::CUDA_ARRAY3D_CUBEMAP) to enable creation of mipmapped cubemaps. If this flag is set, `Width` must be\n     equal to `Height`, and `Depth` must be six. If the [CUDA_ARRAY3D_LAYERED](crate::ffi::CUDA_ARRAY3D_LAYERED) flag is also set,\n     then `Depth` must be a multiple of six.\n   - [CUDA_ARRAY3D_TEXTURE_GATHER](crate::ffi::CUDA_ARRAY3D_TEXTURE_GATHER) to indicate that the CUDA mipmapped array will be used for texture gather.\n     Texture gather can only be performed on 2D CUDA mipmapped arrays.\n\n `Width`, `Height` and `Depth` must meet certain size requirements as listed in the following table.\n All values are specified in elements. Note that for brevity's sake, the full name of the device attribute\n is not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH refers to the device attribute\n [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH).\n\n <table>\n <tr><td><b>CUDA array type</b></td>\n <td><b>Valid extents that must always be met<br>{(width range in elements), (height range),\n (depth range)}</b></td>\n <td><b>Valid extents with CUDA_ARRAY3D_SURFACE_LDST set<br>\n {(width range in elements), (height range), (depth range)}</b></td></tr>\n <tr><td>1D</td>\n <td><small>{ (1,TEXTURE1D_MIPMAPPED_WIDTH), 0, 0 }</small></td>\n <td><small>{ (1,SURFACE1D_WIDTH), 0, 0 }</small></td></tr>\n <tr><td>2D</td>\n <td><small>{ (1,TEXTURE2D_MIPMAPPED_WIDTH), (1,TEXTURE2D_MIPMAPPED_HEIGHT), 0 }</small></td>\n <td><small>{ (1,SURFACE2D_WIDTH), (1,SURFACE2D_HEIGHT), 0 }</small></td></tr>\n <tr><td>3D</td>\n <td><small>{ (1,TEXTURE3D_WIDTH), (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) }\n <br>OR<br>{ (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE),\n (1,TEXTURE3D_DEPTH_ALTERNATE) }</small></td>\n <td><small>{ (1,SURFACE3D_WIDTH), (1,SURFACE3D_HEIGHT),\n (1,SURFACE3D_DEPTH) }</small></td></tr>\n <tr><td>1D Layered</td>\n <td><small>{ (1,TEXTURE1D_LAYERED_WIDTH), 0,\n (1,TEXTURE1D_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACE1D_LAYERED_WIDTH), 0,\n (1,SURFACE1D_LAYERED_LAYERS) }</small></td></tr>\n <tr><td>2D Layered</td>\n <td><small>{ (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT),\n (1,TEXTURE2D_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACE2D_LAYERED_WIDTH), (1,SURFACE2D_LAYERED_HEIGHT),\n (1,SURFACE2D_LAYERED_LAYERS) }</small></td></tr>\n <tr><td>Cubemap</td>\n <td><small>{ (1,TEXTURECUBEMAP_WIDTH), (1,TEXTURECUBEMAP_WIDTH), 6 }</small></td>\n <td><small>{ (1,SURFACECUBEMAP_WIDTH),\n (1,SURFACECUBEMAP_WIDTH), 6 }</small></td></tr>\n <tr><td>Cubemap Layered</td>\n <td><small>{ (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH),\n (1,TEXTURECUBEMAP_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_WIDTH),\n (1,SURFACECUBEMAP_LAYERED_LAYERS) }</small></td></tr>\n </table>\n#### pHandle:\n- Returned mipmapped array\n#### pMipmappedArrayDesc:\n- mipmapped array descriptor\n#### numMipmapLevels:\n- Number of mipmap levels\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMipmappedArrayDestroy](crate::ffi::cuMipmappedArrayDestroy),\n [cuMipmappedArrayGetLevel](crate::ffi::cuMipmappedArrayGetLevel),\n [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cudaMallocMipmappedArray](crate::ffi::cudaMallocMipmappedArray)\n"]
    pub fn cuMipmappedArrayCreate(
        pHandle: *mut CUmipmappedArray,
        pMipmappedArrayDesc: *const CUDA_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets a mipmap level of a CUDA mipmapped array\n\n Returns in `*pLevelArray` a CUDA array that represents a single mipmap level\n of the CUDA mipmapped array `hMipmappedArray`.\n\n If `level` is greater than the maximum number of levels in this mipmapped array,\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n#### pLevelArray:\n- Returned mipmap level CUDA array\n#### hMipmappedArray:\n- CUDA mipmapped array\n#### level:\n- Mipmap level\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMipmappedArrayCreate](crate::ffi::cuMipmappedArrayCreate),\n [cuMipmappedArrayDestroy](crate::ffi::cuMipmappedArrayDestroy),\n [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cudaGetMipmappedArrayLevel](crate::ffi::cudaGetMipmappedArrayLevel)\n"]
    pub fn cuMipmappedArrayGetLevel(
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a CUDA mipmapped array\n\n Destroys the CUDA mipmapped array `hMipmappedArray`.\n#### hMipmappedArray:\n- Mipmapped array to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_ARRAY_IS_MAPPED](crate::ffi::CUDA_ERROR_ARRAY_IS_MAPPED),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMipmappedArrayCreate](crate::ffi::cuMipmappedArrayCreate),\n [cuMipmappedArrayGetLevel](crate::ffi::cuMipmappedArrayGetLevel),\n [cuArrayCreate](crate::ffi::cuArrayCreate),\n [cudaFreeMipmappedArray](crate::ffi::cudaFreeMipmappedArray)\n"]
    pub fn cuMipmappedArrayDestroy(hMipmappedArray: CUmipmappedArray) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Retrieve handle for an address range\n\n Get a handle of the specified type to an address range. The address range\n must have been obtained by a prior call to either [cuMemAlloc](crate::ffi::cuMemAlloc) or [cuMemAddressReserve](crate::ffi::cuMemAddressReserve).\n If the address range was obtained via [cuMemAddressReserve](crate::ffi::cuMemAddressReserve), it must also be fully mapped via [cuMemMap](crate::ffi::cuMemMap).\n The address range must have been obtained by a prior call to either [cuMemAllocHost](crate::ffi::cuMemAllocHost) or\n [cuMemHostAlloc](crate::ffi::cuMemHostAlloc) on Tegra.\n\n Users must ensure the `dptr` and `size` are aligned to the host page size.\n\n When requesting CUmemRangeHandleType[CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD](crate::ffi::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD),\n users are expected to query for dma_buf support for the platform\n by using [CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED](crate::ffi::CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED) device attribute before calling\n this API. The `handle` will be interpreted as a pointer to an integer to store the dma_buf file descriptor.\n Users must ensure the entire address range is backed and mapped when\n the address range is allocated by [cuMemAddressReserve](crate::ffi::cuMemAddressReserve). All the physical\n allocations backing the address range must be resident on the same device and\n have identical allocation properties. Users are also expected to retrieve a\n new handle every time the underlying physical allocation(s) corresponding\n to a previously queried VA range are changed.\n\n For CUmemRangeHandleType[CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD](crate::ffi::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD), users may set\n flags to [CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE](crate::ffi::CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE). Which when set on a\n supported platform, will give a DMA_BUF handle mapped via PCIE BAR1 or will\n return an error otherwise.\n\n `aram`[out] handle     - Pointer to the location where the returned handle will be stored.\n `aram`[in] dptr        - Pointer to a valid CUDA device allocation. Must be aligned to host page size.\n `aram`[in] size        - Length of the address range. Must be aligned to host page size.\n `aram`[in] handleType  - Type of handle requested (defines type and size of the `handle` output parameter)\n `aram`[in] flags       - When requesting CUmemRangeHandleType[CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD](crate::ffi::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD) the value could be\n                          [CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE](crate::ffi::CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE), otherwise 0.\n### Returns:\nCUDA_SUCCESS\n CUDA_ERROR_INVALID_VALUE\n CUDA_ERROR_NOT_SUPPORTED\n"]
    pub fn cuMemGetHandleForAddressRange(
        handle: *mut ::std::ffi::c_void,
        dptr: CUdeviceptr,
        size: usize,
        handleType: CUmemRangeHandleType,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
#[repr(u32)]
#[doc = " Bitmasks for CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemDecompressAlgorithm_enum {
    #[doc = "< Decompression is unsupported.\n"]
    CU_MEM_DECOMPRESS_UNSUPPORTED = 0,
    #[doc = "< Deflate is supported.\n"]
    CU_MEM_DECOMPRESS_ALGORITHM_DEFLATE = 1,
    #[doc = "< Snappy is supported.\n"]
    CU_MEM_DECOMPRESS_ALGORITHM_SNAPPY = 2,
}
#[doc = " Bitmasks for CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK.\n"]
pub use self::CUmemDecompressAlgorithm_enum as CUmemDecompressAlgorithm;
#[doc = " Structure describing the parameters that compose a single\n        decompression operation.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemDecompressParams_st {
    #[doc = " The number of bytes to be read and decompressed from\n  [CUmemDecompressParams_st](crate::ffi::CUmemDecompressParams_st).src.\n"]
    pub srcNumBytes: usize,
    #[doc = " The number of bytes that the decompression operation will be expected to\n  write to [CUmemDecompressParams_st](crate::ffi::CUmemDecompressParams_st).dst. This value is optional; if\n  present, it may be used by the CUDA driver as a heuristic for scheduling\n  the individual decompression operations.\n"]
    pub dstNumBytes: usize,
    #[doc = " After the decompression operation has completed, the actual number of\n bytes written to [CUmemDecompressParams](crate::ffi::CUmemDecompressParams).dst will be recorded as a 32-bit\n unsigned integer in the memory at this address.\n"]
    pub dstActBytes: *mut cuuint32_t,
    #[doc = " Pointer to a buffer of at least [CUmemDecompressParams_st](crate::ffi::CUmemDecompressParams_st).srcNumBytes\n compressed bytes.\n"]
    pub src: *const ::std::ffi::c_void,
    #[doc = " Pointer to a buffer where the decompressed data will be written. The\n number of bytes written to this location will be recorded in the memory\n pointed to by [CUmemDecompressParams_st](crate::ffi::CUmemDecompressParams_st).dstActBytes\n"]
    pub dst: *mut ::std::ffi::c_void,
    #[doc = " The decompression algorithm to use.\n"]
    pub algo: CUmemDecompressAlgorithm,
    pub padding: [::std::ffi::c_uchar; 20usize],
}
#[doc = " Structure describing the parameters that compose a single\n        decompression operation.\n"]
pub type CUmemDecompressParams = CUmemDecompressParams_st;
unsafe extern "C" {
    #[doc = "   Submit a batch of `count` independent decompression operations.\n\n \\details Each of the `count` decompression operations is described by a\n          single entry in the `paramsArray` array. Once the batch has been\n          submitted, the function will return, and decompression will happen\n          asynchronously w.r.t. the CPU. To the work completion tracking\n          mechanisms in the CUDA driver, the batch will be considered a single\n          unit of work and processed according to stream semantics, i.e., it\n          is not possible to query the completion of individual decompression\n          operations within a batch.\n\n          The memory pointed to by each of [CUmemDecompressParams](crate::ffi::CUmemDecompressParams).src,\n          [CUmemDecompressParams](crate::ffi::CUmemDecompressParams).dst, and [CUmemDecompressParams](crate::ffi::CUmemDecompressParams).dstActBytes,\n          must be capable of usage with the hardware decompress feature. That\n          is, for each of said pointers, the pointer attribute\n          [CU_POINTER_ATTRIBUTE_IS_MEM_DECOMPRESS_CAPABLE](crate::ffi::CU_POINTER_ATTRIBUTE_IS_MEM_DECOMPRESS_CAPABLE) should give a\n          non-zero value. To ensure this, the memory backing the pointers\n          should have been allocated using one of the following CUDA memory\n          allocators:\n          * [cuMemAlloc](crate::ffi::cuMemAlloc)()\n          * [cuMemCreate](crate::ffi::cuMemCreate)() with the usage flag [CU_MEM_CREATE_USAGE_HW_DECOMPRESS](crate::ffi::CU_MEM_CREATE_USAGE_HW_DECOMPRESS)\n          * [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync)() from a pool that was created with\n            the usage flag [CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS](crate::ffi::CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS)\n          Additionally, [CUmemDecompressParams](crate::ffi::CUmemDecompressParams).src, [CUmemDecompressParams](crate::ffi::CUmemDecompressParams).dst,\n          and [CUmemDecompressParams](crate::ffi::CUmemDecompressParams).dstActBytes, must all be accessible from\n          the device associated with the context where `stream` was created.\n          For information on how to ensure this, see the documentation for the\n          allocator of interest.\n\n `aram`[in]  paramsArray  The array of structures describing the independent\n                          decompression operations.\n `aram`[in]  count        The number of entries in `paramsArray` array.\n `aram`[in]  flags        Must be 0.\n `aram`[out] errorIndex   The index into `paramsArray` of the decompression\n                          operation for which the error returned by this\n                          function pertains to. If `index` is SIZE_MAX and\n                          the value returned is not [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS), then the\n                          error returned by this function should be considered\n                          a general error that does not pertain to a\n                          particular decompression operation. May be `NULL`,\n                          in which case, no index will be recorded in the\n                          event of error.\n `aram`[in]  stream       The stream where the work will be enqueued.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemAlloc](crate::ffi::cuMemAlloc), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate), [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync)\n"]
    pub fn cuMemBatchDecompressAsync(
        paramsArray: *mut CUmemDecompressParams,
        count: usize,
        flags: ::std::ffi::c_uint,
        errorIndex: *mut usize,
        stream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocate an address range reservation.\n\n Reserves a virtual address range based on the given parameters, giving\n the starting address of the range in `ptr`.  This API requires a system that\n supports UVA.  The size and address parameters must be a multiple of the\n host page size and the alignment must be a power of two or zero for default\n alignment.\n\n `aram`[out] ptr       - Resulting pointer to start of virtual address range allocated\n `aram`[in]  size      - Size of the reserved virtual address range requested\n `aram`[in]  alignment - Alignment of the reserved virtual address range requested\n `aram`[in]  addr      - Fixed starting address range requested\n `aram`[in]  flags     - Currently unused, must be zero\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemAddressFree](crate::ffi::cuMemAddressFree)\n"]
    pub fn cuMemAddressReserve(
        ptr: *mut CUdeviceptr,
        size: usize,
        alignment: usize,
        addr: CUdeviceptr,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Free an address range reservation.\n\n Frees a virtual address range reserved by cuMemAddressReserve.  The size\n must match what was given to memAddressReserve and the ptr given must\n match what was returned from memAddressReserve.\n\n `aram`[in] ptr  - Starting address of the virtual address range to free\n `aram`[in] size - Size of the virtual address region to free\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemAddressReserve](crate::ffi::cuMemAddressReserve)\n"]
    pub fn cuMemAddressFree(ptr: CUdeviceptr, size: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a CUDA memory handle representing a memory allocation of a given size described by the given properties\n\n This creates a memory allocation on the target device specified through the\n `prop` structure. The created allocation will not have any device or host\n mappings. The generic memory `handle` for the allocation can be\n mapped to the address space of calling process via [cuMemMap](crate::ffi::cuMemMap). This handle\n cannot be transmitted directly to other processes (see\n [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle)).  On Windows, the caller must also pass\n an LPSECURITYATTRIBUTE in `prop` to be associated with this handle which\n limits or allows access to this handle for a recipient process (see\n [CUmemAllocationProp](crate::ffi::CUmemAllocationProp)[win32HandleMetaData](crate::ffi::win32HandleMetaData) for more).  The `size` of this\n allocation must be a multiple of the the value given via\n [cuMemGetAllocationGranularity](crate::ffi::cuMemGetAllocationGranularity) with the [CU_MEM_ALLOC_GRANULARITY_MINIMUM](crate::ffi::CU_MEM_ALLOC_GRANULARITY_MINIMUM)\n flag.\n To create a CPU allocation targeting a specific host NUMA node, applications must\n set [CUmemAllocationProp](crate::ffi::CUmemAllocationProp)[CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) to [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA) and\n [CUmemAllocationProp](crate::ffi::CUmemAllocationProp)[CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must specify the NUMA ID of the CPU.\n On systems where NUMA is not available [CUmemAllocationProp](crate::ffi::CUmemAllocationProp)[CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must be set to 0.\n Specifying [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT) or [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST) as the\n [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) will result in [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n\n Applications that intend to use [CU_MEM_HANDLE_TYPE_FABRIC](crate::ffi::CU_MEM_HANDLE_TYPE_FABRIC) based memory sharing must ensure:\n (1) `nvidia-caps-imex-channels` character device is created by the driver and is listed under /proc/devices\n (2) have at least one IMEX channel file accessible by the user launching the application.\n\n When exporter and importer CUDA processes have been granted access to the same IMEX channel, they can securely\n share memory.\n\n The IMEX channel security model works on a per user basis. Which means all processes under a user can share\n memory if the user has access to a valid IMEX channel. When multi-user isolation is desired, a separate IMEX\n channel is required for each user.\n\n These channel files exist in /dev/nvidia-caps-imex-channels/channel* and can be created using standard OS\n native calls like mknod on Linux. For example: To create channel0 with the major number from /proc/devices\n users can execute the following command: `mknod /dev/nvidia-caps-imex-channels/channel0 c <major number> 0`\n\n If [CUmemAllocationProp](crate::ffi::CUmemAllocationProp)[allocFlags](crate::ffi::allocFlags)[usage](crate::ffi::usage) contains [CU_MEM_CREATE_USAGE_TILE_POOL](crate::ffi::CU_MEM_CREATE_USAGE_TILE_POOL) flag then\n the memory allocation is intended only to be used as backing tile pool for sparse CUDA arrays\n and sparse CUDA mipmapped arrays.\n (see [cuMemMapArrayAsync](crate::ffi::cuMemMapArrayAsync)).\n\n `aram`[out] handle - Value of handle returned. All operations on this allocation are to be performed using this handle.\n `aram`[in]  size   - Size of the allocation requested\n `aram`[in]  prop   - Properties of the allocation to create.\n `aram`[in]  flags  - flags for future use, must be zero now.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuMemRelease](crate::ffi::cuMemRelease), [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), [cuMemImportFromShareableHandle](crate::ffi::cuMemImportFromShareableHandle)\n"]
    pub fn cuMemCreate(
        handle: *mut CUmemGenericAllocationHandle,
        size: usize,
        prop: *const CUmemAllocationProp,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.\n\n Frees the memory that was allocated on a device through cuMemCreate.\n\n The memory allocation will be freed when all outstanding mappings to the memory\n are unmapped and when all outstanding references to the handle (including it's\n shareable counterparts) are also released. The generic memory handle can be\n freed when there are still outstanding mappings made with this handle. Each\n time a recipient process imports a shareable handle, it needs to pair it with\n [cuMemRelease](crate::ffi::cuMemRelease) for the handle to be freed.  If `handle` is not a valid handle\n the behavior is undefined.\n\n `aram`[in] handle Value of handle which was returned previously by cuMemCreate.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuMemCreate](crate::ffi::cuMemCreate)\n"]
    pub fn cuMemRelease(handle: CUmemGenericAllocationHandle) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Maps an allocation handle to a reserved virtual address range.\n\n Maps bytes of memory represented by `handle` starting from byte `offset` to\n `size` to address range [`addr`, `addr` + `size`]. This range must be an\n address reservation previously reserved with [cuMemAddressReserve](crate::ffi::cuMemAddressReserve), and\n `offset` + `size` must be less than the size of the memory allocation.\n Both `ptr`, `size`, and `offset` must be a multiple of the value given via\n [cuMemGetAllocationGranularity](crate::ffi::cuMemGetAllocationGranularity) with the [CU_MEM_ALLOC_GRANULARITY_MINIMUM](crate::ffi::CU_MEM_ALLOC_GRANULARITY_MINIMUM) flag.\n If `handle` represents a multicast object, `ptr`, `size` and `offset` must\n be aligned to the value returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag\n [CU_MULTICAST_MINIMUM_GRANULARITY](crate::ffi::CU_MULTICAST_MINIMUM_GRANULARITY). For best performance however, it is\n recommended that `ptr`, `size` and `offset` be aligned to the value\n returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag\n [CU_MULTICAST_RECOMMENDED_GRANULARITY](crate::ffi::CU_MULTICAST_RECOMMENDED_GRANULARITY).\n\n Please note calling [cuMemMap](crate::ffi::cuMemMap) does not make the address accessible,\n the caller needs to update accessibility of a contiguous mapped VA\n range by calling [cuMemSetAccess](crate::ffi::cuMemSetAccess).\n\n Once a recipient process obtains a shareable memory handle\n from [cuMemImportFromShareableHandle](crate::ffi::cuMemImportFromShareableHandle), the process must\n use [cuMemMap](crate::ffi::cuMemMap) to map the memory into its address ranges before\n setting accessibility with [cuMemSetAccess](crate::ffi::cuMemSetAccess).\n\n [cuMemMap](crate::ffi::cuMemMap) can only create mappings on VA range reservations\n that are not currently mapped.\n\n `aram`[in] ptr    - Address where memory will be mapped.\n `aram`[in] size   - Size of the memory mapping.\n `aram`[in] offset - Offset into the memory represented by\n                   - `handle` from which to start mapping\n                   - Note: currently must be zero.\n `aram`[in] handle - Handle to a shareable memory\n `aram`[in] flags  - flags for future use, must be zero now.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuMemUnmap](crate::ffi::cuMemUnmap), [cuMemSetAccess](crate::ffi::cuMemSetAccess), [cuMemCreate](crate::ffi::cuMemCreate), [cuMemAddressReserve](crate::ffi::cuMemAddressReserve), [cuMemImportFromShareableHandle](crate::ffi::cuMemImportFromShareableHandle)\n"]
    pub fn cuMemMap(
        ptr: CUdeviceptr,
        size: usize,
        offset: usize,
        handle: CUmemGenericAllocationHandle,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays\n\n Performs map or unmap operations on subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.\n Each operation is specified by a [CUarrayMapInfo](crate::ffi::CUarrayMapInfo) entry in the `mapInfoList` array of size `count`.\n The structure [CUarrayMapInfo](crate::ffi::CUarrayMapInfo) is defined as follow:\n\\code\ntypedef struct CUarrayMapInfo_st {\nCUresourcetype resourceType;\nunion {\nCUmipmappedArray mipmap;\nCUarray array;\n} resource;\n\nCUarraySparseSubresourceType subresourceType;\nunion {\nstruct {\nunsigned int level;\nunsigned int layer;\nunsigned int offsetX;\nunsigned int offsetY;\nunsigned int offsetZ;\nunsigned int extentWidth;\nunsigned int extentHeight;\nunsigned int extentDepth;\n} sparseLevel;\nstruct {\nunsigned int layer;\nunsigned long long offset;\nunsigned long long size;\n} miptail;\n} subresource;\n\nCUmemOperationType memOperationType;\n\nCUmemHandleType memHandleType;\nunion {\nCUmemGenericAllocationHandle memHandle;\n} memHandle;\n\nunsigned long long offset;\nunsigned int deviceBitMask;\nunsigned int flags;\nunsigned int reserved[2];\n} CUarrayMapInfo;\n\\endcode\n\n where [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[resourceType](crate::ffi::resourceType) specifies the type of resource to be operated on.\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[resourceType](crate::ffi::resourceType) is set to [CUresourcetype](crate::ffi::CUresourcetype)[CU_RESOURCE_TYPE_ARRAY](crate::ffi::CU_RESOURCE_TYPE_ARRAY) then\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[resource](crate::ffi::resource)[array](crate::ffi::array) must be set to a valid sparse CUDA array handle.\n The CUDA array must be either a 2D, 2D layered or 3D CUDA array and must have been allocated using\n [cuArrayCreate](crate::ffi::cuArrayCreate) or [cuArray3DCreate](crate::ffi::cuArray3DCreate) with the flag [CUDA_ARRAY3D_SPARSE](crate::ffi::CUDA_ARRAY3D_SPARSE)\n or [CUDA_ARRAY3D_DEFERRED_MAPPING](crate::ffi::CUDA_ARRAY3D_DEFERRED_MAPPING).\n For CUDA arrays obtained using [cuMipmappedArrayGetLevel](crate::ffi::cuMipmappedArrayGetLevel), [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned.\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[resourceType](crate::ffi::resourceType) is set to [CUresourcetype](crate::ffi::CUresourcetype)[CU_RESOURCE_TYPE_MIPMAPPED_ARRAY](crate::ffi::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY)\n then [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[resource](crate::ffi::resource)[mipmap](crate::ffi::mipmap) must be set to a valid sparse CUDA mipmapped array handle.\n The CUDA mipmapped array must be either a 2D, 2D layered or 3D CUDA mipmapped array and must have been\n allocated using [cuMipmappedArrayCreate](crate::ffi::cuMipmappedArrayCreate) with the flag [CUDA_ARRAY3D_SPARSE](crate::ffi::CUDA_ARRAY3D_SPARSE)\n or [CUDA_ARRAY3D_DEFERRED_MAPPING](crate::ffi::CUDA_ARRAY3D_DEFERRED_MAPPING).\n\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresourceType](crate::ffi::subresourceType) specifies the type of subresource within the resource.\n [CUarraySparseSubresourceType_enum](crate::ffi::CUarraySparseSubresourceType_enum) is defined as:\n\\code\ntypedef enum CUarraySparseSubresourceType_enum {\nCU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,\nCU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1\n} CUarraySparseSubresourceType;\n\\endcode\n\n where [CUarraySparseSubresourceType](crate::ffi::CUarraySparseSubresourceType)[CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL](crate::ffi::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL) indicates a\n sparse-miplevel which spans at least one tile in every dimension. The remaining miplevels which\n are too small to span at least one tile in any dimension constitute the mip tail region as indicated by\n [CUarraySparseSubresourceType](crate::ffi::CUarraySparseSubresourceType)[CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL](crate::ffi::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL) subresource type.\n\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresourceType](crate::ffi::subresourceType) is set to [CUarraySparseSubresourceType](crate::ffi::CUarraySparseSubresourceType)[CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL](crate::ffi::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL)\n then [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel) struct must contain valid array subregion offsets and extents.\n The [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[offsetX](crate::ffi::offsetX), [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[offsetY](crate::ffi::offsetY)\n and [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[offsetZ](crate::ffi::offsetZ) must specify valid X, Y and Z offsets respectively.\n The [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[extentWidth](crate::ffi::extentWidth), [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[extentHeight](crate::ffi::extentHeight)\n and [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[extentDepth](crate::ffi::extentDepth) must specify valid width, height and depth extents respectively.\n These offsets and extents must be aligned to the corresponding tile dimension.\n For CUDA mipmapped arrays [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[level](crate::ffi::level) must specify a valid mip level index. Otherwise,\n must be zero.\n For layered CUDA arrays and layered CUDA mipmapped arrays [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[layer](crate::ffi::layer) must specify a valid layer index. Otherwise,\n must be zero.\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[offsetZ](crate::ffi::offsetZ) must be zero and [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[sparseLevel](crate::ffi::sparseLevel)[extentDepth](crate::ffi::extentDepth)\n must be set to 1 for 2D and 2D layered CUDA arrays and CUDA mipmapped arrays.\n Tile extents can be obtained by calling [cuArrayGetSparseProperties](crate::ffi::cuArrayGetSparseProperties) and [cuMipmappedArrayGetSparseProperties](crate::ffi::cuMipmappedArrayGetSparseProperties)\n\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresourceType](crate::ffi::subresourceType) is set to [CUarraySparseSubresourceType](crate::ffi::CUarraySparseSubresourceType)[CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL](crate::ffi::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL)\n then [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[miptail](crate::ffi::miptail) struct must contain valid mip tail offset in\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[miptail](crate::ffi::miptail)[offset](crate::ffi::offset) and size in [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[miptail](crate::ffi::miptail)[size](crate::ffi::size).\n Both, mip tail offset and mip tail size must be aligned to the tile size.\n For layered CUDA mipmapped arrays which don't have the flag [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](crate::ffi::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL) set in [CUDA_ARRAY_SPARSE_PROPERTIES](crate::ffi::CUDA_ARRAY_SPARSE_PROPERTIES)[flags](crate::ffi::flags)\n as returned by [cuMipmappedArrayGetSparseProperties](crate::ffi::cuMipmappedArrayGetSparseProperties), [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource)[miptail](crate::ffi::miptail)[layer](crate::ffi::layer) must specify a valid layer index.\n Otherwise, must be zero.\n\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[resource](crate::ffi::resource)[array](crate::ffi::array) or [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[resource](crate::ffi::resource)[mipmap](crate::ffi::mipmap) was created with [CUDA_ARRAY3D_DEFERRED_MAPPING](crate::ffi::CUDA_ARRAY3D_DEFERRED_MAPPING)\n flag set the [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresourceType](crate::ffi::subresourceType) and the contents of [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[subresource](crate::ffi::subresource) will be ignored.\n\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memOperationType](crate::ffi::memOperationType) specifies the type of operation. [CUmemOperationType](crate::ffi::CUmemOperationType) is defined as:\n\\code\ntypedef enum CUmemOperationType_enum {\nCU_MEM_OPERATION_TYPE_MAP = 1,\nCU_MEM_OPERATION_TYPE_UNMAP = 2\n} CUmemOperationType;\n\\endcode\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memOperationType](crate::ffi::memOperationType) is set to [CUmemOperationType](crate::ffi::CUmemOperationType)[CU_MEM_OPERATION_TYPE_MAP](crate::ffi::CU_MEM_OPERATION_TYPE_MAP) then the subresource\n will be mapped onto the tile pool memory specified by [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memHandle](crate::ffi::memHandle) at offset [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[offset](crate::ffi::offset).\n The tile pool allocation has to be created by specifying the [CU_MEM_CREATE_USAGE_TILE_POOL](crate::ffi::CU_MEM_CREATE_USAGE_TILE_POOL) flag when calling [cuMemCreate](crate::ffi::cuMemCreate). Also,\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memHandleType](crate::ffi::memHandleType) must be set to [CUmemHandleType](crate::ffi::CUmemHandleType)[CU_MEM_HANDLE_TYPE_GENERIC](crate::ffi::CU_MEM_HANDLE_TYPE_GENERIC).\n\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memOperationType](crate::ffi::memOperationType) is set to [CUmemOperationType](crate::ffi::CUmemOperationType)[CU_MEM_OPERATION_TYPE_UNMAP](crate::ffi::CU_MEM_OPERATION_TYPE_UNMAP) then an unmapping operation\n is performed. [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memHandle](crate::ffi::memHandle) must be NULL.\n\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[deviceBitMask](crate::ffi::deviceBitMask) specifies the list of devices that must map or unmap physical memory.\n Currently, this mask must have exactly one bit set, and the corresponding device must match the device associated with the stream.\n If [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memOperationType](crate::ffi::memOperationType) is set to [CUmemOperationType](crate::ffi::CUmemOperationType)[CU_MEM_OPERATION_TYPE_MAP](crate::ffi::CU_MEM_OPERATION_TYPE_MAP), the device must also match\n the device associated with the tile pool memory allocation as specified by [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[memHandle](crate::ffi::memHandle).\n\n [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[flags](crate::ffi::flags) and [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)[reserved](crate::ffi::reserved)[] are unused and must be set to zero.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n\n `aram`[in] mapInfoList - List of [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)\n `aram`[in] count       - Count of [CUarrayMapInfo](crate::ffi::CUarrayMapInfo)  in `mapInfoList`\n `aram`[in] hStream     - Stream identifier for the stream to use for map or unmap operations\n\n ### See also:\n [cuMipmappedArrayCreate](crate::ffi::cuMipmappedArrayCreate), [cuArrayCreate](crate::ffi::cuArrayCreate), [cuArray3DCreate](crate::ffi::cuArray3DCreate), [cuMemCreate](crate::ffi::cuMemCreate), [cuArrayGetSparseProperties](crate::ffi::cuArrayGetSparseProperties), [cuMipmappedArrayGetSparseProperties](crate::ffi::cuMipmappedArrayGetSparseProperties)\n"]
    pub fn cuMemMapArrayAsync(
        mapInfoList: *mut CUarrayMapInfo,
        count: ::std::ffi::c_uint,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unmap the backing memory of a given address range.\n\n The range must be the entire contiguous address range that was mapped to.  In\n other words, [cuMemUnmap](crate::ffi::cuMemUnmap) cannot unmap a sub-range of an address range mapped\n by [cuMemCreate](crate::ffi::cuMemCreate) / [cuMemMap](crate::ffi::cuMemMap).  Any backing memory allocations will be freed\n if there are no existing mappings and there are no unreleased memory handles.\n\n When [cuMemUnmap](crate::ffi::cuMemUnmap) returns successfully the address range is converted to an\n address reservation and can be used for a future calls to [cuMemMap](crate::ffi::cuMemMap).  Any new\n mapping to this virtual address will need to have access granted through\n [cuMemSetAccess](crate::ffi::cuMemSetAccess), as all mappings start with no accessibility setup.\n\n `aram`[in] ptr  - Starting address for the virtual address range to unmap\n `aram`[in] size - Size of the virtual address range to unmap\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuMemCreate](crate::ffi::cuMemCreate), [cuMemAddressReserve](crate::ffi::cuMemAddressReserve)\n"]
    pub fn cuMemUnmap(ptr: CUdeviceptr, size: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Set the access flags for each location specified in `desc` for the given virtual address range\n\n Given the virtual address range via `ptr` and `size`, and the locations\n in the array given by `desc` and `count`, set the access flags for the\n target locations.  The range must be a fully mapped address range\n containing all allocations created by [cuMemMap](crate::ffi::cuMemMap) / [cuMemCreate](crate::ffi::cuMemCreate).\n Users cannot specify [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA) accessibility for allocations created on with other location types.\n Note: When [CUmemAccessDesc](crate::ffi::CUmemAccessDesc)[CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA), [CUmemAccessDesc](crate::ffi::CUmemAccessDesc)[CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id)\n is ignored.\n When setting the access flags for a virtual address range mapping a multicast\n object, `ptr` and `size` must be aligned to the value returned by\n [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag [CU_MULTICAST_MINIMUM_GRANULARITY](crate::ffi::CU_MULTICAST_MINIMUM_GRANULARITY).\n For best performance however, it is recommended that `ptr` and `size` be\n aligned to the value returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag\n [CU_MULTICAST_RECOMMENDED_GRANULARITY](crate::ffi::CU_MULTICAST_RECOMMENDED_GRANULARITY).\n\n `aram`[in] ptr   - Starting address for the virtual address range\n `aram`[in] size  - Length of the virtual address range\n `aram`[in] desc  - Array of [CUmemAccessDesc](crate::ffi::CUmemAccessDesc) that describe how to change the\n                  - mapping for each location specified\n `aram`[in] count - Number of [CUmemAccessDesc](crate::ffi::CUmemAccessDesc) in `desc`\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [synchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-sync) behavior for most use cases.\n\n\n ### See also:\n [cuMemSetAccess](crate::ffi::cuMemSetAccess), [cuMemCreate](crate::ffi::cuMemCreate), :cuMemMap\n"]
    pub fn cuMemSetAccess(
        ptr: CUdeviceptr,
        size: usize,
        desc: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get the access `flags` set for the given `location` and `ptr`\n\n `aram`[out] flags   - Flags set for this location\n `aram`[in] location - Location in which to check the flags for\n `aram`[in] ptr      - Address in which to check the access flags for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemSetAccess](crate::ffi::cuMemSetAccess)\n"]
    pub fn cuMemGetAccess(
        flags: *mut ::std::ffi::c_ulonglong,
        location: *const CUmemLocation,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Exports an allocation to a requested shareable handle type\n\n Given a CUDA memory handle, create a shareable memory\n allocation handle that can be used to share the memory with other\n processes. The recipient process can convert the shareable handle back into a\n CUDA memory handle using [cuMemImportFromShareableHandle](crate::ffi::cuMemImportFromShareableHandle) and map\n it with [cuMemMap](crate::ffi::cuMemMap). The implementation of what this handle is and how it\n can be transferred is defined by the requested handle type in `handleType`\n\n Once all shareable handles are closed and the allocation is released, the allocated\n memory referenced will be released back to the OS and uses of the CUDA handle afterward\n will lead to undefined behavior.\n\n This API can also be used in conjunction with other APIs (e.g. Vulkan, OpenGL)\n that support importing memory from the shareable type\n\n `aram`[out] shareableHandle - Pointer to the location in which to store the requested handle type\n `aram`[in] handle           - CUDA handle for the memory allocation\n `aram`[in] handleType       - Type of shareable handle requested (defines type and size of the `shareableHandle` output parameter)\n `aram`[in] flags            - Reserved, must be zero\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemImportFromShareableHandle](crate::ffi::cuMemImportFromShareableHandle)\n"]
    pub fn cuMemExportToShareableHandle(
        shareableHandle: *mut ::std::ffi::c_void,
        handle: CUmemGenericAllocationHandle,
        handleType: CUmemAllocationHandleType,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Imports an allocation from a requested shareable handle type.\n\n If the current process cannot support the memory described by this shareable\n handle, this API will error as [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED).\n\n If `shHandleType` is [CU_MEM_HANDLE_TYPE_FABRIC](crate::ffi::CU_MEM_HANDLE_TYPE_FABRIC) and the importer process has not been\n granted access to the same IMEX channel as the exporter process, this API will error\n as [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED).\n\n### Note:\n ### Note:\nImporting shareable handles exported from some graphics APIs(VUlkan, OpenGL, etc)\n created on devices under an SLI group may not be supported, and thus this API will\n return CUDA_ERROR_NOT_SUPPORTED.\n There is no guarantee that the contents of `handle` will be the same CUDA memory handle\n for the same given OS shareable handle, or the same underlying allocation.\n\n `aram`[out] handle       - CUDA Memory handle for the memory allocation.\n `aram`[in]  osHandle     - Shareable Handle representing the memory allocation that is to be imported.\n `aram`[in]  shHandleType - handle type of the exported handle [CUmemAllocationHandleType](crate::ffi::CUmemAllocationHandleType).\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), [cuMemMap](crate::ffi::cuMemMap), [cuMemRelease](crate::ffi::cuMemRelease)\n"]
    pub fn cuMemImportFromShareableHandle(
        handle: *mut CUmemGenericAllocationHandle,
        osHandle: *mut ::std::ffi::c_void,
        shHandleType: CUmemAllocationHandleType,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Calculates either the minimal or recommended granularity\n\n Calculates either the minimal or recommended granularity\n for a given allocation specification and returns it in granularity.  This\n granularity can be used as a multiple for alignment, size, or address mapping.\n\n `aram`[out] granularity Returned granularity.\n `aram`[in]  prop Property for which to determine the granularity for\n `aram`[in]  option Determines which granularity to return\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemCreate](crate::ffi::cuMemCreate), [cuMemMap](crate::ffi::cuMemMap)\n"]
    pub fn cuMemGetAllocationGranularity(
        granularity: *mut usize,
        prop: *const CUmemAllocationProp,
        option: CUmemAllocationGranularity_flags,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Retrieve the contents of the property structure defining properties for this handle\n\n `aram`[out] prop  - Pointer to a properties structure which will hold the information about this handle\n `aram`[in] handle - Handle which to perform the query on\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemCreate](crate::ffi::cuMemCreate), [cuMemImportFromShareableHandle](crate::ffi::cuMemImportFromShareableHandle)\n"]
    pub fn cuMemGetAllocationPropertiesFromHandle(
        prop: *mut CUmemAllocationProp,
        handle: CUmemGenericAllocationHandle,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Given an address `addr`, returns the allocation handle of the backing memory allocation.\n\n The handle is guaranteed to be the same handle value used to map the memory. If the address\n requested is not mapped, the function will fail. The returned handle must be released with\n corresponding number of calls to [cuMemRelease](crate::ffi::cuMemRelease).\n\n### Note:\n ### Note:\nThe address `addr`, can be any address in a range previously mapped\n by [cuMemMap](crate::ffi::cuMemMap), and not necessarily the start address.\n\n `aram`[out] handle CUDA Memory handle for the backing memory allocation.\n `aram`[in] addr Memory address to query, that has been mapped previously.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMemCreate](crate::ffi::cuMemCreate), [cuMemRelease](crate::ffi::cuMemRelease), [cuMemMap](crate::ffi::cuMemMap)\n"]
    pub fn cuMemRetainAllocationHandle(
        handle: *mut CUmemGenericAllocationHandle,
        addr: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Frees memory with stream ordered semantics\n\n Inserts a free operation into `hStream`.\n The allocation must not be accessed after stream execution reaches the free.\n After this API returns, accessing the memory from any subsequent work launched on the GPU\n or querying its pointer attributes results in undefined behavior.\n\n### Note:\n ### Note:\nDuring stream capture, this function results in the creation of a free node and\n       must therefore be passed the address of a graph allocation.\n#### dptr:\n- memory to free\n#### hStream:\n- The stream establishing the stream ordering contract.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) (default stream specified with no current context),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n"]
    pub fn cuMemFreeAsync(dptr: CUdeviceptr, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocates memory with stream ordered semantics\n\n Inserts an allocation operation into `hStream`.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the memory pool current to the stream's device.\n\n### Note:\n ### Note:\nThe default memory pool of a device contains device memory from that device.\n ### Note:\nBasic stream ordering allows future work submitted into the same stream to use the allocation.\n       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation\n       operation completes before work submitted in a separate stream runs.\n ### Note:\nDuring stream capture, this function results in the creation of an allocation node.  In this case,\n       the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n       are used to set the node's creation parameters.\n\n `aram`[out] dptr    - Returned device pointer\n `aram`[in] bytesize - Number of bytes to allocate\n `aram`[in] hStream  - The stream establishing the stream ordering contract and the memory pool to allocate from\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) (default stream specified with no current context),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceSetMemPool](crate::ffi::cuDeviceSetMemPool),\n     [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool), [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate),\n     [cuMemPoolSetAccess](crate::ffi::cuMemPoolSetAccess), [cuMemPoolSetAttribute](crate::ffi::cuMemPoolSetAttribute)\n"]
    pub fn cuMemAllocAsync(dptr: *mut CUdeviceptr, bytesize: usize, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Tries to release memory back to the OS\n\n Releases memory back to the OS until the pool contains fewer than minBytesToKeep\n reserved bytes, or there is no more memory that the allocator can safely release.\n The allocator cannot release OS allocations that back outstanding asynchronous allocations.\n The OS allocations may happen at different granularity from the user allocations.\n\n### Note:\n \n Allocations that have not been freed count as outstanding.\n \n Allocations that have been asynchronously freed but whose completion has\n        not been observed on the host (eg. by a synchronize) can count as outstanding.\n\n `aram`[in] pool           - The memory pool to trim\n `aram`[in] minBytesToKeep - If the pool has less than minBytesToKeep reserved,\n the TrimTo operation is a no-op.  Otherwise the pool will be guaranteed to have\n at least minBytesToKeep bytes reserved after the operation.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool),\n     [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate)\n"]
    pub fn cuMemPoolTrimTo(pool: CUmemoryPool, minBytesToKeep: usize) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets attributes of a memory pool\n\n Supported attributes are:\n - [CU_MEMPOOL_ATTR_RELEASE_THRESHOLD](crate::ffi::CU_MEMPOOL_ATTR_RELEASE_THRESHOLD): (value type = cuuint64_t)\n                    Amount of reserved memory in bytes to hold onto before trying\n                    to release memory back to the OS. When more than the release\n                    threshold bytes of memory are held by the memory pool, the\n                    allocator will try to release memory back to the OS on the\n                    next call to stream, event or context synchronize. (default 0)\n - [CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES](crate::ffi::CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES): (value type = int)\n                    Allow [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) to use memory asynchronously freed\n                    in another stream as long as a stream ordering dependency\n                    of the allocating stream on the free action exists.\n                    Cuda events and null stream interactions can create the required\n                    stream ordered dependencies. (default enabled)\n - [CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC](crate::ffi::CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC): (value type = int)\n                    Allow reuse of already completed frees when there is no dependency\n                    between the free and allocation. (default enabled)\n - [CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES](crate::ffi::CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES): (value type = int)\n                    Allow [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) to insert new stream dependencies\n                    in order to establish the stream ordering required to reuse\n                    a piece of memory released by [cuMemFreeAsync](crate::ffi::cuMemFreeAsync) (default enabled).\n - [CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH](crate::ffi::CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH): (value type = cuuint64_t)\n                    Reset the high watermark that tracks the amount of backing memory that was\n                    allocated for the memory pool. It is illegal to set this attribute to a non-zero value.\n - [CU_MEMPOOL_ATTR_USED_MEM_HIGH](crate::ffi::CU_MEMPOOL_ATTR_USED_MEM_HIGH): (value type = cuuint64_t)\n                    Reset the high watermark that tracks the amount of used memory that was\n                    allocated for the memory pool.\n\n `aram`[in] pool  - The memory pool to modify\n `aram`[in] attr  - The attribute to modify\n `aram`[in] value - Pointer to the value to assign\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool),\n     [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate)\n"]
    pub fn cuMemPoolSetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets attributes of a memory pool\n\n Supported attributes are:\n - [CU_MEMPOOL_ATTR_RELEASE_THRESHOLD](crate::ffi::CU_MEMPOOL_ATTR_RELEASE_THRESHOLD): (value type = cuuint64_t)\n                    Amount of reserved memory in bytes to hold onto before trying\n                    to release memory back to the OS. When more than the release\n                    threshold bytes of memory are held by the memory pool, the\n                    allocator will try to release memory back to the OS on the\n                    next call to stream, event or context synchronize. (default 0)\n - [CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES](crate::ffi::CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES): (value type = int)\n                    Allow [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) to use memory asynchronously freed\n                    in another stream as long as a stream ordering dependency\n                    of the allocating stream on the free action exists.\n                    Cuda events and null stream interactions can create the required\n                    stream ordered dependencies. (default enabled)\n - [CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC](crate::ffi::CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC): (value type = int)\n                    Allow reuse of already completed frees when there is no dependency\n                    between the free and allocation. (default enabled)\n - [CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES](crate::ffi::CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES): (value type = int)\n                    Allow [cuMemAllocAsync](crate::ffi::cuMemAllocAsync) to insert new stream dependencies\n                    in order to establish the stream ordering required to reuse\n                    a piece of memory released by [cuMemFreeAsync](crate::ffi::cuMemFreeAsync) (default enabled).\n - [CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT](crate::ffi::CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT): (value type = cuuint64_t)\n                    Amount of backing memory currently allocated for the mempool\n - [CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH](crate::ffi::CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH): (value type = cuuint64_t)\n                    High watermark of backing memory allocated for the mempool since the\n                    last time it was reset.\n - [CU_MEMPOOL_ATTR_USED_MEM_CURRENT](crate::ffi::CU_MEMPOOL_ATTR_USED_MEM_CURRENT): (value type = cuuint64_t)\n                    Amount of memory from the pool that is currently in use by the application.\n - [CU_MEMPOOL_ATTR_USED_MEM_HIGH](crate::ffi::CU_MEMPOOL_ATTR_USED_MEM_HIGH): (value type = cuuint64_t)\n                    High watermark of the amount of memory from the pool that was in use by the application.\n\n `aram`[in] pool   - The memory pool to get attributes of\n `aram`[in] attr   - The attribute to get\n `aram`[out] value - Retrieved value\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool),\n     [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate)\n"]
    pub fn cuMemPoolGetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Controls visibility of pools between devices\n\n `aram`[in] pool  - The pool being modified\n `aram`[in] map   - Array of access descriptors. Each descriptor instructs the access to enable for a single gpu.\n `aram`[in] count - Number of descriptors in the map array.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool),\n     [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate)\n"]
    pub fn cuMemPoolSetAccess(
        pool: CUmemoryPool,
        map: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the accessibility of a pool from a device\n\n Returns the accessibility of the pool's memory from the specified location.\n\n `aram`[out] flags   - the accessibility of the pool from the specified location\n `aram`[in] memPool  - the pool being queried\n `aram`[in] location - the location accessing the pool\n\n ### See also:\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool),\n     [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate)\n"]
    pub fn cuMemPoolGetAccess(
        flags: *mut CUmemAccess_flags,
        memPool: CUmemoryPool,
        location: *mut CUmemLocation,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a memory pool\n\n Creates a CUDA memory pool and returns the handle in `pool`.  The `poolProps` determines\n the properties of the pool such as the backing device and IPC capabilities.\n\n To create a memory pool targeting a specific host NUMA node, applications must\n set [CUmemPoolProps](crate::ffi::CUmemPoolProps)[CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) to [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA) and\n [CUmemPoolProps](crate::ffi::CUmemPoolProps)[CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must specify the NUMA ID of the host memory node.\n Specifying [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT) or [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST) as the\n [CUmemPoolProps](crate::ffi::CUmemPoolProps)[CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) will result in [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n By default, the pool's memory will be accessible from the device it is allocated on.\n In the case of pools created with [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA), their default accessibility\n will be from the host CPU.\n Applications can control the maximum size of the pool by specifying a non-zero value for [CUmemPoolProps](crate::ffi::CUmemPoolProps)[maxSize](crate::ffi::maxSize).\n If set to 0, the maximum size of the pool will default to a system dependent value.\n\n Applications that intend to use [CU_MEM_HANDLE_TYPE_FABRIC](crate::ffi::CU_MEM_HANDLE_TYPE_FABRIC) based memory sharing must ensure:\n (1) `nvidia-caps-imex-channels` character device is created by the driver and is listed under /proc/devices\n (2) have at least one IMEX channel file accessible by the user launching the application.\n\n When exporter and importer CUDA processes have been granted access to the same IMEX channel, they can securely\n share memory.\n\n The IMEX channel security model works on a per user basis. Which means all processes under a user can share\n memory if the user has access to a valid IMEX channel. When multi-user isolation is desired, a separate IMEX\n channel is required for each user.\n\n These channel files exist in /dev/nvidia-caps-imex-channels/channel* and can be created using standard OS\n native calls like mknod on Linux. For example: To create channel0 with the major number from /proc/devices\n users can execute the following command: `mknod /dev/nvidia-caps-imex-channels/channel0 c <major number> 0`\n\n### Note:\n ### Note:\nSpecifying CU_MEM_HANDLE_TYPE_NONE creates a memory pool that will not support IPC.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuDeviceSetMemPool](crate::ffi::cuDeviceSetMemPool), [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool),\n     [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync), [cuMemPoolExportToShareableHandle](crate::ffi::cuMemPoolExportToShareableHandle)\n"]
    pub fn cuMemPoolCreate(pool: *mut CUmemoryPool, poolProps: *const CUmemPoolProps) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys the specified memory pool\n\n If any pointers obtained from this pool haven't been freed or\n the pool has free operations that haven't completed\n when [cuMemPoolDestroy](crate::ffi::cuMemPoolDestroy) is invoked, the function will return immediately and the\n resources associated with the pool will be released automatically\n once there are no more outstanding allocations.\n\n Destroying the current mempool of a device sets the default mempool of\n that device as the current mempool for that device.\n\n### Note:\n ### Note:\nA device's default memory pool cannot be destroyed.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceSetMemPool](crate::ffi::cuDeviceSetMemPool), [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool),\n     [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate)\n"]
    pub fn cuMemPoolDestroy(pool: CUmemoryPool) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allocates memory from a specified pool with stream ordered semantics.\n\n Inserts an allocation operation into `hStream`.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the specified memory pool.\n\n### Note:\n \\note\n    -  The specified memory pool may be from a device different than that of the specified `hStream`.\n\n    -  Basic stream ordering allows future work submitted into the same stream to use the allocation.\n       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation\n       operation completes before work submitted in a separate stream runs.\n\n ### Note:\nDuring stream capture, this function results in the creation of an allocation node.  In this case,\n       the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n       are used to set the node's creation parameters.\n\n `aram`[out] dptr    - Returned device pointer\n `aram`[in] bytesize - Number of bytes to allocate\n `aram`[in] pool     - The pool to allocate from\n `aram`[in] hStream  - The stream establishing the stream ordering semantic\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) (default stream specified with no current context),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync), [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool),\n     [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate), [cuMemPoolSetAccess](crate::ffi::cuMemPoolSetAccess),\n     [cuMemPoolSetAttribute](crate::ffi::cuMemPoolSetAttribute)\n"]
    pub fn cuMemAllocFromPoolAsync(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        pool: CUmemoryPool,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Exports a memory pool to the requested handle type.\n\n Given an IPC capable mempool, create an OS handle to share the pool with another process.\n A recipient process can convert the shareable handle into a mempool with [cuMemPoolImportFromShareableHandle](crate::ffi::cuMemPoolImportFromShareableHandle).\n Individual pointers can then be shared with the [cuMemPoolExportPointer](crate::ffi::cuMemPoolExportPointer) and [cuMemPoolImportPointer](crate::ffi::cuMemPoolImportPointer) APIs.\n The implementation of what the shareable handle is and how it can be transferred is defined by the requested\n handle type.\n\n### Note:\n \n To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than CU_MEM_HANDLE_TYPE_NONE.\n\n `aram`[out] handle_out  - Returned OS handle\n `aram`[in] pool         - pool to export\n `aram`[in] handleType   - the type of handle to create\n `aram`[in] flags        - must be 0\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuMemPoolImportFromShareableHandle](crate::ffi::cuMemPoolImportFromShareableHandle), [cuMemPoolExportPointer](crate::ffi::cuMemPoolExportPointer),\n     [cuMemPoolImportPointer](crate::ffi::cuMemPoolImportPointer), [cuMemAllocAsync](crate::ffi::cuMemAllocAsync), [cuMemFreeAsync](crate::ffi::cuMemFreeAsync),\n     [cuDeviceGetDefaultMemPool](crate::ffi::cuDeviceGetDefaultMemPool), [cuDeviceGetMemPool](crate::ffi::cuDeviceGetMemPool), [cuMemPoolCreate](crate::ffi::cuMemPoolCreate),\n     [cuMemPoolSetAccess](crate::ffi::cuMemPoolSetAccess), [cuMemPoolSetAttribute](crate::ffi::cuMemPoolSetAttribute)\n"]
    pub fn cuMemPoolExportToShareableHandle(
        handle_out: *mut ::std::ffi::c_void,
        pool: CUmemoryPool,
        handleType: CUmemAllocationHandleType,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " imports a memory pool from a shared handle.\n\n Specific allocations can be imported from the imported pool with cuMemPoolImportPointer.\n\n If `handleType` is [CU_MEM_HANDLE_TYPE_FABRIC](crate::ffi::CU_MEM_HANDLE_TYPE_FABRIC) and the importer process has not been\n granted access to the same IMEX channel as the exporter process, this API will error\n as [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED).\n\n\n### Note:\n ### Note:\nImported memory pools do not support creating new allocations.\n       As such imported memory pools may not be used in cuDeviceSetMemPool\n       or [cuMemAllocFromPoolAsync](crate::ffi::cuMemAllocFromPoolAsync) calls.\n\n `aram`[out] pool_out    - Returned memory pool\n `aram`[in] handle       - OS handle of the pool to open\n `aram`[in] handleType   - The type of handle being imported\n `aram`[in] flags        - must be 0\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuMemPoolExportToShareableHandle](crate::ffi::cuMemPoolExportToShareableHandle), [cuMemPoolExportPointer](crate::ffi::cuMemPoolExportPointer), [cuMemPoolImportPointer](crate::ffi::cuMemPoolImportPointer)\n"]
    pub fn cuMemPoolImportFromShareableHandle(
        pool_out: *mut CUmemoryPool,
        handle: *mut ::std::ffi::c_void,
        handleType: CUmemAllocationHandleType,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Export data to share a memory pool allocation between processes.\n\n Constructs `shareData_out` for sharing a specific allocation from an already shared memory pool.\n The recipient process can import the allocation with the [cuMemPoolImportPointer](crate::ffi::cuMemPoolImportPointer) api.\n The data is not a handle and may be shared through any IPC mechanism.\n\n `aram`[out] shareData_out - Returned export data\n `aram`[in] ptr            - pointer to memory being exported\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuMemPoolExportToShareableHandle](crate::ffi::cuMemPoolExportToShareableHandle), [cuMemPoolImportFromShareableHandle](crate::ffi::cuMemPoolImportFromShareableHandle), [cuMemPoolImportPointer](crate::ffi::cuMemPoolImportPointer)\n"]
    pub fn cuMemPoolExportPointer(
        shareData_out: *mut CUmemPoolPtrExportData,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Import a memory pool allocation from another process.\n\n Returns in `ptr_out` a pointer to the imported memory.\n The imported memory must not be accessed before the allocation operation completes\n in the exporting process. The imported memory must be freed from all importing processes before\n being freed in the exporting process. The pointer may be freed with cuMemFree\n or cuMemFreeAsync.  If cuMemFreeAsync is used, the free must be completed\n on the importing process before the free operation on the exporting process.\n\n### Note:\n ### Note:\nThe cuMemFreeAsync api may be used in the exporting process before\n       the cuMemFreeAsync operation completes in its stream as long as the\n       cuMemFreeAsync in the exporting process specifies a stream with\n       a stream dependency on the importing process's cuMemFreeAsync.\n\n `aram`[out] ptr_out  - pointer to imported memory\n `aram`[in] pool      - pool from which to import\n `aram`[in] shareData - data specifying the memory to import\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n [cuMemPoolExportToShareableHandle](crate::ffi::cuMemPoolExportToShareableHandle), [cuMemPoolImportFromShareableHandle](crate::ffi::cuMemPoolImportFromShareableHandle), [cuMemPoolExportPointer](crate::ffi::cuMemPoolExportPointer)\n"]
    pub fn cuMemPoolImportPointer(
        ptr_out: *mut CUdeviceptr,
        pool: CUmemoryPool,
        shareData: *mut CUmemPoolPtrExportData,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a generic allocation handle representing a multicast object described by the given properties.\n\n This creates a multicast object as described by `prop`. The number of\n participating devices is specified by [CUmulticastObjectProp](crate::ffi::CUmulticastObjectProp)[numDevices](crate::ffi::numDevices).\n Devices can be added to the multicast object via [cuMulticastAddDevice](crate::ffi::cuMulticastAddDevice).\n All participating devices must be added to the multicast object before memory\n can be bound to it. Memory is bound to the multicast object via either\n [cuMulticastBindMem](crate::ffi::cuMulticastBindMem) or [cuMulticastBindAddr](crate::ffi::cuMulticastBindAddr), and can be unbound via\n [cuMulticastUnbind](crate::ffi::cuMulticastUnbind). The total amount of memory that can be bound per device\n is specified by :CUmulticastObjectProp[size](crate::ffi::size). This size must be a multiple of\n the value returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag\n [CU_MULTICAST_GRANULARITY_MINIMUM](crate::ffi::CU_MULTICAST_GRANULARITY_MINIMUM). For best performance however, the size\n should be aligned to the value returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with\n the flag [CU_MULTICAST_GRANULARITY_RECOMMENDED](crate::ffi::CU_MULTICAST_GRANULARITY_RECOMMENDED).\n\n After all participating devices have been added, multicast objects can also\n be mapped to a device's virtual address space using the virtual memory\n management APIs (see [cuMemMap](crate::ffi::cuMemMap) and [cuMemSetAccess](crate::ffi::cuMemSetAccess)). Multicast objects can\n also be shared with other processes by requesting a shareable handle via\n [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle). Note that the desired types of shareable\n handles must be specified in the bitmask [CUmulticastObjectProp](crate::ffi::CUmulticastObjectProp)[handleTypes](crate::ffi::handleTypes).\n Multicast objects can be released using the virtual memory management API\n [cuMemRelease](crate::ffi::cuMemRelease).\n\n `aram`[out] mcHandle     Value of handle returned.\n `aram`[in]  prop         Properties of the multicast object to create.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMulticastAddDevice](crate::ffi::cuMulticastAddDevice), [cuMulticastBindMem](crate::ffi::cuMulticastBindMem), [cuMulticastBindAddr](crate::ffi::cuMulticastBindAddr), [cuMulticastUnbind](crate::ffi::cuMulticastUnbind)\n ### See also:\n [cuMemCreate](crate::ffi::cuMemCreate), [cuMemRelease](crate::ffi::cuMemRelease), [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle), [cuMemImportFromShareableHandle](crate::ffi::cuMemImportFromShareableHandle)\n"]
    pub fn cuMulticastCreate(
        mcHandle: *mut CUmemGenericAllocationHandle,
        prop: *const CUmulticastObjectProp,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Associate a device to a multicast object.\n\n Associates a device to a multicast object. The added device will be a part of\n the multicast team of size specified by CUmulticastObjectProp[numDevices](crate::ffi::numDevices)\n during [cuMulticastCreate](crate::ffi::cuMulticastCreate).\n The association of the device to the multicast object is permanent during\n the life time of the multicast object.\n All devices must be added to the multicast team before any memory can be\n bound to any device in the team. Any calls to [cuMulticastBindMem](crate::ffi::cuMulticastBindMem) or\n [cuMulticastBindAddr](crate::ffi::cuMulticastBindAddr) will block until all devices have been added.\n Similarly all devices must be added to the multicast team before a virtual\n address range can be mapped to the multicast object. A call to [cuMemMap](crate::ffi::cuMemMap)\n will block until all devices have been added.\n\n `aram`[in] mcHandle     Handle representing a multicast object.\n `aram`[in] dev          Device that will be associated to the multicast\n                         object.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMulticastCreate](crate::ffi::cuMulticastCreate), [cuMulticastBindMem](crate::ffi::cuMulticastBindMem), [cuMulticastBindAddr](crate::ffi::cuMulticastBindAddr)\n"]
    pub fn cuMulticastAddDevice(mcHandle: CUmemGenericAllocationHandle, dev: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Bind a memory allocation represented by a handle to a multicast object.\n\n Binds a memory allocation specified by `memHandle` and created via\n [cuMemCreate](crate::ffi::cuMemCreate) to a multicast object represented by `mcHandle` and created\n via [cuMulticastCreate](crate::ffi::cuMulticastCreate). The intended `size` of the bind, the offset in the\n multicast range `mcOffset` as well as the offset in the memory `memOffset`\n must be a multiple of the value returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with\n the flag [CU_MULTICAST_GRANULARITY_MINIMUM](crate::ffi::CU_MULTICAST_GRANULARITY_MINIMUM). For best performance however,\n `size`, `mcOffset` and `memOffset` should be aligned to the granularity of\n the memory allocation(see [cuMemGetAllocationGranularity](crate::ffi::cuMemGetAllocationGranularity)) or to the value\n returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag\n [CU_MULTICAST_GRANULARITY_RECOMMENDED](crate::ffi::CU_MULTICAST_GRANULARITY_RECOMMENDED).\n\n The `size` + `memOffset` cannot be larger than the size of the allocated\n memory. Similarly the `size` + `mcOffset` cannot be larger than the size\n of the multicast object.\n The memory allocation must have beeen created on one of the devices\n that was added to the multicast team via [cuMulticastAddDevice](crate::ffi::cuMulticastAddDevice).\n Externally shareable as well as imported multicast objects can be bound only\n to externally shareable memory.\n Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if there are\n insufficient resources required to perform the bind. This call may also\n return CUDA_ERROR_SYSTEM_NOT_READY if the necessary system software is not\n initialized or running.\n\n `aram`[in]  mcHandle     Handle representing a multicast object.\n `aram`[in]  mcOffset     Offset into the multicast object for attachment.\n `aram`[in]  memHandle    Handle representing a memory allocation.\n `aram`[in]  memOffset    Offset into the memory for attachment.\n `aram`[in]  size         Size of the memory that will be bound to the\n                          multicast object.\n `aram`[in]  flags        Flags for future use, must be zero for now.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_SYSTEM_NOT_READY](crate::ffi::CUDA_ERROR_SYSTEM_NOT_READY)\n\n ### See also:\n [cuMulticastCreate](crate::ffi::cuMulticastCreate), [cuMulticastAddDevice](crate::ffi::cuMulticastAddDevice), [cuMemCreate](crate::ffi::cuMemCreate)\n"]
    pub fn cuMulticastBindMem(
        mcHandle: CUmemGenericAllocationHandle,
        mcOffset: usize,
        memHandle: CUmemGenericAllocationHandle,
        memOffset: usize,
        size: usize,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Bind a memory allocation represented by a virtual address to a multicast object.\n\n Binds a memory allocation specified by its mapped address `memptr` to a\n multicast object represented by `mcHandle`.\n The memory must have been allocated via [cuMemCreate](crate::ffi::cuMemCreate) or [cudaMallocAsync](crate::ffi::cudaMallocAsync).\n The intended `size` of the bind, the offset in the multicast range\n `mcOffset` and `memptr` must be a multiple of the value returned by\n [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag [CU_MULTICAST_GRANULARITY_MINIMUM](crate::ffi::CU_MULTICAST_GRANULARITY_MINIMUM).\n For best performance however, `size`, `mcOffset` and `memptr` should be\n aligned to the value returned by [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) with the flag\n [CU_MULTICAST_GRANULARITY_RECOMMENDED](crate::ffi::CU_MULTICAST_GRANULARITY_RECOMMENDED).\n\n The `size` cannot be larger than the size of the allocated memory.\n Similarly the `size` + `mcOffset` cannot be larger than the total size\n of the multicast object.\n The memory allocation must have beeen created on one of the devices\n that was added to the multicast team via [cuMulticastAddDevice](crate::ffi::cuMulticastAddDevice).\n Externally shareable as well as imported multicast objects can be bound only\n to externally shareable memory.\n Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if there are\n insufficient resources required to perform the bind. This call may also\n return CUDA_ERROR_SYSTEM_NOT_READY if the necessary system software is not\n initialized or running.\n\n `aram`[in]  mcHandle     Handle representing a multicast object.\n `aram`[in]  mcOffset     Offset into multicast va range for attachment.\n `aram`[in]  memptr       Virtual address of the memory allocation.\n `aram`[in]  size         Size of memory that will be bound to the\n                          multicast object.\n `aram`[in]  flags        Flags for future use, must be zero now.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY),\n [CUDA_ERROR_SYSTEM_NOT_READY](crate::ffi::CUDA_ERROR_SYSTEM_NOT_READY)\n\n ### See also:\n [cuMulticastCreate](crate::ffi::cuMulticastCreate), [cuMulticastAddDevice](crate::ffi::cuMulticastAddDevice), [cuMemCreate](crate::ffi::cuMemCreate)\n"]
    pub fn cuMulticastBindAddr(
        mcHandle: CUmemGenericAllocationHandle,
        mcOffset: usize,
        memptr: CUdeviceptr,
        size: usize,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unbind any memory allocations bound to a multicast object at a given offset and upto a given size.\n\n Unbinds any memory allocations hosted on `dev` and bound to a multicast\n object at `mcOffset` and upto a given `size`.\n The intended `size` of the unbind and the offset in the multicast range\n ( `mcOffset` ) must be a multiple of the value returned by\n [cuMulticastGetGranularity](crate::ffi::cuMulticastGetGranularity) flag [CU_MULTICAST_GRANULARITY_MINIMUM](crate::ffi::CU_MULTICAST_GRANULARITY_MINIMUM).\n The `size` + `mcOffset` cannot be larger than the total size of the\n multicast object.\n\n### Note:\n \\note\n Warning:\n The `mcOffset` and the `size` must match the corresponding values specified\n during the bind call. Any other values may result in undefined behavior.\n\n `aram`[in]  mcHandle     Handle representing a multicast object.\n `aram`[in]  dev          Device that hosts the memory allocation.\n `aram`[in]  mcOffset     Offset into the multicast object.\n `aram`[in]  size         Desired size to unbind.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMulticastBindMem](crate::ffi::cuMulticastBindMem), [cuMulticastBindAddr](crate::ffi::cuMulticastBindAddr)\n"]
    pub fn cuMulticastUnbind(
        mcHandle: CUmemGenericAllocationHandle,
        dev: CUdevice,
        mcOffset: usize,
        size: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Calculates either the minimal or recommended granularity for multicast object\n\n Calculates either the minimal or recommended granularity for a given set of\n multicast object properties and returns it in granularity.  This granularity\n can be used as a multiple for size, bind offsets and address mappings of the\n multicast object.\n\n `aram`[out] granularity Returned granularity.\n `aram`[in]  prop        Properties of the multicast object.\n `aram`[in]  option      Determines which granularity to return.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n [cuMulticastCreate](crate::ffi::cuMulticastCreate), [cuMulticastBindMem](crate::ffi::cuMulticastBindMem), [cuMulticastBindAddr](crate::ffi::cuMulticastBindAddr), [cuMulticastUnbind](crate::ffi::cuMulticastUnbind)\n"]
    pub fn cuMulticastGetGranularity(
        granularity: *mut usize,
        prop: *const CUmulticastObjectProp,
        option: CUmulticastGranularity_flags,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns information about a pointer\n\n The supported attributes are:\n\n - [CU_POINTER_ATTRIBUTE_CONTEXT](crate::ffi::CU_POINTER_ATTRIBUTE_CONTEXT):\n\n      Returns in `*data` the [CUcontext](crate::ffi::CUcontext) in which `ptr` was allocated or\n      registered.\n      The type of `data` must be [CUcontext](crate::ffi::CUcontext) *.\n\n      If `ptr` was not allocated by, mapped by, or registered with\n      a [CUcontext](crate::ffi::CUcontext) which uses unified virtual addressing then\n      [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n - [CU_POINTER_ATTRIBUTE_MEMORY_TYPE](crate::ffi::CU_POINTER_ATTRIBUTE_MEMORY_TYPE):\n\n      Returns in `*data` the physical memory type of the memory that\n      `ptr` addresses as a [CUmemorytype](crate::ffi::CUmemorytype) enumerated value.\n      The type of `data` must be unsigned int.\n\n      If `ptr` addresses device memory then `*data` is set to\n      [CU_MEMORYTYPE_DEVICE](crate::ffi::CU_MEMORYTYPE_DEVICE).  The particular [CUdevice](crate::ffi::CUdevice) on which the\n      memory resides is the [CUdevice](crate::ffi::CUdevice) of the [CUcontext](crate::ffi::CUcontext) returned by the\n      [CU_POINTER_ATTRIBUTE_CONTEXT](crate::ffi::CU_POINTER_ATTRIBUTE_CONTEXT) attribute of `ptr`.\n\n      If `ptr` addresses host memory then `*data` is set to\n      [CU_MEMORYTYPE_HOST](crate::ffi::CU_MEMORYTYPE_HOST).\n\n      If `ptr` was not allocated by, mapped by, or registered with\n      a [CUcontext](crate::ffi::CUcontext) which uses unified virtual addressing then\n      [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n      If the current [CUcontext](crate::ffi::CUcontext) does not support unified virtual\n      addressing then [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) is returned.\n\n - [CU_POINTER_ATTRIBUTE_DEVICE_POINTER](crate::ffi::CU_POINTER_ATTRIBUTE_DEVICE_POINTER):\n\n      Returns in `*data` the device pointer value through which\n      `ptr` may be accessed by kernels running in the current\n      [CUcontext](crate::ffi::CUcontext).\n      The type of `data` must be CUdeviceptr *.\n\n      If there exists no device pointer value through which\n      kernels running in the current [CUcontext](crate::ffi::CUcontext) may access\n      `ptr` then [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n      If there is no current [CUcontext](crate::ffi::CUcontext) then\n      [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) is returned.\n\n      Except in the exceptional disjoint addressing cases discussed\n      below, the value returned in `*data` will equal the input\n      value `ptr`.\n\n - [CU_POINTER_ATTRIBUTE_HOST_POINTER](crate::ffi::CU_POINTER_ATTRIBUTE_HOST_POINTER):\n\n      Returns in `*data` the host pointer value through which\n      `ptr` may be accessed by by the host program.\n      The type of `data` must be void **.\n      If there exists no host pointer value through which\n      the host program may directly access `ptr` then\n      [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n      Except in the exceptional disjoint addressing cases discussed\n      below, the value returned in `*data` will equal the input\n      value `ptr`.\n\n - [CU_POINTER_ATTRIBUTE_P2P_TOKENS](crate::ffi::CU_POINTER_ATTRIBUTE_P2P_TOKENS):\n\n      Returns in `*data` two tokens for use with the nv-p2p.h Linux\n      kernel interface. `data` must be a struct of type\n      CUDA_POINTER_ATTRIBUTE_P2P_TOKENS.\n\n      `ptr` must be a pointer to memory obtained from :cuMemAlloc().\n      Note that p2pToken and vaSpaceToken are only valid for the\n      lifetime of the source allocation. A subsequent allocation at\n      the same address may return completely different tokens.\n      Querying this attribute has a side effect of setting the attribute\n      [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](crate::ffi::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS) for the region of memory that\n      `ptr` points to.\n\n - [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](crate::ffi::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS):\n\n      A boolean attribute which when set, ensures that synchronous memory operations\n      initiated on the region of memory that `ptr` points to will always synchronize.\n      See further documentation in the section titled \"API synchronization behavior\"\n      to learn more about cases when synchronous memory operations can\n      exhibit asynchronous behavior.\n\n - [CU_POINTER_ATTRIBUTE_BUFFER_ID](crate::ffi::CU_POINTER_ATTRIBUTE_BUFFER_ID):\n\n      Returns in `*data` a buffer ID which is guaranteed to be unique within the process.\n      `data` must point to an unsigned long long.\n\n      `ptr` must be a pointer to memory obtained from a CUDA memory allocation API.\n      Every memory allocation from any of the CUDA memory allocation APIs will\n      have a unique ID over a process lifetime. Subsequent allocations do not reuse IDs\n      from previous freed allocations. IDs are only unique within a single process.\n\n\n - [CU_POINTER_ATTRIBUTE_IS_MANAGED](crate::ffi::CU_POINTER_ATTRIBUTE_IS_MANAGED):\n\n      Returns in `*data` a boolean that indicates whether the pointer points to\n      managed memory or not.\n\n      If `ptr` is not a valid CUDA pointer then [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n - [CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL](crate::ffi::CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL):\n\n      Returns in `*data` an integer representing a device ordinal of a device against\n      which the memory was allocated or registered.\n\n - [CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE](crate::ffi::CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE):\n\n      Returns in `*data` a boolean that indicates if this pointer maps to\n      an allocation that is suitable for [cudaIpcGetMemHandle](crate::ffi::cudaIpcGetMemHandle).\n\n - [CU_POINTER_ATTRIBUTE_RANGE_START_ADDR](crate::ffi::CU_POINTER_ATTRIBUTE_RANGE_START_ADDR):\n\n      Returns in `*data` the starting address for the allocation referenced\n      by the device pointer `ptr`.  Note that this is not necessarily the\n      address of the mapped region, but the address of the mappable address\n      range `ptr` references (e.g. from [cuMemAddressReserve](crate::ffi::cuMemAddressReserve)).\n\n - [CU_POINTER_ATTRIBUTE_RANGE_SIZE](crate::ffi::CU_POINTER_ATTRIBUTE_RANGE_SIZE):\n\n      Returns in `*data` the size for the allocation referenced by the device\n      pointer `ptr`.  Note that this is not necessarily the size of the mapped\n      region, but the size of the mappable address range `ptr` references\n      (e.g. from [cuMemAddressReserve](crate::ffi::cuMemAddressReserve)).  To retrieve the size of the mapped\n      region, see [cuMemGetAddressRange](crate::ffi::cuMemGetAddressRange)\n\n - [CU_POINTER_ATTRIBUTE_MAPPED](crate::ffi::CU_POINTER_ATTRIBUTE_MAPPED):\n\n      Returns in `*data` a boolean that indicates if this pointer is in a\n      valid address range that is mapped to a backing allocation.\n\n - [CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES](crate::ffi::CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES):\n\n      Returns a bitmask of the allowed handle types for an allocation that may\n      be passed to [cuMemExportToShareableHandle](crate::ffi::cuMemExportToShareableHandle).\n\n - [CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE](crate::ffi::CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE):\n\n      Returns in `*data` the handle to the mempool that the allocation was obtained from.\n\n - [CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE](crate::ffi::CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE):\n\n      Returns in `*data` a boolean that indicates whether the pointer points\n      to memory that is capable to be used for hardware accelerated\n      decompression.\n\n `ar`\n\n Note that for most allocations in the unified virtual address space\n the host and device pointer for accessing the allocation will be the\n same.  The exceptions to this are\n  - user memory registered using [cuMemHostRegister](crate::ffi::cuMemHostRegister)\n  - host memory allocated using [cuMemHostAlloc](crate::ffi::cuMemHostAlloc) with the\n    [CU_MEMHOSTALLOC_WRITECOMBINED](crate::ffi::CU_MEMHOSTALLOC_WRITECOMBINED) flag\n For these types of allocation there will exist separate, disjoint host\n and device addresses for accessing the allocation.  In particular\n  - The host address will correspond to an invalid unmapped device address\n    (which will result in an exception if accessed from the device)\n  - The device address will correspond to an invalid unmapped host address\n    (which will result in an exception if accessed from the host).\n For these types of allocations, querying [CU_POINTER_ATTRIBUTE_HOST_POINTER](crate::ffi::CU_POINTER_ATTRIBUTE_HOST_POINTER)\n and [CU_POINTER_ATTRIBUTE_DEVICE_POINTER](crate::ffi::CU_POINTER_ATTRIBUTE_DEVICE_POINTER) may be used to retrieve the host\n and device addresses from either address.\n#### data:\n- Returned pointer attribute value\n#### attribute:\n- Pointer attribute to query\n#### ptr:\n- Pointer\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuPointerSetAttribute](crate::ffi::cuPointerSetAttribute),\n [cuMemAlloc](crate::ffi::cuMemAlloc),\n [cuMemFree](crate::ffi::cuMemFree),\n [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostRegister](crate::ffi::cuMemHostRegister),\n [cuMemHostUnregister](crate::ffi::cuMemHostUnregister),\n [cudaPointerGetAttributes](crate::ffi::cudaPointerGetAttributes)\n"]
    pub fn cuPointerGetAttribute(
        data: *mut ::std::ffi::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Prefetches memory to the specified destination device\n\n Note there is a later version of this API, [cuMemPrefetchAsync_v2](crate::ffi::cuMemPrefetchAsync_v2). It will\n supplant this version in 13.0, which is retained for minor version compatibility.\n\n Prefetches memory to the specified destination device.  `devPtr` is the\n base device pointer of the memory to be prefetched and `dstDevice` is the\n destination device. `count` specifies the number of bytes to copy. `hStream`\n is the stream in which the operation is enqueued. The memory range must refer\n to managed memory allocated via [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) or declared via __managed__ variables\n or it may also refer to system-allocated memory on systems with non-zero\n CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS.\n\n Passing in CU_DEVICE_CPU for `dstDevice` will prefetch the data to host memory. If\n `dstDevice` is a GPU, then the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS)\n must be non-zero. Additionally, `hStream` must be associated with a device that has a\n non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS).\n\n The start address and end address of the memory range will be rounded down and rounded up\n respectively to be aligned to CPU page size before the prefetch operation is enqueued\n in the stream.\n\n If no physical memory has been allocated for this region, then this memory region\n will be populated and mapped on the destination device. If there's insufficient\n memory to prefetch the desired region, the Unified Memory driver may evict pages from other\n [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) allocations to host memory in order to make room. Device memory\n allocated using [cuMemAlloc](crate::ffi::cuMemAlloc) or [cuArrayCreate](crate::ffi::cuArrayCreate) will not be evicted.\n\n By default, any mappings to the previous location of the migrated pages are removed and\n mappings for the new location are only setup on `dstDevice`. The exact behavior however\n also depends on the settings applied to this memory range via [cuMemAdvise](crate::ffi::cuMemAdvise) as described\n below:\n\n If [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) was set on any subset of this memory range,\n then that subset will create a read-only copy of the pages on `dstDevice`.\n\n If [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION) was called on any subset of this memory\n range, then the pages will be migrated to `dstDevice` even if `dstDevice` is not the\n preferred location of any pages in the memory range.\n\n If [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY) was called on any subset of this memory range,\n then mappings to those pages from all the appropriate processors are updated to\n refer to the new location if establishing such a mapping is possible. Otherwise,\n those mappings are cleared.\n\n Note that this API is not required for functionality and only serves to improve performance\n by allowing the application to migrate data to a suitable location before it is accessed.\n Memory accesses to this range are always coherent and are allowed even when the data is\n actively being migrated.\n\n Note that this function is asynchronous with respect to the host and all work\n on other devices.\n#### devPtr:\n- Pointer to be prefetched\n#### count:\n- Size in bytes\n#### dstDevice:\n- Destination device to prefetch to\n#### hStream:\n- Stream to enqueue prefetch operation\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemcpy](crate::ffi::cuMemcpy), [cuMemcpyPeer](crate::ffi::cuMemcpyPeer), [cuMemcpyAsync](crate::ffi::cuMemcpyAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync), [cuMemAdvise](crate::ffi::cuMemAdvise), [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync)\n [cudaMemPrefetchAsync_v2](crate::ffi::cudaMemPrefetchAsync_v2)\n"]
    pub fn cuMemPrefetchAsync(
        devPtr: CUdeviceptr,
        count: usize,
        dstDevice: CUdevice,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Prefetches memory to the specified destination location\n\n Prefetches memory to the specified destination location.  `devPtr` is the\n base device pointer of the memory to be prefetched and `location` specifies the\n destination location. `count` specifies the number of bytes to copy. `hStream`\n is the stream in which the operation is enqueued. The memory range must refer\n to managed memory allocated via [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) or declared via __managed__ variables.\n\n Specifying [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE) for [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) will prefetch memory to GPU\n specified by device ordinal [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) which must have non-zero value for the device attribute\n [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS). Additionally, `hStream` must be associated with a device\n that has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS).\n Specifying [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST) as [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) will prefetch data to host memory.\n Applications can request prefetching memory to a specific host NUMA node by specifying\n [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA) for [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) and a valid host NUMA node id in [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id)\n Users can also request prefetching memory to the host NUMA node closest to the current thread's CPU by specifying\n [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT) for [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type). Note when [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is etiher\n [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST) OR [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT), [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) will be ignored.\n\n The start address and end address of the memory range will be rounded down and rounded up\n respectively to be aligned to CPU page size before the prefetch operation is enqueued\n in the stream.\n\n If no physical memory has been allocated for this region, then this memory region\n will be populated and mapped on the destination device. If there's insufficient\n memory to prefetch the desired region, the Unified Memory driver may evict pages from other\n [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) allocations to host memory in order to make room. Device memory\n allocated using [cuMemAlloc](crate::ffi::cuMemAlloc) or [cuArrayCreate](crate::ffi::cuArrayCreate) will not be evicted.\n\n By default, any mappings to the previous location of the migrated pages are removed and\n mappings for the new location are only setup on the destination location. The exact behavior however\n also depends on the settings applied to this memory range via [cuMemAdvise](crate::ffi::cuMemAdvise) as described\n below:\n\n If [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) was set on any subset of this memory range,\n then that subset will create a read-only copy of the pages on destination location.\n If however the destination location is a host NUMA node, then any pages of that subset\n that are already in another host NUMA node will be transferred to the destination.\n\n If [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION) was called on any subset of this memory\n range, then the pages will be migrated to `location` even if `location` is not the\n preferred location of any pages in the memory range.\n\n If [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY) was called on any subset of this memory range,\n then mappings to those pages from all the appropriate processors are updated to\n refer to the new location if establishing such a mapping is possible. Otherwise,\n those mappings are cleared.\n\n Note that this API is not required for functionality and only serves to improve performance\n by allowing the application to migrate data to a suitable location before it is accessed.\n Memory accesses to this range are always coherent and are allowed even when the data is\n actively being migrated.\n\n Note that this function is asynchronous with respect to the host and all work\n on other devices.\n#### devPtr:\n- Pointer to be prefetched\n#### count:\n- Size in bytes\n#### dstDevice:\n- Destination device to prefetch to\n#### flags:\n- flags for future use, must be zero now.\n#### hStream:\n- Stream to enqueue prefetch operation\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemcpy](crate::ffi::cuMemcpy), [cuMemcpyPeer](crate::ffi::cuMemcpyPeer), [cuMemcpyAsync](crate::ffi::cuMemcpyAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync), [cuMemAdvise](crate::ffi::cuMemAdvise), [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync)\n [cudaMemPrefetchAsync_v2](crate::ffi::cudaMemPrefetchAsync_v2)\n"]
    pub fn cuMemPrefetchAsync_v2(
        devPtr: CUdeviceptr,
        count: usize,
        location: CUmemLocation,
        flags: ::std::ffi::c_uint,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Advise about the usage of a given memory range\n\n Note there is a later version of this API, [cuMemAdvise_v2](crate::ffi::cuMemAdvise_v2). It will\n supplant this version in 13.0, which is retained for minor version compatibility.\n\n Advise the Unified Memory subsystem about the usage pattern for the memory range\n starting at `devPtr` with a size of `count` bytes. The start address and end address of the memory\n range will be rounded down and rounded up respectively to be aligned to CPU page size before the\n advice is applied. The memory range must refer to managed memory allocated via [cuMemAllocManaged](crate::ffi::cuMemAllocManaged)\n or declared via __managed__ variables. The memory range could also refer to system-allocated pageable\n memory provided it represents a valid, host-accessible region of memory and all additional constraints\n imposed by `advice` as outlined below are also satisfied. Specifying an invalid system-allocated pageable\n memory range results in an error being returned.\n\n The `advice` parameter can take the following values:\n - [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY): This implies that the data is mostly going to be read\n from and only occasionally written to. Any read accesses from any processor to this region will create a\n read-only copy of at least the accessed pages in that processor's memory. Additionally, if [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync)\n is called on this region, it will create a read-only copy of the data on the destination processor.\n If any processor writes to this region, all copies of the corresponding page will be invalidated\n except for the one where the write occurred. The `device` argument is ignored for this advice.\n Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU\n that has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS).\n Also, if a context is created on a device that does not have the device attribute\n [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS) set, then read-duplication will not occur until\n all such contexts are destroyed.\n If the memory region refers to valid system-allocated pageable memory, then the accessing device must\n have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS) for a read-only\n copy to be created on that device. Note however that if the accessing device also has a non-zero value for the\n device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES), then setting this advice\n will not create a read-only copy when that device accesses this memory region.\n\n - [CU_MEM_ADVISE_UNSET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_UNSET_READ_MOSTLY):  Undoes the effect of [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) and also prevents the\n Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated\n copies of the data will be collapsed into a single copy. The location for the collapsed\n copy will be the preferred location if the page has a preferred location and one of the read-duplicated\n copies was resident at that location. Otherwise, the location chosen is arbitrary.\n\n - [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION): This advice sets the preferred location for the\n data to be the memory belonging to `device`. Passing in CU_DEVICE_CPU for `device` sets the\n preferred location as host memory. If `device` is a GPU, then it must have a non-zero value for the\n device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS). Setting the preferred location\n does not cause data to migrate to that location immediately. Instead, it guides the migration policy\n when a fault occurs on that memory region. If the data is already in its preferred location and the\n faulting processor can establish a mapping without requiring the data to be migrated, then\n data migration will be avoided. On the other hand, if the data is not in its preferred location\n or if a direct mapping cannot be established, then it will be migrated to the processor accessing\n it. It is important to note that setting the preferred location does not prevent data prefetching\n done using [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync).\n Having a preferred location can override the page thrash detection and resolution logic in the Unified\n Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device\n memory, the page may eventually be pinned to host memory by the Unified Memory driver. But\n if the preferred location is set as device memory, then the page will continue to thrash indefinitely.\n If [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice, unless read accesses from\n `device` will not result in a read-only copy being created on that device as outlined in description for\n the advice [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY).\n If the memory region refers to valid system-allocated pageable memory, then `device` must have a non-zero\n value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS).\n\n - [CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION): Undoes the effect of [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION)\n and changes the preferred location to none.\n\n - [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY): This advice implies that the data will be accessed by `device`.\n Passing in [CU_DEVICE_CPU](crate::ffi::CU_DEVICE_CPU) for `device` will set the advice for the CPU. If `device` is a GPU, then\n the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS) must be non-zero.\n This advice does not cause data migration and has no impact on the location of the data per se. Instead,\n it causes the data to always be mapped in the specified processor's page tables, as long as the\n location of the data permits a mapping to be established. If the data gets migrated for any reason,\n the mappings are updated accordingly.\n This advice is recommended in scenarios where data locality is not important, but avoiding faults is.\n Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the\n data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data\n over to the other GPUs is not as important because the accesses are infrequent and the overhead of\n migration may be too high. But preventing faults can still help improve performance, and so having\n a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated\n to host memory because the CPU typically cannot access device memory directly. Any GPU that had the\n [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY) flag set for this data will now have its mapping updated to point to the\n page in host memory.\n If [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice. Additionally, if the\n preferred location of this memory region or any subset of it is also `device`, then the policies\n associated with [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION) will override the policies of this advice.\n If the memory region refers to valid system-allocated pageable memory, then `device` must have a non-zero\n value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS). Additionally, if `device` has\n a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES),\n then this call has no effect.\n\n - [CU_MEM_ADVISE_UNSET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_UNSET_ACCESSED_BY): Undoes the effect of [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY). Any mappings to\n the data from `device` may be removed at any time causing accesses to result in non-fatal page faults.\n If the memory region refers to valid system-allocated pageable memory, then `device` must have a non-zero\n value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS). Additionally, if `device` has\n a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES),\n then this call has no effect.\n#### devPtr:\n- Pointer to memory to set the advice for\n#### count:\n- Size in bytes of the memory range\n#### advice:\n- Advice to be applied for the specified memory range\n#### device:\n- Device to apply the advice for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemcpy](crate::ffi::cuMemcpy), [cuMemcpyPeer](crate::ffi::cuMemcpyPeer), [cuMemcpyAsync](crate::ffi::cuMemcpyAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync), [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync), [cuMemAdvise_v2](crate::ffi::cuMemAdvise_v2)\n [cudaMemAdvise](crate::ffi::cudaMemAdvise)\n"]
    pub fn cuMemAdvise(
        devPtr: CUdeviceptr,
        count: usize,
        advice: CUmem_advise,
        device: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Advise about the usage of a given memory range\n\n Advise the Unified Memory subsystem about the usage pattern for the memory range\n starting at `devPtr` with a size of `count` bytes. The start address and end address of the memory\n range will be rounded down and rounded up respectively to be aligned to CPU page size before the\n advice is applied. The memory range must refer to managed memory allocated via [cuMemAllocManaged](crate::ffi::cuMemAllocManaged)\n or declared via __managed__ variables. The memory range could also refer to system-allocated pageable\n memory provided it represents a valid, host-accessible region of memory and all additional constraints\n imposed by `advice` as outlined below are also satisfied. Specifying an invalid system-allocated pageable\n memory range results in an error being returned.\n\n The `advice` parameter can take the following values:\n - [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY): This implies that the data is mostly going to be read\n from and only occasionally written to. Any read accesses from any processor to this region will create a\n read-only copy of at least the accessed pages in that processor's memory. Additionally, if [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync)\n or [cuMemPrefetchAsync_v2](crate::ffi::cuMemPrefetchAsync_v2) is called on this region, it will create a read-only copy of the data on the destination processor.\n If the target location for [cuMemPrefetchAsync_v2](crate::ffi::cuMemPrefetchAsync_v2) is a host NUMA node and a read-only copy already exists on\n another host NUMA node, that copy will be migrated to the targeted host NUMA node.\n If any processor writes to this region, all copies of the corresponding page will be invalidated\n except for the one where the write occurred. If the writing processor is the CPU and the preferred location of\n the page is a host NUMA node, then the page will also be migrated to that host NUMA node. The `location` argument is ignored for this advice.\n Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU\n that has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS).\n Also, if a context is created on a device that does not have the device attribute\n [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS) set, then read-duplication will not occur until\n all such contexts are destroyed.\n If the memory region refers to valid system-allocated pageable memory, then the accessing device must\n have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS) for a read-only\n copy to be created on that device. Note however that if the accessing device also has a non-zero value for the\n device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES), then setting this advice\n will not create a read-only copy when that device accesses this memory region.\n\n - [CU_MEM_ADVISE_UNSET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_UNSET_READ_MOSTLY):  Undoes the effect of [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) and also prevents the\n Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated\n copies of the data will be collapsed into a single copy. The location for the collapsed\n copy will be the preferred location if the page has a preferred location and one of the read-duplicated\n copies was resident at that location. Otherwise, the location chosen is arbitrary.\n Note: The `location` argument is ignored for this advice.\n\n - [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION): This advice sets the preferred location for the\n data to be the memory belonging to `location`. When [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST),\n [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) is ignored and the preferred location is set to be host memory. To set the preferred location\n to a specific host NUMA node, applications must set [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) to [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA) and\n [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must specify the NUMA ID of the host NUMA node. If [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is set to [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT),\n [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) will be ignored and the the host NUMA node closest to the calling thread's CPU will be used as the preferred location.\n If [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is a [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE), then [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must be a valid device ordinal\n and the device must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS).\n Setting the preferred location does not cause data to migrate to that location immediately. Instead, it guides the migration policy\n when a fault occurs on that memory region. If the data is already in its preferred location and the\n faulting processor can establish a mapping without requiring the data to be migrated, then\n data migration will be avoided. On the other hand, if the data is not in its preferred location\n or if a direct mapping cannot be established, then it will be migrated to the processor accessing\n it. It is important to note that setting the preferred location does not prevent data prefetching\n done using [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync).\n Having a preferred location can override the page thrash detection and resolution logic in the Unified\n Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device\n memory, the page may eventually be pinned to host memory by the Unified Memory driver. But\n if the preferred location is set as device memory, then the page will continue to thrash indefinitely.\n If [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice, unless read accesses from\n `location` will not result in a read-only copy being created on that procesor as outlined in description for\n the advice [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY).\n If the memory region refers to valid system-allocated pageable memory, and [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is CU_MEM_LOCATION_TYPE_DEVICE\n then [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must be a valid device that has a non-zero alue for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS).\n\n - [CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION): Undoes the effect of [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION)\n and changes the preferred location to none. The `location` argument is ignored for this advice.\n\n - [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY): This advice implies that the data will be accessed by processor `location`.\n The [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) must be either [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE) with [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) representing a valid device\n ordinal or [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST) and [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) will be ignored. All other location types are invalid.\n If [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) is a GPU, then the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS) must be non-zero.\n This advice does not cause data migration and has no impact on the location of the data per se. Instead,\n it causes the data to always be mapped in the specified processor's page tables, as long as the\n location of the data permits a mapping to be established. If the data gets migrated for any reason,\n the mappings are updated accordingly.\n This advice is recommended in scenarios where data locality is not important, but avoiding faults is.\n Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the\n data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data\n over to the other GPUs is not as important because the accesses are infrequent and the overhead of\n migration may be too high. But preventing faults can still help improve performance, and so having\n a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated\n to host memory because the CPU typically cannot access device memory directly. Any GPU that had the\n [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY) flag set for this data will now have its mapping updated to point to the\n page in host memory.\n If [CU_MEM_ADVISE_SET_READ_MOSTLY](crate::ffi::CU_MEM_ADVISE_SET_READ_MOSTLY) is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice. Additionally, if the\n preferred location of this memory region or any subset of it is also `location`, then the policies\n associated with [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](crate::ffi::CU_MEM_ADVISE_SET_PREFERRED_LOCATION) will override the policies of this advice.\n If the memory region refers to valid system-allocated pageable memory, and [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE)\n then device in [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS).\n Additionally, if [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES),\n then this call has no effect.\n\n - [CU_MEM_ADVISE_UNSET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_UNSET_ACCESSED_BY): Undoes the effect of [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY). Any mappings to\n the data from `location` may be removed at any time causing accesses to result in non-fatal page faults.\n If the memory region refers to valid system-allocated pageable memory, and [CUmemLocation](crate::ffi::CUmemLocation)[type](crate::ffi::type) is [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE)\n then device in [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS).\n Additionally, if [CUmemLocation](crate::ffi::CUmemLocation)[id](crate::ffi::id) has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES),\n then this call has no effect.\n#### devPtr:\n- Pointer to memory to set the advice for\n#### count:\n- Size in bytes of the memory range\n#### advice:\n- Advice to be applied for the specified memory range\n#### location:\n- location to apply the advice for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemcpy](crate::ffi::cuMemcpy), [cuMemcpyPeer](crate::ffi::cuMemcpyPeer), [cuMemcpyAsync](crate::ffi::cuMemcpyAsync),\n [cuMemcpy3DPeerAsync](crate::ffi::cuMemcpy3DPeerAsync), [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync), [cuMemAdvise](crate::ffi::cuMemAdvise)\n [cudaMemAdvise](crate::ffi::cudaMemAdvise)\n"]
    pub fn cuMemAdvise_v2(
        devPtr: CUdeviceptr,
        count: usize,
        advice: CUmem_advise,
        location: CUmemLocation,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query an attribute of a given memory range\n\n Query an attribute about the memory range starting at `devPtr` with a size of `count` bytes. The\n memory range must refer to managed memory allocated via [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) or declared via\n __managed__ variables.\n\n The `attribute` parameter can take the following values:\n - [CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY): If this attribute is specified, `data` will be interpreted\n as a 32-bit integer, and `dataSize` must be 4. The result returned will be 1 if all pages in the given\n memory range have read-duplication enabled, or 0 otherwise.\n - [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION): If this attribute is specified, `data` will be\n interpreted as a 32-bit integer, and `dataSize` must be 4. The result returned will be a GPU device\n id if all pages in the memory range have that GPU as their preferred location, or it will be CU_DEVICE_CPU\n if all pages in the memory range have the CPU as their preferred location, or it will be CU_DEVICE_INVALID\n if either all the pages don't have the same preferred location or some of the pages don't have a\n preferred location at all. Note that the actual location of the pages in the memory range at the time of\n the query may be different from the preferred location.\n - [CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY): If this attribute is specified, `data` will be interpreted\n as an array of 32-bit integers, and `dataSize` must be a non-zero multiple of 4. The result returned\n will be a list of device ids that had [CU_MEM_ADVISE_SET_ACCESSED_BY](crate::ffi::CU_MEM_ADVISE_SET_ACCESSED_BY) set for that entire memory range.\n If any device does not have that advice set for the entire memory range, that device will not be included.\n If `data` is larger than the number of devices that have that advice set for that memory range,\n CU_DEVICE_INVALID will be returned in all the extra space provided. For ex., if `dataSize` is 12\n (i.e. `data` has 3 elements) and only device 0 has the advice set, then the result returned will be\n { 0, CU_DEVICE_INVALID, CU_DEVICE_INVALID }. If `data` is smaller than the number of devices that have\n that advice set, then only as many devices will be returned as can fit in the array. There is no\n guarantee on which specific devices will be returned, however.\n - [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION): If this attribute is specified, `data` will be\n interpreted as a 32-bit integer, and `dataSize` must be 4. The result returned will be the last location\n to which all pages in the memory range were prefetched explicitly via [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync). This will either be\n a GPU id or CU_DEVICE_CPU depending on whether the last location for prefetch was a GPU or the CPU\n respectively. If any page in the memory range was never explicitly prefetched or if all pages were not\n prefetched to the same location, CU_DEVICE_INVALID will be returned. Note that this simply returns the\n last location that the application requested to prefetch the memory range to. It gives no indication as to\n whether the prefetch operation to that location has completed or even begun.\n - [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE): If this attribute is specified, `data` will be\n interpreted as a [CUmemLocationType](crate::ffi::CUmemLocationType), and `dataSize` must be sizeof(CUmemLocationType). The [CUmemLocationType](crate::ffi::CUmemLocationType) returned will be\n [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE) if all pages in the memory range have the same GPU as their preferred location, or [CUmemLocationType](crate::ffi::CUmemLocationType)\n will be [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST) if all pages in the memory range have the CPU as their preferred location, or it will be [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA)\n if all the pages in the memory range have the same host NUMA node ID as their preferred location or it will be [CU_MEM_LOCATION_TYPE_INVALID](crate::ffi::CU_MEM_LOCATION_TYPE_INVALID)\n if either all the pages don't have the same preferred location or some of the pages don't have a preferred location at all.\n Note that the actual location type of the pages in the memory range at the time of the query may be different from the preferred location type.\n  - [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID): If this attribute is specified, `data` will be\n interpreted as a 32-bit integer, and `dataSize` must be 4. If the [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE) query for the same address range\n returns [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE), it will be a valid device ordinal or if it returns [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA), it will be a valid host NUMA node ID\n or if it returns any other location type, the id should be ignored.\n - [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE): If this attribute is specified, `data` will be\n interpreted as a [CUmemLocationType](crate::ffi::CUmemLocationType), and `dataSize` must be sizeof(CUmemLocationType). The result returned will be the last location\n to which all pages in the memory range were prefetched explicitly via [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync). The [CUmemLocationType](crate::ffi::CUmemLocationType) returned\n will be [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE) if the last prefetch location was a GPU or [CU_MEM_LOCATION_TYPE_HOST](crate::ffi::CU_MEM_LOCATION_TYPE_HOST) if it was the CPU or [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA) if\n the last prefetch location was a specific host NUMA node. If any page in the memory range was never explicitly prefetched or if all pages were not\n prefetched to the same location, [CUmemLocationType](crate::ffi::CUmemLocationType) will be [CU_MEM_LOCATION_TYPE_INVALID](crate::ffi::CU_MEM_LOCATION_TYPE_INVALID).\n Note that this simply returns the last location type that the application requested to prefetch the memory range to. It gives no indication as to\n whether the prefetch operation to that location has completed or even begun.\n  - [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID): If this attribute is specified, `data` will be\n interpreted as a 32-bit integer, and `dataSize` must be 4. If the [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE) query for the same address range\n returns [CU_MEM_LOCATION_TYPE_DEVICE](crate::ffi::CU_MEM_LOCATION_TYPE_DEVICE), it will be a valid device ordinal or if it returns [CU_MEM_LOCATION_TYPE_HOST_NUMA](crate::ffi::CU_MEM_LOCATION_TYPE_HOST_NUMA), it will be a valid host NUMA node ID\n or if it returns any other location type, the id should be ignored.\n#### data:\n- A pointers to a memory location where the result\n                    of each attribute query will be written to.\n#### dataSize:\n- Array containing the size of data\n#### attribute:\n- The attribute to query\n#### devPtr:\n- Start of the range to query\n#### count:\n- Size of the range to query\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n This function exhibits [asynchronous](https://docs.nvidia.com/cuda/cuda-driver-api/api-sync-behavior.html#api-sync-behavior__memcpy-async) behavior for most use cases.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n\n ### See also:\n [cuMemRangeGetAttributes](crate::ffi::cuMemRangeGetAttributes), [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync),\n [cuMemAdvise](crate::ffi::cuMemAdvise),\n [cudaMemRangeGetAttribute](crate::ffi::cudaMemRangeGetAttribute)\n"]
    pub fn cuMemRangeGetAttribute(
        data: *mut ::std::ffi::c_void,
        dataSize: usize,
        attribute: CUmem_range_attribute,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query attributes of a given memory range.\n\n Query attributes of the memory range starting at `devPtr` with a size of `count` bytes. The\n memory range must refer to managed memory allocated via [cuMemAllocManaged](crate::ffi::cuMemAllocManaged) or declared via\n __managed__ variables. The `attributes` array will be interpreted to have `numAttributes`\n entries. The `dataSizes` array will also be interpreted to have `numAttributes` entries.\n The results of the query will be stored in `data`.\n\n The list of supported attributes are given below. Please refer to [cuMemRangeGetAttribute](crate::ffi::cuMemRangeGetAttribute) for\n attribute descriptions and restrictions.\n\n - [CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY)\n - [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION)\n - [CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY)\n - [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION)\n - [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE)\n - [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID)\n - [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE)\n - [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID](crate::ffi::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID)\n#### data:\n- A two-dimensional array containing pointers to memory\n                        locations where the result of each attribute query will be written to.\n#### dataSizes:\n- Array containing the sizes of each result\n#### attributes:\n- An array of attributes to query\n                        (numAttributes and the number of attributes in this array should match)\n#### numAttributes:\n- Number of attributes to query\n#### devPtr:\n- Start of the range to query\n#### count:\n- Size of the range to query\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuMemRangeGetAttribute](crate::ffi::cuMemRangeGetAttribute), [cuMemAdvise](crate::ffi::cuMemAdvise),\n [cuMemPrefetchAsync](crate::ffi::cuMemPrefetchAsync),\n [cudaMemRangeGetAttributes](crate::ffi::cudaMemRangeGetAttributes)\n"]
    pub fn cuMemRangeGetAttributes(
        data: *mut *mut ::std::ffi::c_void,
        dataSizes: *mut usize,
        attributes: *mut CUmem_range_attribute,
        numAttributes: usize,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Set attributes on a previously allocated memory region\n\n The supported attributes are:\n\n - [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](crate::ffi::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS):\n\n      A boolean attribute that can either be set (1) or unset (0). When set,\n      the region of memory that `ptr` points to is guaranteed to always synchronize\n      memory operations that are synchronous. If there are some previously initiated\n      synchronous memory operations that are pending when this attribute is set, the\n      function does not return until those memory operations are complete.\n      See further documentation in the section titled \"API synchronization behavior\"\n      to learn more about cases when synchronous memory operations can\n      exhibit asynchronous behavior.\n      `value` will be considered as a pointer to an unsigned integer to which this attribute is to be set.\n#### value:\n- Pointer to memory containing the value to be set\n#### attribute:\n- Pointer attribute to set\n#### ptr:\n- Pointer to a memory region allocated using CUDA memory allocation APIs\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuPointerGetAttribute](crate::ffi::cuPointerGetAttribute),\n [cuPointerGetAttributes](crate::ffi::cuPointerGetAttributes),\n [cuMemAlloc](crate::ffi::cuMemAlloc),\n [cuMemFree](crate::ffi::cuMemFree),\n [cuMemAllocHost](crate::ffi::cuMemAllocHost),\n [cuMemFreeHost](crate::ffi::cuMemFreeHost),\n [cuMemHostAlloc](crate::ffi::cuMemHostAlloc),\n [cuMemHostRegister](crate::ffi::cuMemHostRegister),\n [cuMemHostUnregister](crate::ffi::cuMemHostUnregister)\n"]
    pub fn cuPointerSetAttribute(
        value: *const ::std::ffi::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns information about a pointer.\n\n The supported attributes are (refer to [cuPointerGetAttribute](crate::ffi::cuPointerGetAttribute) for attribute descriptions and restrictions):\n\n - [CU_POINTER_ATTRIBUTE_CONTEXT](crate::ffi::CU_POINTER_ATTRIBUTE_CONTEXT)\n - [CU_POINTER_ATTRIBUTE_MEMORY_TYPE](crate::ffi::CU_POINTER_ATTRIBUTE_MEMORY_TYPE)\n - [CU_POINTER_ATTRIBUTE_DEVICE_POINTER](crate::ffi::CU_POINTER_ATTRIBUTE_DEVICE_POINTER)\n - [CU_POINTER_ATTRIBUTE_HOST_POINTER](crate::ffi::CU_POINTER_ATTRIBUTE_HOST_POINTER)\n - [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](crate::ffi::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS)\n - [CU_POINTER_ATTRIBUTE_BUFFER_ID](crate::ffi::CU_POINTER_ATTRIBUTE_BUFFER_ID)\n - [CU_POINTER_ATTRIBUTE_IS_MANAGED](crate::ffi::CU_POINTER_ATTRIBUTE_IS_MANAGED)\n - [CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL](crate::ffi::CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL)\n - [CU_POINTER_ATTRIBUTE_RANGE_START_ADDR](crate::ffi::CU_POINTER_ATTRIBUTE_RANGE_START_ADDR)\n - [CU_POINTER_ATTRIBUTE_RANGE_SIZE](crate::ffi::CU_POINTER_ATTRIBUTE_RANGE_SIZE)\n - [CU_POINTER_ATTRIBUTE_MAPPED](crate::ffi::CU_POINTER_ATTRIBUTE_MAPPED)\n - [CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE](crate::ffi::CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE)\n - [CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES](crate::ffi::CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES)\n - [CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE](crate::ffi::CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE)\n - [CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE](crate::ffi::CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE)\n#### numAttributes:\n- Number of attributes to query\n#### attributes:\n- An array of attributes to query\n                      (numAttributes and the number of attributes in this array should match)\n#### data:\n- A two-dimensional array containing pointers to memory\n                      locations where the result of each attribute query will be written to.\n#### ptr:\n- Pointer to query\n\n Unlike [cuPointerGetAttribute](crate::ffi::cuPointerGetAttribute), this function will not return an error when the `ptr`\n encountered is not a valid CUDA pointer. Instead, the attributes are assigned default NULL values\n and CUDA_SUCCESS is returned.\n\n If `ptr` was not allocated by, mapped by, or registered with a [CUcontext](crate::ffi::CUcontext) which uses UVA\n (Unified Virtual Addressing), [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) is returned.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuPointerGetAttribute](crate::ffi::cuPointerGetAttribute),\n [cuPointerSetAttribute](crate::ffi::cuPointerSetAttribute),\n [cudaPointerGetAttributes](crate::ffi::cudaPointerGetAttributes)\n"]
    pub fn cuPointerGetAttributes(
        numAttributes: ::std::ffi::c_uint,
        attributes: *mut CUpointer_attribute,
        data: *mut *mut ::std::ffi::c_void,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a stream\n\n Creates a stream and returns a handle in `phStream`.  The `Flags` argument\n determines behaviors of the stream.\n\n Valid values for `Flags` are:\n - [CU_STREAM_DEFAULT](crate::ffi::CU_STREAM_DEFAULT): Default stream creation flag.\n - [CU_STREAM_NON_BLOCKING](crate::ffi::CU_STREAM_NON_BLOCKING): Specifies that work running in the created\n   stream may run concurrently with work in stream 0 (the NULL stream), and that\n   the created stream should perform no implicit synchronization with stream 0.\n#### phStream:\n- Returned newly created stream\n#### Flags:\n- Parameters for stream creation\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority),\n [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags),\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamCreate](crate::ffi::cudaStreamCreate),\n [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags)\n"]
    pub fn cuStreamCreate(phStream: *mut CUstream, Flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a stream with the given priority\n\n Creates a stream with the specified priority and returns a handle in `phStream`.\n This affects the scheduling priority of work in the stream. Priorities provide a\n hint to preferentially run work with higher priority when possible, but do\n not preempt already-running work or provide any other functional guarantee on\n execution order.\n\n `priority` follows a convention where lower numbers represent higher priorities.\n '0' represents default priority. The range of meaningful numerical priorities can\n be queried using [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange). If the specified priority is\n outside the numerical range returned by [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n it will automatically be clamped to the lowest or the highest number in the range.\n#### phStream:\n- Returned newly created stream\n#### flags:\n- Flags for stream creation. See [cuStreamCreate](crate::ffi::cuStreamCreate) for a list of\n                      valid flags\n#### priority:\n- Stream priority. Lower numbers represent higher priorities.\n                      See [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange) for more information about\n                      meaningful stream priorities that can be passed.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### Note:\nStream priorities are supported only on GPUs\n with compute capability 3.5 or higher.\n\n ### Note:\nIn the current implementation, only compute kernels launched in\n priority streams are affected by the stream's priority. Stream priorities have\n no effect on host-to-device and device-to-host memory operations.\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags),\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamCreateWithPriority](crate::ffi::cudaStreamCreateWithPriority)\n"]
    pub fn cuStreamCreateWithPriority(
        phStream: *mut CUstream,
        flags: ::std::ffi::c_uint,
        priority: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query the priority of a given stream\n\n Query the priority of a stream created using [cuStreamCreate](crate::ffi::cuStreamCreate), [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority) or [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate)\n and return the priority in `priority`. Note that if the stream was created with a\n priority outside the numerical range returned by [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n this function returns the clamped priority.\n See [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority) for details about priority clamping.\n#### hStream:\n- Handle to the stream to be queried\n#### priority:\n- Pointer to a signed integer in which the stream's priority is returned\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority),\n [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate),\n [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags),\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n [cudaStreamGetPriority](crate::ffi::cudaStreamGetPriority)\n"]
    pub fn cuStreamGetPriority(hStream: CUstream, priority: *mut ::std::ffi::c_int) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the device handle of the stream\n\n Returns in `*device` the device handle of the stream\n#### hStream:\n- Handle to the stream to be queried\n#### device:\n- Returns the device to which a stream belongs\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags)\n"]
    pub fn cuStreamGetDevice(hStream: CUstream, device: *mut CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query the flags of a given stream\n\n Query the flags of a stream created using [cuStreamCreate](crate::ffi::cuStreamCreate), [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority) or [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate)\n and return the flags in `flags`.\n#### hStream:\n- Handle to the stream to be queried\n#### flags:\n- Pointer to an unsigned integer in which the stream's flags are returned\n                     The value returned in `flags` is a logical 'OR' of all flags that\n                     were used while creating this stream. See [cuStreamCreate](crate::ffi::cuStreamCreate) for the list\n                     of valid flags\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cudaStreamGetFlags](crate::ffi::cudaStreamGetFlags)\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n"]
    pub fn cuStreamGetFlags(hStream: CUstream, flags: *mut ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the unique Id associated with the stream handle supplied\n\n Returns in `streamId` the unique Id which is associated with the given stream handle.\n The Id is unique for the life of the program.\n\n The stream handle `hStream` can refer to any of the following:\n <ul>\n   <li>a stream created via any of the CUDA driver APIs such as [cuStreamCreate](crate::ffi::cuStreamCreate)\n   and [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority), or their runtime API equivalents such as\n   [cudaStreamCreate](crate::ffi::cudaStreamCreate), [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags) and [cudaStreamCreateWithPriority](crate::ffi::cudaStreamCreateWithPriority).\n   Passing an invalid handle will result in undefined behavior.</li>\n   <li>any of the special streams such as the NULL stream, [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) and\n   [CU_STREAM_PER_THREAD](crate::ffi::CU_STREAM_PER_THREAD). The runtime API equivalents of these are also accepted,\n   which are NULL, [cudaStreamLegacy](crate::ffi::cudaStreamLegacy) and [cudaStreamPerThread](crate::ffi::cudaStreamPerThread) respectively.</li>\n </ul>\n#### hStream:\n- Handle to the stream to be queried\n#### streamId:\n- Pointer to store the Id of the stream\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cudaStreamGetId](crate::ffi::cudaStreamGetId)\n"]
    pub fn cuStreamGetId(hStream: CUstream, streamId: *mut ::std::ffi::c_ulonglong) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query the context associated with a stream\n\n Returns the CUDA context that the stream is associated with.\n\n Note there is a later version of this API, [cuStreamGetCtx_v2](crate::ffi::cuStreamGetCtx_v2). It will\n supplant this version in CUDA 13.0. It is recommended to use [cuStreamGetCtx_v2](crate::ffi::cuStreamGetCtx_v2)\n till then as this version will return [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED) for streams created via the API [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate).\n\n The stream handle `hStream` can refer to any of the following:\n <ul>\n   <li>a stream created via any of the CUDA driver APIs such as [cuStreamCreate](crate::ffi::cuStreamCreate)\n   and [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority), or their runtime API equivalents such as\n   [cudaStreamCreate](crate::ffi::cudaStreamCreate), [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags) and [cudaStreamCreateWithPriority](crate::ffi::cudaStreamCreateWithPriority).\n   The returned context is the context that was active in the calling thread when the\n   stream was created. Passing an invalid handle will result in undefined behavior.</li>\n   <li>any of the special streams such as the NULL stream, [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) and\n   [CU_STREAM_PER_THREAD](crate::ffi::CU_STREAM_PER_THREAD). The runtime API equivalents of these are also accepted,\n   which are NULL, [cudaStreamLegacy](crate::ffi::cudaStreamLegacy) and [cudaStreamPerThread](crate::ffi::cudaStreamPerThread) respectively.\n   Specifying any of the special handles will return the context current to the\n   calling thread. If no context is current to the calling thread,\n   [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) is returned.</li>\n </ul>\n#### hStream:\n- Handle to the stream to be queried\n#### pctx:\n- Returned context associated with the stream\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags),\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamCreate](crate::ffi::cudaStreamCreate),\n [cuStreamGetCtx_v2](crate::ffi::cuStreamGetCtx_v2),\n [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags)\n"]
    pub fn cuStreamGetCtx(hStream: CUstream, pctx: *mut CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query the contexts associated with a stream\n\n Returns the contexts that the stream is associated with.\n\n If the stream is associated with a green context, the API returns the green context in `pGreenCtx`\n and the primary context of the associated device in `pCtx`.\n\n If the stream is associated with a regular context, the API returns the regular context in `pCtx`\n and NULL in `pGreenCtx`.\n\n The stream handle `hStream` can refer to any of the following:\n <ul>\n   <li>a stream created via any of the CUDA driver APIs such as [cuStreamCreate](crate::ffi::cuStreamCreate),\n   [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority) and [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate), or their runtime API equivalents such as\n   [cudaStreamCreate](crate::ffi::cudaStreamCreate), [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags) and [cudaStreamCreateWithPriority](crate::ffi::cudaStreamCreateWithPriority).\n   Passing an invalid handle will result in undefined behavior.</li>\n   <li>any of the special streams such as the NULL stream, [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) and\n   [CU_STREAM_PER_THREAD](crate::ffi::CU_STREAM_PER_THREAD). The runtime API equivalents of these are also accepted,\n   which are NULL, [cudaStreamLegacy](crate::ffi::cudaStreamLegacy) and [cudaStreamPerThread](crate::ffi::cudaStreamPerThread) respectively.\n   If any of the special handles are specified, the API will operate on the context current to the\n   calling thread. If a green context (that was converted via [cuCtxFromGreenCtx](crate::ffi::cuCtxFromGreenCtx)() before setting it current)\n   is current to the calling thread, the API will return the green context in `pGreenCtx`\n   and the primary context of the associated device in `pCtx`. If a regular context is current,\n   the API returns the regular context in `pCtx` and NULL in `pGreenCtx`.\n   Note that specifying [CU_STREAM_PER_THREAD](crate::ffi::CU_STREAM_PER_THREAD) or [cudaStreamPerThread](crate::ffi::cudaStreamPerThread) will return [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n   if a green context is current to the calling thread.\n   If no context is current to the calling thread, [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) is returned.</li>\n </ul>\n#### hStream:\n- Handle to the stream to be queried\n#### pCtx:\n- Returned regular context associated with the stream\n#### pGreenCtx:\n- Returned green context if the stream is associated with a green context or NULL if not\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreate](crate::ffi::cuStreamCreate)\n [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority),\n [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags),\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamCreate](crate::ffi::cudaStreamCreate),\n [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags),\n"]
    pub fn cuStreamGetCtx_v2(
        hStream: CUstream,
        pCtx: *mut CUcontext,
        pGreenCtx: *mut CUgreenCtx,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Make a compute stream wait on an event\n\n Makes all future work submitted to `hStream` wait for all work captured in\n `hEvent`.  See [cuEventRecord](crate::ffi::cuEventRecord)() for details on what is captured by an event.\n The synchronization will be performed efficiently on the device when applicable.\n `hEvent` may be from a different context or device than `hStream`.\n\n flags include:\n - [CU_EVENT_WAIT_DEFAULT](crate::ffi::CU_EVENT_WAIT_DEFAULT): Default event creation flag.\n - [CU_EVENT_WAIT_EXTERNAL](crate::ffi::CU_EVENT_WAIT_EXTERNAL): Event is captured in the graph as an external\n   event node when performing stream capture. This flag is invalid outside\n   of stream capture.\n#### hStream:\n- Stream to wait\n#### hEvent:\n- Event to wait on (may not be NULL)\n#### Flags:\n- See [CUevent_capture_flags](crate::ffi::CUevent_capture_flags)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cudaStreamWaitEvent](crate::ffi::cudaStreamWaitEvent)\n"]
    pub fn cuStreamWaitEvent(
        hStream: CUstream,
        hEvent: CUevent,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Add a callback to a compute stream\n\n### Note:\n ### Note:\nThis function is slated for eventual deprecation and removal. If\n you do not require the callback to execute in case of a device error,\n consider using [cuLaunchHostFunc](crate::ffi::cuLaunchHostFunc). Additionally, this function is not\n supported with [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture) and [cuStreamEndCapture](crate::ffi::cuStreamEndCapture), unlike\n [cuLaunchHostFunc](crate::ffi::cuLaunchHostFunc).\n\n Adds a callback to be called on the host after all currently enqueued\n items in the stream have completed.  For each\n cuStreamAddCallback call, the callback will be executed exactly once.\n The callback will block later work in the stream until it is finished.\n\n The callback may be passed [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) or an error code.  In the event\n of a device error, all subsequently executed callbacks will receive an\n appropriate [CUresult](crate::ffi::CUresult).\n\n Callbacks must not make any CUDA API calls.  Attempting to use a CUDA API\n will result in [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED).  Callbacks must not perform any\n synchronization that may depend on outstanding device work or other callbacks\n that are not mandated to run earlier.  Callbacks without a mandated order\n (in independent streams) execute in undefined order and may be serialized.\n\n For the purposes of Unified Memory, callback execution makes a number of\n guarantees:\n <ul>\n   <li>The callback stream is considered idle for the duration of the\n   callback.  Thus, for example, a callback may always use memory attached\n   to the callback stream.</li>\n   <li>The start of execution of a callback has the same effect as\n   synchronizing an event recorded in the same stream immediately prior to\n   the callback.  It thus synchronizes streams which have been \"joined\"\n   prior to the callback.</li>\n   <li>Adding device work to any stream does not have the effect of making\n   the stream active until all preceding host functions and stream callbacks\n   have executed.  Thus, for\n   example, a callback might use global attached memory even if work has\n   been added to another stream, if the work has been ordered behind the\n   callback with an event.</li>\n   <li>Completion of a callback does not cause a stream to become\n   active except as described above.  The callback stream will remain idle\n   if no device work follows the callback, and will remain idle across\n   consecutive callbacks without device work in between.  Thus, for example,\n   stream synchronization can be done by signaling from a callback at the\n   end of the stream.</li>\n </ul>\n#### hStream:\n- Stream to add callback to\n#### callback:\n- The function to call once preceding stream operations are complete\n#### userData:\n- User specified data to be passed to the callback function\n#### flags:\n- Reserved for future use, must be 0\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuMemAllocManaged](crate::ffi::cuMemAllocManaged),\n [cuStreamAttachMemAsync](crate::ffi::cuStreamAttachMemAsync),\n [cuLaunchHostFunc](crate::ffi::cuLaunchHostFunc),\n [cudaStreamAddCallback](crate::ffi::cudaStreamAddCallback)\n"]
    pub fn cuStreamAddCallback(
        hStream: CUstream,
        callback: CUstreamCallback,
        userData: *mut ::std::ffi::c_void,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Begins graph capture on a stream\n\n Begin graph capture on `hStream`. When a stream is in capture mode, all operations\n pushed into the stream will not be executed, but will instead be captured into\n a graph, which will be returned via [cuStreamEndCapture](crate::ffi::cuStreamEndCapture). Capture may not be initiated\n if `stream` is CU_STREAM_LEGACY. Capture must be ended on the same stream in which\n it was initiated, and it may only be initiated if the stream is not already in capture\n mode. The capture mode may be queried via [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing). A unique id\n representing the capture sequence may be queried via [cuStreamGetCaptureInfo](crate::ffi::cuStreamGetCaptureInfo).\n\n If `mode` is not [CU_STREAM_CAPTURE_MODE_RELAXED](crate::ffi::CU_STREAM_CAPTURE_MODE_RELAXED), [cuStreamEndCapture](crate::ffi::cuStreamEndCapture) must be\n called on this stream from the same thread.\n#### hStream:\n- Stream in which to initiate capture\n#### mode:\n- Controls the interaction of this capture sequence with other API\n                  calls that are potentially unsafe. For more details see\n                  [cuThreadExchangeStreamCaptureMode](crate::ffi::cuThreadExchangeStreamCaptureMode).\n\n### Note:\n ### Note:\nKernels captured using this API must not use texture and surface references.\n       Reading or writing through any texture or surface reference is undefined\n       behavior. This restriction does not apply to texture and surface objects.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing),\n [cuStreamEndCapture](crate::ffi::cuStreamEndCapture),\n [cuThreadExchangeStreamCaptureMode](crate::ffi::cuThreadExchangeStreamCaptureMode)\n"]
    pub fn cuStreamBeginCapture_v2(hStream: CUstream, mode: CUstreamCaptureMode) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Begins graph capture on a stream to an existing graph\n\n Begin graph capture on `hStream`, placing new nodes into an existing graph. When a stream is\n in capture mode, all operations pushed into the stream will not be executed, but will instead\n be captured into `hGraph`. The graph will not be instantiable until the user calls\n [cuStreamEndCapture](crate::ffi::cuStreamEndCapture).\n\n Capture may not be initiated if `stream` is CU_STREAM_LEGACY. Capture must be ended on the\n same stream in which it was initiated, and it may only be initiated if the stream is not\n already in capture mode. The capture mode may be queried via [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing). A unique id\n representing the capture sequence may be queried via [cuStreamGetCaptureInfo](crate::ffi::cuStreamGetCaptureInfo).\n\n If `mode` is not [CU_STREAM_CAPTURE_MODE_RELAXED](crate::ffi::CU_STREAM_CAPTURE_MODE_RELAXED), [cuStreamEndCapture](crate::ffi::cuStreamEndCapture) must be\n called on this stream from the same thread.\n#### hStream:\n- Stream in which to initiate capture.\n#### hGraph:\n- Graph to capture into.\n#### dependencies:\n- Dependencies of the first node captured in the stream.  Can be NULL if numDependencies is 0.\n#### dependencyData:\n- Optional array of data associated with each dependency.\n#### numDependencies:\n- Number of dependencies.\n#### mode:\n- Controls the interaction of this capture sequence with other API\n                          calls that are potentially unsafe. For more details see\n                          [cuThreadExchangeStreamCaptureMode](crate::ffi::cuThreadExchangeStreamCaptureMode).\n\n### Note:\n ### Note:\nKernels captured using this API must not use texture and surface references.\n       Reading or writing through any texture or surface reference is undefined\n       behavior. This restriction does not apply to texture and surface objects.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture),\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing),\n [cuStreamEndCapture](crate::ffi::cuStreamEndCapture),\n [cuThreadExchangeStreamCaptureMode](crate::ffi::cuThreadExchangeStreamCaptureMode),\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n"]
    pub fn cuStreamBeginCaptureToGraph(
        hStream: CUstream,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        dependencyData: *const CUgraphEdgeData,
        numDependencies: usize,
        mode: CUstreamCaptureMode,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Swaps the stream capture interaction mode for a thread\n\n Sets the calling thread's stream capture interaction mode to the value contained\n in `*mode`, and overwrites `*mode` with the previous mode for the thread. To\n facilitate deterministic behavior across function or module boundaries, callers\n are encouraged to use this API in a push-pop fashion: \\code\nCUstreamCaptureMode mode = desiredMode;\ncuThreadExchangeStreamCaptureMode(&mode);\n...\ncuThreadExchangeStreamCaptureMode(&mode); // restore previous mode\n \\endcode\n\n During stream capture (see [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture)), some actions, such as a call\n to [cudaMalloc](crate::ffi::cudaMalloc), may be unsafe. In the case of [cudaMalloc](crate::ffi::cudaMalloc), the operation is\n not enqueued asynchronously to a stream, and is not observed by stream capture.\n Therefore, if the sequence of operations captured via [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture)\n depended on the allocation being replayed whenever the graph is launched, the\n captured graph would be invalid.\n\n Therefore, stream capture places restrictions on API calls that can be made within\n or concurrently to a [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture)-[cuStreamEndCapture](crate::ffi::cuStreamEndCapture) sequence. This\n behavior can be controlled via this API and flags to [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture).\n\n A thread's mode is one of the following:\n - `CU_STREAM_CAPTURE_MODE_GLOBAL`: This is the default mode. If the local thread has\n   an ongoing capture sequence that was not initiated with\n   `CU_STREAM_CAPTURE_MODE_RELAXED` at `cuStreamBeginCapture`, or if any other thread\n   has a concurrent capture sequence initiated with `CU_STREAM_CAPTURE_MODE_GLOBAL`,\n   this thread is prohibited from potentially unsafe API calls.\n - `CU_STREAM_CAPTURE_MODE_THREAD_LOCAL`: If the local thread has an ongoing capture\n   sequence not initiated with `CU_STREAM_CAPTURE_MODE_RELAXED`, it is prohibited\n   from potentially unsafe API calls. Concurrent capture sequences in other threads\n   are ignored.\n - `CU_STREAM_CAPTURE_MODE_RELAXED`: The local thread is not prohibited from potentially\n   unsafe API calls. Note that the thread is still prohibited from API calls which\n   necessarily conflict with stream capture, for example, attempting [cuEventQuery](crate::ffi::cuEventQuery)\n   on an event that was last recorded inside a capture sequence.\n#### mode:\n- Pointer to mode value to swap with the current mode\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture)\n"]
    pub fn cuThreadExchangeStreamCaptureMode(mode: *mut CUstreamCaptureMode) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Ends capture on a stream, returning the captured graph\n\n End capture on `hStream`, returning the captured graph via `phGraph`.\n Capture must have been initiated on `hStream` via a call to [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture).\n If capture was invalidated, due to a violation of the rules of stream capture, then\n a NULL graph will be returned.\n\n If the `mode` argument to [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture) was not\n [CU_STREAM_CAPTURE_MODE_RELAXED](crate::ffi::CU_STREAM_CAPTURE_MODE_RELAXED), this call must be from the same thread as\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture).\n#### hStream:\n- Stream to query\n#### phGraph:\n- The captured graph\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture),\n [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing),\n [cuGraphDestroy](crate::ffi::cuGraphDestroy)\n"]
    pub fn cuStreamEndCapture(hStream: CUstream, phGraph: *mut CUgraph) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a stream's capture status\n\n Return the capture status of `hStream` via `captureStatus`. After a successful\n call, `*captureStatus` will contain one of the following:\n - [CU_STREAM_CAPTURE_STATUS_NONE](crate::ffi::CU_STREAM_CAPTURE_STATUS_NONE): The stream is not capturing.\n - [CU_STREAM_CAPTURE_STATUS_ACTIVE](crate::ffi::CU_STREAM_CAPTURE_STATUS_ACTIVE): The stream is capturing.\n - [CU_STREAM_CAPTURE_STATUS_INVALIDATED](crate::ffi::CU_STREAM_CAPTURE_STATUS_INVALIDATED): The stream was capturing but an error\n   has invalidated the capture sequence. The capture sequence must be terminated\n   with [cuStreamEndCapture](crate::ffi::cuStreamEndCapture) on the stream where it was initiated in order to\n   continue using `hStream`.\n\n Note that, if this is called on [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) (the \"null stream\") while\n a blocking stream in the same context is capturing, it will return\n [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT) and `*captureStatus` is unspecified\n after the call. The blocking stream capture is not invalidated.\n\n When a blocking stream is capturing, the legacy stream is in an\n unusable state until the blocking stream capture is terminated. The legacy\n stream is not supported for stream capture, but attempted use would have an\n implicit dependency on the capturing stream(s).\n#### hStream:\n- Stream to query\n#### captureStatus:\n- Returns the stream's capture status\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture),\n [cuStreamEndCapture](crate::ffi::cuStreamEndCapture)\n"]
    pub fn cuStreamIsCapturing(
        hStream: CUstream,
        captureStatus: *mut CUstreamCaptureStatus,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query a stream's capture state\n\n Query stream state related to stream capture.\n\n If called on [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) (the \"null stream\") while a stream not created\n with [CU_STREAM_NON_BLOCKING](crate::ffi::CU_STREAM_NON_BLOCKING) is capturing, returns [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT).\n\n Valid data (other than capture status) is returned only if both of the following are true:\n - the call returns CUDA_SUCCESS\n - the returned capture status is [CU_STREAM_CAPTURE_STATUS_ACTIVE](crate::ffi::CU_STREAM_CAPTURE_STATUS_ACTIVE)\n#### hStream:\n- The stream to query\n#### captureStatus_out:\n- Location to return the capture status of the stream; required\n#### id_out:\n- Optional location to return an id for the capture sequence, which is\n           unique over the lifetime of the process\n#### graph_out:\n- Optional location to return the graph being captured into. All\n           operations other than destroy and node removal are permitted on the graph\n           while the capture sequence is in progress. This API does not transfer\n           ownership of the graph, which is transferred or destroyed at\n           [cuStreamEndCapture](crate::ffi::cuStreamEndCapture). Note that the graph handle may be invalidated before\n           end of capture for certain errors. Nodes that are or become\n           unreachable from the original stream at [cuStreamEndCapture](crate::ffi::cuStreamEndCapture) due to direct\n           actions on the graph do not trigger [CUDA_ERROR_STREAM_CAPTURE_UNJOINED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNJOINED).\n#### dependencies_out:\n- Optional location to store a pointer to an array of nodes.\n           The next node to be captured in the stream will depend on this set of nodes,\n           absent operations such as event wait which modify this set. The array pointer\n           is valid until the next API call which operates on the stream or until the\n           capture is terminated. The node handles may be copied out and are valid until\n           they or the graph is destroyed. The driver-owned array may also be passed\n           directly to APIs that operate on the graph (not the stream) without copying.\n#### numDependencies_out:\n- Optional location to store the size of the array\n           returned in dependencies_out.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamGetCaptureInfo_v3](crate::ffi::cuStreamGetCaptureInfo_v3)\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture),\n [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing),\n [cuStreamUpdateCaptureDependencies](crate::ffi::cuStreamUpdateCaptureDependencies)\n"]
    pub fn cuStreamGetCaptureInfo_v2(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        numDependencies_out: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query a stream's capture state (12.3+)\n\n Query stream state related to stream capture.\n\n If called on [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) (the \"null stream\") while a stream not created\n with [CU_STREAM_NON_BLOCKING](crate::ffi::CU_STREAM_NON_BLOCKING) is capturing, returns [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT).\n\n Valid data (other than capture status) is returned only if both of the following are true:\n - the call returns CUDA_SUCCESS\n - the returned capture status is [CU_STREAM_CAPTURE_STATUS_ACTIVE](crate::ffi::CU_STREAM_CAPTURE_STATUS_ACTIVE)\n\n If `edgeData_out` is non-NULL then `dependencies_out` must be as well. If\n `dependencies_out` is non-NULL and `edgeData_out` is NULL, but there is non-zero edge\n data for one or more of the current stream dependencies, the call will return\n [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY).\n#### hStream:\n- The stream to query\n#### captureStatus_out:\n- Location to return the capture status of the stream; required\n#### id_out:\n- Optional location to return an id for the capture sequence, which is\n           unique over the lifetime of the process\n#### graph_out:\n- Optional location to return the graph being captured into. All\n           operations other than destroy and node removal are permitted on the graph\n           while the capture sequence is in progress. This API does not transfer\n           ownership of the graph, which is transferred or destroyed at\n           [cuStreamEndCapture](crate::ffi::cuStreamEndCapture). Note that the graph handle may be invalidated before\n           end of capture for certain errors. Nodes that are or become\n           unreachable from the original stream at [cuStreamEndCapture](crate::ffi::cuStreamEndCapture) due to direct\n           actions on the graph do not trigger [CUDA_ERROR_STREAM_CAPTURE_UNJOINED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNJOINED).\n#### dependencies_out:\n- Optional location to store a pointer to an array of nodes.\n           The next node to be captured in the stream will depend on this set of nodes,\n           absent operations such as event wait which modify this set. The array pointer\n           is valid until the next API call which operates on the stream or until the\n           capture is terminated. The node handles may be copied out and are valid until\n           they or the graph is destroyed. The driver-owned array may also be passed\n           directly to APIs that operate on the graph (not the stream) without copying.\n#### edgeData_out:\n- Optional location to store a pointer to an array of graph edge\n           data. This array parallels \\c dependencies_out; the next node to be added\n           has an edge to \\c dependencies_out[i] with annotation \\c edgeData_out[i] for\n           each \\c i. The array pointer is valid until the next API call which operates\n           on the stream or until the capture is terminated.\n#### numDependencies_out:\n- Optional location to store the size of the array\n           returned in dependencies_out.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT),\n [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamGetCaptureInfo](crate::ffi::cuStreamGetCaptureInfo)\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture),\n [cuStreamIsCapturing](crate::ffi::cuStreamIsCapturing),\n [cuStreamUpdateCaptureDependencies](crate::ffi::cuStreamUpdateCaptureDependencies)\n"]
    pub fn cuStreamGetCaptureInfo_v3(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        edgeData_out: *mut *const CUgraphEdgeData,
        numDependencies_out: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Update the set of dependencies in a capturing stream (11.3+)\n\n Modifies the dependency set of a capturing stream. The dependency set is the set\n of nodes that the next captured node in the stream will depend on.\n\n Valid flags are [CU_STREAM_ADD_CAPTURE_DEPENDENCIES](crate::ffi::CU_STREAM_ADD_CAPTURE_DEPENDENCIES) and\n [CU_STREAM_SET_CAPTURE_DEPENDENCIES](crate::ffi::CU_STREAM_SET_CAPTURE_DEPENDENCIES). These control whether the set passed to\n the API is added to the existing set or replaces it. A flags value of 0 defaults\n to [CU_STREAM_ADD_CAPTURE_DEPENDENCIES](crate::ffi::CU_STREAM_ADD_CAPTURE_DEPENDENCIES).\n\n Nodes that are removed from the dependency set via this API do not result in\n [CUDA_ERROR_STREAM_CAPTURE_UNJOINED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNJOINED) if they are unreachable from the stream at\n [cuStreamEndCapture](crate::ffi::cuStreamEndCapture).\n\n Returns [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE) if the stream is not capturing.\n\n This API is new in CUDA 11.3. Developers requiring compatibility across minor\n versions to CUDA 11.0 should not use this API or provide a fallback.\n#### hStream:\n- The stream to update\n#### dependencies:\n- The set of dependencies to add\n#### numDependencies:\n- The size of the dependencies array\n#### flags:\n- See above\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE)\n\n ### See also:\n\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture),\n [cuStreamGetCaptureInfo](crate::ffi::cuStreamGetCaptureInfo),\n"]
    pub fn cuStreamUpdateCaptureDependencies(
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        numDependencies: usize,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Update the set of dependencies in a capturing stream (12.3+)\n\n Modifies the dependency set of a capturing stream. The dependency set is the set\n of nodes that the next captured node in the stream will depend on along with the\n edge data for those dependencies.\n\n Valid flags are [CU_STREAM_ADD_CAPTURE_DEPENDENCIES](crate::ffi::CU_STREAM_ADD_CAPTURE_DEPENDENCIES) and\n [CU_STREAM_SET_CAPTURE_DEPENDENCIES](crate::ffi::CU_STREAM_SET_CAPTURE_DEPENDENCIES). These control whether the set passed to\n the API is added to the existing set or replaces it. A flags value of 0 defaults\n to [CU_STREAM_ADD_CAPTURE_DEPENDENCIES](crate::ffi::CU_STREAM_ADD_CAPTURE_DEPENDENCIES).\n\n Nodes that are removed from the dependency set via this API do not result in\n [CUDA_ERROR_STREAM_CAPTURE_UNJOINED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNJOINED) if they are unreachable from the stream at\n [cuStreamEndCapture](crate::ffi::cuStreamEndCapture).\n\n Returns [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE) if the stream is not capturing.\n#### hStream:\n- The stream to update\n#### dependencies:\n- The set of dependencies to add\n#### dependencyData:\n- Optional array of data associated with each dependency.\n#### numDependencies:\n- The size of the dependencies array\n#### flags:\n- See above\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE)\n\n ### See also:\n\n [cuStreamBeginCapture](crate::ffi::cuStreamBeginCapture),\n [cuStreamGetCaptureInfo](crate::ffi::cuStreamGetCaptureInfo),\n"]
    pub fn cuStreamUpdateCaptureDependencies_v2(
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        dependencyData: *const CUgraphEdgeData,
        numDependencies: usize,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Attach memory to a stream asynchronously\n\n Enqueues an operation in `hStream` to specify stream association of\n `length` bytes of memory starting from `dptr`. This function is a\n stream-ordered operation, meaning that it is dependent on, and will\n only take effect when, previous work in stream has completed. Any\n previous association is automatically replaced.\n\n `dptr` must point to one of the following types of memories:\n - managed memory declared using the __managed__ keyword or allocated with\n   [cuMemAllocManaged](crate::ffi::cuMemAllocManaged).\n - a valid host-accessible region of system-allocated pageable memory. This\n   type of memory may only be specified if the device associated with the\n   stream reports a non-zero value for the device attribute\n   [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS).\n\n For managed allocations, `length` must be either zero or the entire\n allocation's size. Both indicate that the entire allocation's stream\n association is being changed. Currently, it is not possible to change stream\n association for a portion of a managed allocation.\n\n For pageable host allocations, `length` must be non-zero.\n\n The stream association is specified using `flags` which must be\n one of [CUmemAttach_flags](crate::ffi::CUmemAttach_flags).\n If the [CU_MEM_ATTACH_GLOBAL](crate::ffi::CU_MEM_ATTACH_GLOBAL) flag is specified, the memory can be accessed\n by any stream on any device.\n If the [CU_MEM_ATTACH_HOST](crate::ffi::CU_MEM_ATTACH_HOST) flag is specified, the program makes a guarantee\n that it won't access the memory on the device from any stream on a device that\n has a zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS).\n If the [CU_MEM_ATTACH_SINGLE](crate::ffi::CU_MEM_ATTACH_SINGLE) flag is specified and `hStream` is associated with\n a device that has a zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS),\n the program makes a guarantee that it will only access the memory on the device\n from `hStream`. It is illegal to attach singly to the NULL stream, because the\n NULL stream is a virtual global stream and not a specific stream. An error will\n be returned in this case.\n\n When memory is associated with a single stream, the Unified Memory system will\n allow CPU access to this memory region so long as all operations in `hStream`\n have completed, regardless of whether other streams are active. In effect,\n this constrains exclusive ownership of the managed memory region by\n an active GPU to per-stream activity instead of whole-GPU activity.\n\n Accessing memory on the device from streams that are not associated with\n it will produce undefined results. No error checking is performed by the\n Unified Memory system to ensure that kernels launched into other streams\n do not access this region.\n\n It is a program's responsibility to order calls to [cuStreamAttachMemAsync](crate::ffi::cuStreamAttachMemAsync)\n via events, synchronization or other means to ensure legal access to memory\n at all times. Data visibility and coherency will be changed appropriately\n for all kernels which follow a stream-association change.\n\n If `hStream` is destroyed while data is associated with it, the association is\n removed and the association reverts to the default visibility of the allocation\n as specified at [cuMemAllocManaged](crate::ffi::cuMemAllocManaged). For __managed__ variables, the default\n association is always [CU_MEM_ATTACH_GLOBAL](crate::ffi::CU_MEM_ATTACH_GLOBAL). Note that destroying a stream is an\n asynchronous operation, and as a result, the change to default association won't\n happen until all work in the stream has completed.\n#### hStream:\n- Stream in which to enqueue the attach operation\n#### dptr:\n- Pointer to memory (must be a pointer to managed memory or\n                  to a valid host-accessible region of system-allocated\n                  pageable memory)\n#### length:\n- Length of memory\n#### flags:\n- Must be one of [CUmemAttach_flags](crate::ffi::CUmemAttach_flags)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuMemAllocManaged](crate::ffi::cuMemAllocManaged),\n [cudaStreamAttachMemAsync](crate::ffi::cudaStreamAttachMemAsync)\n"]
    pub fn cuStreamAttachMemAsync(
        hStream: CUstream,
        dptr: CUdeviceptr,
        length: usize,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Determine status of a compute stream\n\n Returns [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) if all operations in the stream specified by\n `hStream` have completed, or [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY) if not.\n\n For the purposes of Unified Memory, a return value of [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n is equivalent to having called [cuStreamSynchronize](crate::ffi::cuStreamSynchronize)().\n#### hStream:\n- Stream to query status of\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamQuery](crate::ffi::cudaStreamQuery)\n"]
    pub fn cuStreamQuery(hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Wait until a stream's tasks are completed\n\n Waits until the device has completed all operations in the stream specified\n by `hStream`. If the context was created with the\n [CU_CTX_SCHED_BLOCKING_SYNC](crate::ffi::CU_CTX_SCHED_BLOCKING_SYNC) flag, the CPU thread will block until the\n stream is finished with all of its tasks.\n#### hStream:\n- Stream to wait for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamSynchronize](crate::ffi::cudaStreamSynchronize)\n"]
    pub fn cuStreamSynchronize(hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a stream\n\n Destroys the stream specified by `hStream`.\n\n In case the device is still doing work in the stream `hStream`\n when [cuStreamDestroy](crate::ffi::cuStreamDestroy)() is called, the function will return immediately\n and the resources associated with `hStream` will be released automatically\n once the device has completed all work in `hStream`.\n#### hStream:\n- Stream to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamDestroy](crate::ffi::cudaStreamDestroy)\n"]
    pub fn cuStreamDestroy_v2(hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies attributes from source stream to destination stream.\n\n Copies attributes from source stream `src` to destination stream `dst`.\n Both streams must have the same context.\n\n `aram`[out] dst Destination stream\n `aram`[in] src Source stream\n For list of attributes see [CUstreamAttrID](crate::ffi::CUstreamAttrID)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow)\n"]
    pub fn cuStreamCopyAttributes(dst: CUstream, src: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Queries stream attribute.\n\n Queries attribute `attr` from `hStream` and stores it in corresponding\n member of `value_out`.\n\n `aram`[in] hStream\n `aram`[in] attr\n `aram`[out] value_out\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow)\n"]
    pub fn cuStreamGetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value_out: *mut CUstreamAttrValue,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets stream attribute.\n\n Sets attribute `attr` on `hStream` from corresponding attribute of\n `value`. The updated attribute will be applied to subsequent work\n submitted to the stream. It will not affect previously submitted work.\n\n `aram`[out] hStream\n `aram`[in] attr\n `aram`[in] value\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow)\n"]
    pub fn cuStreamSetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value: *const CUstreamAttrValue,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an event\n\n Creates an event *phEvent for the current context with the flags specified via\n `Flags`. Valid flags include:\n - [CU_EVENT_DEFAULT](crate::ffi::CU_EVENT_DEFAULT): Default event creation flag.\n - [CU_EVENT_BLOCKING_SYNC](crate::ffi::CU_EVENT_BLOCKING_SYNC): Specifies that the created event should use blocking\n   synchronization.  A CPU thread that uses [cuEventSynchronize](crate::ffi::cuEventSynchronize)() to wait on\n   an event created with this flag will block until the event has actually\n   been recorded.\n - [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING): Specifies that the created event does not need\n   to record timing data.  Events created with this flag specified and\n   the [CU_EVENT_BLOCKING_SYNC](crate::ffi::CU_EVENT_BLOCKING_SYNC) flag not specified will provide the best\n   performance when used with [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)() and [cuEventQuery](crate::ffi::cuEventQuery)().\n - [CU_EVENT_INTERPROCESS](crate::ffi::CU_EVENT_INTERPROCESS): Specifies that the created event may be used as an\n   interprocess event by [cuIpcGetEventHandle](crate::ffi::cuIpcGetEventHandle)(). [CU_EVENT_INTERPROCESS](crate::ffi::CU_EVENT_INTERPROCESS) must\n   be specified along with [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING).\n#### phEvent:\n- Returns newly created event\n#### Flags:\n- Event creation flags\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cuEventElapsedTime](crate::ffi::cuEventElapsedTime),\n [cudaEventCreate](crate::ffi::cudaEventCreate),\n [cudaEventCreateWithFlags](crate::ffi::cudaEventCreateWithFlags)\n"]
    pub fn cuEventCreate(phEvent: *mut CUevent, Flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Records an event\n\n Captures in `hEvent` the contents of `hStream` at the time of this call.\n `hEvent` and `hStream` must be from the same context otherwise\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is returned.\n Calls such as [cuEventQuery](crate::ffi::cuEventQuery)() or [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)() will then\n examine or wait for completion of the work that was captured. Uses of\n `hStream` after this call do not modify `hEvent`. See note on default\n stream behavior for what is captured in the default case.\n\n [cuEventRecord](crate::ffi::cuEventRecord)() can be called multiple times on the same event and\n will overwrite the previously captured state. Other APIs such as\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)() use the most recently captured state at the time\n of the API call, and are not affected by later calls to\n [cuEventRecord](crate::ffi::cuEventRecord)(). Before the first call to [cuEventRecord](crate::ffi::cuEventRecord)(), an\n event represents an empty set of work, so for example [cuEventQuery](crate::ffi::cuEventQuery)()\n would return [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS).\n#### hEvent:\n- Event to record\n#### hStream:\n- Stream to record event for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cuEventElapsedTime](crate::ffi::cuEventElapsedTime),\n [cudaEventRecord](crate::ffi::cudaEventRecord),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags)\n"]
    pub fn cuEventRecord(hEvent: CUevent, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Records an event\n\n Captures in `hEvent` the contents of `hStream` at the time of this call.\n `hEvent` and `hStream` must be from the same context otherwise\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is returned.\n Calls such as [cuEventQuery](crate::ffi::cuEventQuery)() or [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)() will then\n examine or wait for completion of the work that was captured. Uses of\n `hStream` after this call do not modify `hEvent`. See note on default\n stream behavior for what is captured in the default case.\n\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags)() can be called multiple times on the same event and\n will overwrite the previously captured state. Other APIs such as\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)() use the most recently captured state at the time\n of the API call, and are not affected by later calls to\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags)(). Before the first call to [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags)(), an\n event represents an empty set of work, so for example [cuEventQuery](crate::ffi::cuEventQuery)()\n would return [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS).\n\n flags include:\n - [CU_EVENT_RECORD_DEFAULT](crate::ffi::CU_EVENT_RECORD_DEFAULT): Default event creation flag.\n - [CU_EVENT_RECORD_EXTERNAL](crate::ffi::CU_EVENT_RECORD_EXTERNAL): Event is captured in the graph as an external\n   event node when performing stream capture. This flag is invalid outside\n   of stream capture.\n#### hEvent:\n- Event to record\n#### hStream:\n- Stream to record event for\n#### flags:\n- See [CUevent_capture_flags](crate::ffi::CUevent_capture_flags)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cuEventElapsedTime](crate::ffi::cuEventElapsedTime),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cudaEventRecord](crate::ffi::cudaEventRecord)\n"]
    pub fn cuEventRecordWithFlags(
        hEvent: CUevent,
        hStream: CUstream,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Queries an event's status\n\n Queries the status of all work currently captured by `hEvent`. See\n [cuEventRecord](crate::ffi::cuEventRecord)() for details on what is captured by an event.\n\n Returns [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) if all captured work has been completed, or\n [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY) if any captured work is incomplete.\n\n For the purposes of Unified Memory, a return value of [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n is equivalent to having called [cuEventSynchronize](crate::ffi::cuEventSynchronize)().\n#### hEvent:\n- Event to query\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cuEventElapsedTime](crate::ffi::cuEventElapsedTime),\n [cudaEventQuery](crate::ffi::cudaEventQuery)\n"]
    pub fn cuEventQuery(hEvent: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Waits for an event to complete\n\n Waits until the completion of all work currently captured in `hEvent`.\n See [cuEventRecord](crate::ffi::cuEventRecord)() for details on what is captured by an event.\n\n Waiting for an event that was created with the [CU_EVENT_BLOCKING_SYNC](crate::ffi::CU_EVENT_BLOCKING_SYNC)\n flag will cause the calling CPU thread to block until the event has\n been completed by the device.  If the [CU_EVENT_BLOCKING_SYNC](crate::ffi::CU_EVENT_BLOCKING_SYNC) flag has\n not been set, then the CPU thread will busy-wait until the event has\n been completed by the device.\n#### hEvent:\n- Event to wait for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cuEventElapsedTime](crate::ffi::cuEventElapsedTime),\n [cudaEventSynchronize](crate::ffi::cudaEventSynchronize)\n"]
    pub fn cuEventSynchronize(hEvent: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys an event\n\n Destroys the event specified by `hEvent`.\n\n An event may be destroyed before it is complete (i.e., while\n [cuEventQuery](crate::ffi::cuEventQuery)() would return [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY)). In this case, the\n call does not block on completion of the event, and any associated\n resources will automatically be released asynchronously at completion.\n#### hEvent:\n- Event to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuEventElapsedTime](crate::ffi::cuEventElapsedTime),\n [cudaEventDestroy](crate::ffi::cudaEventDestroy)\n"]
    pub fn cuEventDestroy_v2(hEvent: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Computes the elapsed time between two events\n\n Computes the elapsed time between two events (in milliseconds with a\n resolution of around 0.5 microseconds).\n\n If either event was last recorded in a non-NULL stream, the resulting time\n may be greater than expected (even if both used the same stream handle). This\n happens because the [cuEventRecord](crate::ffi::cuEventRecord)() operation takes place asynchronously\n and there is no guarantee that the measured latency is actually just between\n the two events. Any number of other different stream operations could execute\n in between the two measured events, thus altering the timing in a significant\n way.\n\n If [cuEventRecord](crate::ffi::cuEventRecord)() has not been called on either event then\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is returned. If [cuEventRecord](crate::ffi::cuEventRecord)() has been called\n on both events but one or both of them has not yet been completed (that is,\n [cuEventQuery](crate::ffi::cuEventQuery)() would return [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY) on at least one of the\n events), [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY) is returned. If either event was created with\n the [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING) flag, then this function will return\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE).\n\n Note there is a later version of this API, [cuEventElapsedTime_v2](crate::ffi::cuEventElapsedTime_v2). It will\n supplant this version in CUDA 13.0, which is retained for minor version compatibility.\n#### pMilliseconds:\n- Time between `hStart` and `hEnd` in ms\n#### hStart:\n- Starting event\n#### hEnd:\n- Ending event\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cudaEventElapsedTime](crate::ffi::cudaEventElapsedTime)\n"]
    pub fn cuEventElapsedTime(pMilliseconds: *mut f32, hStart: CUevent, hEnd: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Computes the elapsed time between two events\n\n Computes the elapsed time between two events (in milliseconds with a\n resolution of around 0.5 microseconds). Note this API is not guaranteed\n to return the latest errors for pending work. As such this API is intended to\n serve as an elapsed time calculation only and any polling for completion on the\n events to be compared should be done with [cuEventQuery](crate::ffi::cuEventQuery) instead.\n\n If either event was last recorded in a non-NULL stream, the resulting time\n may be greater than expected (even if both used the same stream handle). This\n happens because the [cuEventRecord](crate::ffi::cuEventRecord)() operation takes place asynchronously\n and there is no guarantee that the measured latency is actually just between\n the two events. Any number of other different stream operations could execute\n in between the two measured events, thus altering the timing in a significant\n way.\n\n If [cuEventRecord](crate::ffi::cuEventRecord)() has not been called on either event then\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is returned. If [cuEventRecord](crate::ffi::cuEventRecord)() has been called\n on both events but one or both of them has not yet been completed (that is,\n [cuEventQuery](crate::ffi::cuEventQuery)() would return [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY) on at least one of the\n events), [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY) is returned. If either event was created with\n the [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING) flag, then this function will return\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE).\n#### pMilliseconds:\n- Time between `hStart` and `hEnd` in ms\n#### hStart:\n- Starting event\n#### hEnd:\n- Ending event\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuEventCreate](crate::ffi::cuEventCreate),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuEventQuery](crate::ffi::cuEventQuery),\n [cuEventSynchronize](crate::ffi::cuEventSynchronize),\n [cuEventDestroy](crate::ffi::cuEventDestroy),\n [cudaEventElapsedTime](crate::ffi::cudaEventElapsedTime)\n"]
    pub fn cuEventElapsedTime_v2(
        pMilliseconds: *mut f32,
        hStart: CUevent,
        hEnd: CUevent,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Imports an external memory object\n\n Imports an externally allocated memory object and returns\n a handle to that in `extMem_out`.\n\n The properties of the handle being imported must be described in\n `memHandleDesc`. The [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC) structure\n is defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {\nCUexternalMemoryHandleType type;\nunion {\nint fd;\nstruct {\nvoid *handle;\nconst void *name;\n} win32;\nconst void *nvSciBufObject;\n} handle;\nunsigned long long size;\nunsigned int flags;\n} CUDA_EXTERNAL_MEMORY_HANDLE_DESC;\n \\endcode\n\n where [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) specifies the type\n of handle being imported. [CUexternalMemoryHandleType](crate::ffi::CUexternalMemoryHandleType) is\n defined as:\n\n \\code\ntypedef enum CUexternalMemoryHandleType_enum {\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD          = 1,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32       = 2,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT   = 3,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP         = 4,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE     = 5,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE     = 6,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF           = 8,\n} CUexternalMemoryHandleType;\n \\endcode\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD), then\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[fd](crate::ffi::fd) must be a valid\n file descriptor referencing a memory object. Ownership of\n the file descriptor is transferred to the CUDA driver when the\n handle is imported successfully. Performing any operations on the\n file descriptor after it is imported results in undefined behavior.\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32), then exactly one\n of [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) and\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name) must not be\n NULL. If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n is not NULL, then it must represent a valid shared NT handle that\n references a memory object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a memory object.\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT), then\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) must\n be non-NULL and\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n must be NULL. The handle specified must be a globally shared KMT\n handle. This handle does not hold a reference to the underlying\n object, and thus will be invalid when all references to the\n memory object are destroyed.\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP), then exactly one\n of [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) and\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name) must not be\n NULL. If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device[CreateSharedHandle](crate::ffi::CreateSharedHandle) when referring to a\n ID3D12Heap object. This handle holds a reference to the underlying\n object. If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D12Heap object.\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE), then exactly one\n of [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) and\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name) must not be\n NULL. If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device[CreateSharedHandle](crate::ffi::CreateSharedHandle) when referring to a\n ID3D12Resource object. This handle holds a reference to the\n underlying object. If\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D12Resource object.\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE), then\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) must\n represent a valid shared NT handle that is returned by\n IDXGIResource1[CreateSharedHandle](crate::ffi::CreateSharedHandle) when referring to a\n ID3D11Resource object. If\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D11Resource object.\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT), then\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) must\n represent a valid shared KMT handle that is returned by\n IDXGIResource[GetSharedHandle](crate::ffi::GetSharedHandle) when referring to a\n ID3D11Resource object and\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n must be NULL.\n\n If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF), then\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[handle](crate::ffi::handle)[nvSciBufObject](crate::ffi::nvSciBufObject) must be non-NULL\n and reference a valid NvSciBuf object.\n If the NvSciBuf object imported into CUDA is also mapped by other drivers, then the\n application must use [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync) or [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync)\n as appropriate barriers to maintain coherence between CUDA and the other drivers.\n See [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC) and [CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC)\n for memory synchronization.\n\n\n The size of the memory object must be specified in\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[size](crate::ffi::size).\n\n Specifying the flag [CUDA_EXTERNAL_MEMORY_DEDICATED](crate::ffi::CUDA_EXTERNAL_MEMORY_DEDICATED) in\n [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[flags](crate::ffi::flags) indicates that the\n resource is a dedicated resource. The definition of what a\n dedicated resource is outside the scope of this extension.\n This flag must be set if [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_HANDLE_DESC)[type](crate::ffi::type)\n is one of the following:\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE)\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE)\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT)\n#### extMem_out:\n- Returned handle to an external memory object\n#### memHandleDesc:\n- Memory import handle descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OPERATING_SYSTEM](crate::ffi::CUDA_ERROR_OPERATING_SYSTEM)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### Note:\nIf the Vulkan memory imported into CUDA is mapped on the CPU then the\n application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges\n as well as appropriate Vulkan pipeline barriers to maintain coherence between\n CPU and GPU. For more information on these APIs, please refer to \"Synchronization\n and Cache Control\" chapter from Vulkan specification.\n\n ### See also:\n [cuDestroyExternalMemory](crate::ffi::cuDestroyExternalMemory),\n [cuExternalMemoryGetMappedBuffer](crate::ffi::cuExternalMemoryGetMappedBuffer),\n [cuExternalMemoryGetMappedMipmappedArray](crate::ffi::cuExternalMemoryGetMappedMipmappedArray)\n"]
    pub fn cuImportExternalMemory(
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Maps a buffer onto an imported memory object\n\n Maps a buffer onto an imported memory object and returns a device\n pointer in `devPtr`.\n\n The properties of the buffer being mapped must be described in\n `bufferDesc`. The [CUDA_EXTERNAL_MEMORY_BUFFER_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_BUFFER_DESC) structure is\n defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {\nunsigned long long offset;\nunsigned long long size;\nunsigned int flags;\n} CUDA_EXTERNAL_MEMORY_BUFFER_DESC;\n \\endcode\n\n where [CUDA_EXTERNAL_MEMORY_BUFFER_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_BUFFER_DESC)[offset](crate::ffi::offset) is the offset in\n the memory object where the buffer's base address is.\n [CUDA_EXTERNAL_MEMORY_BUFFER_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_BUFFER_DESC)[size](crate::ffi::size) is the size of the buffer.\n [CUDA_EXTERNAL_MEMORY_BUFFER_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_BUFFER_DESC)[flags](crate::ffi::flags) must be zero.\n\n The offset and size have to be suitably aligned to match the\n requirements of the external API. Mapping two buffers whose ranges\n overlap may or may not result in the same virtual address being\n returned for the overlapped portion. In such cases, the application\n must ensure that all accesses to that region from the GPU are\n volatile. Otherwise writes made via one address are not guaranteed\n to be visible via the other address, even if they're issued by the\n same thread. It is recommended that applications map the combined\n range instead of mapping separate buffers and then apply the\n appropriate offsets to the returned pointer to derive the\n individual buffers.\n\n The returned pointer `devPtr` must be freed using [cuMemFree](crate::ffi::cuMemFree).\n#### devPtr:\n- Returned device pointer to buffer\n#### extMem:\n- Handle to external memory object\n#### bufferDesc:\n- Buffer descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuImportExternalMemory](crate::ffi::cuImportExternalMemory),\n [cuDestroyExternalMemory](crate::ffi::cuDestroyExternalMemory),\n [cuExternalMemoryGetMappedMipmappedArray](crate::ffi::cuExternalMemoryGetMappedMipmappedArray)\n"]
    pub fn cuExternalMemoryGetMappedBuffer(
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Maps a CUDA mipmapped array onto an external memory object\n\n Maps a CUDA mipmapped array onto an external object and returns a\n handle to it in `mipmap`.\n\n The properties of the CUDA mipmapped array being mapped must be\n described in `mipmapDesc`. The structure\n [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC) is defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {\nunsigned long long offset;\nCUDA_ARRAY3D_DESCRIPTOR arrayDesc;\nunsigned int numLevels;\n} CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC;\n \\endcode\n\n where [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC)[offset](crate::ffi::offset) is the\n offset in the memory object where the base level of the mipmap\n chain is.\n [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC)[arrayDesc](crate::ffi::arrayDesc) describes\n the format, dimensions and type of the base level of the mipmap\n chain. For further details on these parameters, please refer to the\n documentation for [cuMipmappedArrayCreate](crate::ffi::cuMipmappedArrayCreate). Note that if the mipmapped\n array is bound as a color target in the graphics API, then the flag\n [CUDA_ARRAY3D_COLOR_ATTACHMENT](crate::ffi::CUDA_ARRAY3D_COLOR_ATTACHMENT) must be specified in\n [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC)[arrayDesc](crate::ffi::arrayDesc)[Flags](crate::ffi::Flags).\n [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC)[numLevels](crate::ffi::numLevels) specifies\n the total number of levels in the mipmap chain.\n\n If `extMem` was imported from a handle of type [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF), then\n [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](crate::ffi::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC)[numLevels](crate::ffi::numLevels) must be equal to 1.\n\n\n The returned CUDA mipmapped array must be freed using [cuMipmappedArrayDestroy](crate::ffi::cuMipmappedArrayDestroy).\n#### mipmap:\n- Returned CUDA mipmapped array\n#### extMem:\n- Handle to external memory object\n#### mipmapDesc:\n- CUDA array descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuImportExternalMemory](crate::ffi::cuImportExternalMemory),\n [cuDestroyExternalMemory](crate::ffi::cuDestroyExternalMemory),\n [cuExternalMemoryGetMappedBuffer](crate::ffi::cuExternalMemoryGetMappedBuffer)\n"]
    pub fn cuExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys an external memory object.\n\n Destroys the specified external memory object. Any existing buffers\n and CUDA mipmapped arrays mapped onto this object must no longer be\n used and must be explicitly freed using [cuMemFree](crate::ffi::cuMemFree) and\n [cuMipmappedArrayDestroy](crate::ffi::cuMipmappedArrayDestroy) respectively.\n#### extMem:\n- External memory object to be destroyed\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuImportExternalMemory](crate::ffi::cuImportExternalMemory),\n [cuExternalMemoryGetMappedBuffer](crate::ffi::cuExternalMemoryGetMappedBuffer),\n [cuExternalMemoryGetMappedMipmappedArray](crate::ffi::cuExternalMemoryGetMappedMipmappedArray)\n"]
    pub fn cuDestroyExternalMemory(extMem: CUexternalMemory) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Imports an external semaphore\n\n Imports an externally allocated synchronization object and returns\n a handle to that in `extSem_out`.\n\n The properties of the handle being imported must be described in\n `semHandleDesc`. The [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC) is\n defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {\nCUexternalSemaphoreHandleType type;\nunion {\nint fd;\nstruct {\nvoid *handle;\nconst void *name;\n} win32;\nconst void* NvSciSyncObj;\n} handle;\nunsigned int flags;\n} CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC;\n \\endcode\n\n where [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) specifies the type of\n handle being imported. [CUexternalSemaphoreHandleType](crate::ffi::CUexternalSemaphoreHandleType) is defined\n as:\n\n \\code\ntypedef enum CUexternalSemaphoreHandleType_enum {\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD                = 1,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32             = 2,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT         = 3,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE              = 4,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE              = 5,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC                = 6,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX        = 7,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT    = 8,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD    = 9,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10\n} CUexternalSemaphoreHandleType;\n \\endcode\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD), then\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[fd](crate::ffi::fd) must be a valid\n file descriptor referencing a synchronization object. Ownership of\n the file descriptor is transferred to the CUDA driver when the\n handle is imported successfully. Performing any operations on the\n file descriptor after it is imported results in undefined behavior.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32), then exactly one\n of [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) and\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name) must not be\n NULL. If\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n is not NULL, then it must represent a valid shared NT handle that\n references a synchronization object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must name a valid synchronization object.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT), then\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) must\n be non-NULL and\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n must be NULL. The handle specified must be a globally shared KMT\n handle. This handle does not hold a reference to the underlying\n object, and thus will be invalid when all references to the\n synchronization object are destroyed.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE), then exactly one\n of [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) and\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name) must not be\n NULL. If\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device[CreateSharedHandle](crate::ffi::CreateSharedHandle) when referring to a\n ID3D12Fence object. This handle holds a reference to the underlying\n object. If\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must name a valid synchronization object that\n refers to a valid ID3D12Fence object.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE), then\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n represents a valid shared NT handle that is returned by\n ID3D11Fence[CreateSharedHandle](crate::ffi::CreateSharedHandle). If\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must name a valid synchronization object that\n refers to a valid ID3D11Fence object.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC), then\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[nvSciSyncObj](crate::ffi::nvSciSyncObj)\n represents a valid NvSciSyncObj.\n\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX), then\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n represents a valid shared NT handle that\n is returned by IDXGIResource1[CreateSharedHandle](crate::ffi::CreateSharedHandle) when referring to\n a IDXGIKeyedMutex object. If\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must name a valid synchronization object that\n refers to a valid IDXGIKeyedMutex object.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT), then\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n represents a valid shared KMT handle that\n is returned by IDXGIResource[GetSharedHandle](crate::ffi::GetSharedHandle) when referring to\n a IDXGIKeyedMutex object and\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name) must be NULL.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD), then\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[fd](crate::ffi::fd) must be a valid\n file descriptor referencing a synchronization object. Ownership of\n the file descriptor is transferred to the CUDA driver when the\n handle is imported successfully. Performing any operations on the\n file descriptor after it is imported results in undefined behavior.\n\n If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[type](crate::ffi::type) is\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32), then exactly one\n of [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle) and\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name) must not be\n NULL. If\n [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[handle](crate::ffi::handle)\n is not NULL, then it must represent a valid shared NT handle that\n references a synchronization object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)[handle](crate::ffi::handle)[win32](crate::ffi::win32)[name](crate::ffi::name)\n is not NULL, then it must name a valid synchronization object.\n#### extSem_out:\n- Returned handle to an external semaphore\n#### semHandleDesc:\n- Semaphore import handle descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OPERATING_SYSTEM](crate::ffi::CUDA_ERROR_OPERATING_SYSTEM)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuDestroyExternalSemaphore](crate::ffi::cuDestroyExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuImportExternalSemaphore(
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Signals a set of external semaphore objects\n\n Enqueues a signal operation on a set of externally allocated\n semaphore object in the specified stream. The operations will be\n executed when all prior operations in the stream complete.\n\n The exact semantics of signaling a semaphore depends on the type of\n the object.\n\n If the semaphore object is any one of the following types:\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT)\n then signaling the semaphore will set it to the signaled state.\n\n If the semaphore object is any one of the following types:\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32)\n then the semaphore will be set to the value specified in\n [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)[params](crate::ffi::params)[fence](crate::ffi::fence)[value](crate::ffi::value).\n\n If the semaphore object is of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC)\n this API sets [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)[params](crate::ffi::params)[nvSciSync](crate::ffi::nvSciSync)[fence](crate::ffi::fence)\n to a value that can be used by subsequent waiters of the same NvSciSync object\n to order operations with those currently submitted in `stream`. Such an update\n will overwrite previous contents of\n [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)[params](crate::ffi::params)[nvSciSync](crate::ffi::nvSciSync)[fence](crate::ffi::fence). By default,\n signaling such an external semaphore object causes appropriate memory synchronization\n operations to be performed over all external memory objects that are imported as\n [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF). This ensures that any subsequent accesses\n made by other importers of the same set of NvSciBuf memory object(s) are coherent.\n These operations can be skipped by specifying the flag\n [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC), which can be used as a\n performance optimization when data coherency is not required. But specifying this\n flag in scenarios where data coherency is required results in undefined behavior.\n Also, for semaphore object of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC),\n if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in\n [cuDeviceGetNvSciSyncAttributes](crate::ffi::cuDeviceGetNvSciSyncAttributes) to CUDA_NVSCISYNC_ATTR_SIGNAL, this API will return\n CUDA_ERROR_NOT_SUPPORTED.\n NvSciSyncFence associated with semaphore object of the type\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC) can be deterministic. For this the\n NvSciSyncAttrList used to create the semaphore object must have value of\n NvSciSyncAttrKey_RequireDeterministicFences key set to true. Deterministic fences\n allow users to enqueue a wait over the semaphore object even before corresponding\n signal is enqueued. For such a semaphore object, CUDA guarantees that each signal\n operation will increment the fence value by '1'. Users are expected to track count\n of signals enqueued on the semaphore object and insert waits accordingly. When such\n a semaphore object is signaled from multiple streams, due to concurrent stream\n execution, it is possible that the order in which the semaphore gets signaled is\n indeterministic. This could lead to waiters of the semaphore getting unblocked\n incorrectly. Users are expected to handle such situations, either by not using the\n same semaphore object with deterministic fence support enabled in different streams\n or by adding explicit dependency amongst such streams so that the semaphore is\n signaled in order.\n\n If the semaphore object is any one of the following types:\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT)\n then the keyed mutex will be released with the key specified in\n [CUDA_EXTERNAL_SEMAPHORE_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_PARAMS)[params](crate::ffi::params)[keyedmutex](crate::ffi::keyedmutex)[key](crate::ffi::key).\n#### extSemArray:\n- Set of external semaphores to be signaled\n#### paramsArray:\n- Array of semaphore parameters\n#### numExtSems:\n- Number of semaphores to signal\n#### stream:\n- Stream to enqueue the signal operations in\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuDestroyExternalSemaphore](crate::ffi::cuDestroyExternalSemaphore),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuSignalExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::std::ffi::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Waits on a set of external semaphore objects\n\n Enqueues a wait operation on a set of externally allocated\n semaphore object in the specified stream. The operations will be\n executed when all prior operations in the stream complete.\n\n The exact semantics of waiting on a semaphore depends on the type\n of the object.\n\n If the semaphore object is any one of the following types:\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT)\n then waiting on the semaphore will wait until the semaphore reaches\n the signaled state. The semaphore will then be reset to the\n unsignaled state. Therefore for every signal operation, there can\n only be one wait operation.\n\n If the semaphore object is any one of the following types:\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32)\n then waiting on the semaphore will wait until the value of the\n semaphore is greater than or equal to\n [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)[params](crate::ffi::params)[fence](crate::ffi::fence)[value](crate::ffi::value).\n\n If the semaphore object is of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC)\n then, waiting on the semaphore will wait until the\n [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)[params](crate::ffi::params)[nvSciSync](crate::ffi::nvSciSync)[fence](crate::ffi::fence) is signaled by the\n signaler of the NvSciSyncObj that was associated with this semaphore object.\n By default, waiting on such an external semaphore object causes appropriate\n memory synchronization operations to be performed over all external memory objects\n that are imported as [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](crate::ffi::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF). This ensures that\n any subsequent accesses made by other importers of the same set of NvSciBuf memory\n object(s) are coherent. These operations can be skipped by specifying the flag\n [CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC), which can be used as a\n performance optimization when data coherency is not required. But specifying this\n flag in scenarios where data coherency is required results in undefined behavior.\n Also, for semaphore object of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC),\n if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in\n [cuDeviceGetNvSciSyncAttributes](crate::ffi::cuDeviceGetNvSciSyncAttributes) to CUDA_NVSCISYNC_ATTR_WAIT, this API will return\n CUDA_ERROR_NOT_SUPPORTED.\n\n If the semaphore object is any one of the following types:\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX),\n [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](crate::ffi::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT)\n then the keyed mutex will be acquired when it is released with the key\n specified in [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)[params](crate::ffi::params)[keyedmutex](crate::ffi::keyedmutex)[key](crate::ffi::key)\n or until the timeout specified by\n [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS](crate::ffi::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)[params](crate::ffi::params)[keyedmutex](crate::ffi::keyedmutex)[timeoutMs](crate::ffi::timeoutMs)\n has lapsed. The timeout interval can either be a finite value\n specified in milliseconds or an infinite value. In case an infinite\n value is specified the timeout never elapses. The windows INFINITE\n macro must be used to specify infinite timeout.\n#### extSemArray:\n- External semaphores to be waited on\n#### paramsArray:\n- Array of semaphore parameters\n#### numExtSems:\n- Number of semaphores to wait on\n#### stream:\n- Stream to enqueue the wait operations in\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_TIMEOUT](crate::ffi::CUDA_ERROR_TIMEOUT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuDestroyExternalSemaphore](crate::ffi::cuDestroyExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync)\n"]
    pub fn cuWaitExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::std::ffi::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys an external semaphore\n\n Destroys an external semaphore object and releases any references\n to the underlying resource. Any outstanding signals or waits must\n have completed before the semaphore is destroyed.\n#### extSem:\n- External semaphore to be destroyed\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuDestroyExternalSemaphore(extSem: CUexternalSemaphore) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Wait on a memory location\n\n Enqueues a synchronization of the stream on the given memory location. Work\n ordered after the operation will block until the given condition on the\n memory is satisfied. By default, the condition is to wait for\n (int32_t)(*addr - value) >= 0, a cyclic greater-or-equal.\n Other condition types can be specified via `flags`.\n\n If the memory was registered via [cuMemHostRegister](crate::ffi::cuMemHostRegister)(), the device pointer\n should be obtained with [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)(). This function cannot\n be used with managed memory ([cuMemAllocManaged](crate::ffi::cuMemAllocManaged)).\n\n Support for CU_STREAM_WAIT_VALUE_NOR can be queried with [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)() and\n [CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2).\n\n### Note:\n \\note\n Warning:\n Improper use of this API may deadlock the application. Synchronization\n ordering established through this API is not visible to CUDA. CUDA tasks\n that are (even indirectly) ordered by this API should also have that order\n expressed with CUDA-visible dependencies such as events. This ensures that\n the scheduler does not serialize them in an improper order.\n#### stream:\nThe stream to synchronize on the memory location.\n#### addr:\nThe memory location to wait on.\n#### value:\nThe value to compare with the memory location.\n#### flags:\nSee [CUstreamWaitValue_flags](crate::ffi::CUstreamWaitValue_flags).\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64),\n [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32),\n [cuStreamWriteValue64](crate::ffi::cuStreamWriteValue64),\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuMemHostRegister](crate::ffi::cuMemHostRegister),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n"]
    pub fn cuStreamWaitValue32_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Wait on a memory location\n\n Enqueues a synchronization of the stream on the given memory location. Work\n ordered after the operation will block until the given condition on the\n memory is satisfied. By default, the condition is to wait for\n (int64_t)(*addr - value) >= 0, a cyclic greater-or-equal.\n Other condition types can be specified via `flags`.\n\n If the memory was registered via [cuMemHostRegister](crate::ffi::cuMemHostRegister)(), the device pointer\n should be obtained with [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)().\n\n Support for this can be queried with [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)() and\n [CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS).\n\n### Note:\n \\note\n Warning:\n Improper use of this API may deadlock the application. Synchronization\n ordering established through this API is not visible to CUDA. CUDA tasks\n that are (even indirectly) ordered by this API should also have that order\n expressed with CUDA-visible dependencies such as events. This ensures that\n the scheduler does not serialize them in an improper order.\n#### stream:\nThe stream to synchronize on the memory location.\n#### addr:\nThe memory location to wait on.\n#### value:\nThe value to compare with the memory location.\n#### flags:\nSee [CUstreamWaitValue_flags](crate::ffi::CUstreamWaitValue_flags).\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32),\n [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32),\n [cuStreamWriteValue64](crate::ffi::cuStreamWriteValue64),\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuMemHostRegister](crate::ffi::cuMemHostRegister),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n"]
    pub fn cuStreamWaitValue64_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Write a value to memory\n\n Write a value to memory.\n\n If the memory was registered via [cuMemHostRegister](crate::ffi::cuMemHostRegister)(), the device pointer\n should be obtained with [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)(). This function cannot\n be used with managed memory ([cuMemAllocManaged](crate::ffi::cuMemAllocManaged)).\n#### stream:\nThe stream to do the write in.\n#### addr:\nThe device address to write to.\n#### value:\nThe value to write.\n#### flags:\nSee [CUstreamWriteValue_flags](crate::ffi::CUstreamWriteValue_flags).\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamWriteValue64](crate::ffi::cuStreamWriteValue64),\n [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32),\n [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64),\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuMemHostRegister](crate::ffi::cuMemHostRegister),\n [cuEventRecord](crate::ffi::cuEventRecord)\n"]
    pub fn cuStreamWriteValue32_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Write a value to memory\n\n Write a value to memory.\n\n If the memory was registered via [cuMemHostRegister](crate::ffi::cuMemHostRegister)(), the device pointer\n should be obtained with [cuMemHostGetDevicePointer](crate::ffi::cuMemHostGetDevicePointer)().\n\n Support for this can be queried with [cuDeviceGetAttribute](crate::ffi::cuDeviceGetAttribute)() and\n [CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS](crate::ffi::CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS).\n#### stream:\nThe stream to do the write in.\n#### addr:\nThe device address to write to.\n#### value:\nThe value to write.\n#### flags:\nSee [CUstreamWriteValue_flags](crate::ffi::CUstreamWriteValue_flags).\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32),\n [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32),\n [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64),\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuMemHostRegister](crate::ffi::cuMemHostRegister),\n [cuEventRecord](crate::ffi::cuEventRecord)\n"]
    pub fn cuStreamWriteValue64_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Batch operations to synchronize the stream via memory operations\n\n This is a batch version of [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32)() and [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32)().\n Batching operations may avoid some performance overhead in both the API call\n and the device execution versus adding them to the stream in separate API\n calls. The operations are enqueued in the order they appear in the array.\n\n See [CUstreamBatchMemOpType](crate::ffi::CUstreamBatchMemOpType) for the full set of supported operations, and\n [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32)(), [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64)(), [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32)(),\n and [cuStreamWriteValue64](crate::ffi::cuStreamWriteValue64)() for details of specific operations.\n\n See related APIs for details on querying support for specific operations.\n\n### Note:\n \\note\n Warning:\n Improper use of this API may deadlock the application. Synchronization\n ordering established through this API is not visible to CUDA. CUDA tasks\n that are (even indirectly) ordered by this API should also have that order\n expressed with CUDA-visible dependencies such as events. This ensures that\n the scheduler does not serialize them in an improper order. For more\n information, see the Stream Memory Operations section in the programming\n guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).\n#### stream:\nThe stream to enqueue the operations in.\n#### count:\nThe number of operations in the array. Must be less than 256.\n#### paramArray:\nThe types and parameters of the individual operations.\n#### flags:\nReserved for future expansion; must be 0.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32),\n [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64),\n [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32),\n [cuStreamWriteValue64](crate::ffi::cuStreamWriteValue64),\n [cuMemHostRegister](crate::ffi::cuMemHostRegister)\n"]
    pub fn cuStreamBatchMemOp_v2(
        stream: CUstream,
        count: ::std::ffi::c_uint,
        paramArray: *mut CUstreamBatchMemOpParams,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns information about a function\n\n Returns in `*pi` the integer value of the attribute `attrib` on the kernel\n given by `hfunc`. The supported attributes are:\n - [CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK): The maximum number of threads\n   per block, beyond which a launch of the function would fail. This number\n   depends on both the function and the device on which the function is\n   currently loaded.\n - [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES): The size in bytes of\n   statically-allocated shared memory per block required by this function.\n   This does not include dynamically-allocated shared memory requested by\n   the user at runtime.\n - [CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES): The size in bytes of user-allocated\n   constant memory required by this function.\n - [CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES): The size in bytes of local memory\n   used by each thread of this function.\n - [CU_FUNC_ATTRIBUTE_NUM_REGS](crate::ffi::CU_FUNC_ATTRIBUTE_NUM_REGS): The number of registers used by each thread\n   of this function.\n - [CU_FUNC_ATTRIBUTE_PTX_VERSION](crate::ffi::CU_FUNC_ATTRIBUTE_PTX_VERSION): The PTX virtual architecture version for\n   which the function was compiled. This value is the major PTX version * 10\n   + the minor PTX version, so a PTX version 1.3 function would return the\n   value 13. Note that this may return the undefined value of 0 for cubins\n   compiled prior to CUDA 3.0.\n - [CU_FUNC_ATTRIBUTE_BINARY_VERSION](crate::ffi::CU_FUNC_ATTRIBUTE_BINARY_VERSION): The binary architecture version for\n   which the function was compiled. This value is the major binary\n   version * 10 + the minor binary version, so a binary version 1.3 function\n   would return the value 13. Note that this will return a value of 10 for\n   legacy cubins that do not have a properly-encoded binary architecture\n   version.\n - [CU_FUNC_CACHE_MODE_CA](crate::ffi::CU_FUNC_CACHE_MODE_CA): The attribute to indicate whether the function has\n   been compiled with user specified option \"-Xptxas --dlcm=ca\" set .\n - [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES): The maximum size in bytes of\n   dynamically-allocated shared memory.\n - [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](crate::ffi::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT): Preferred shared memory-L1\n   cache split ratio in percent of total shared memory.\n - [CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET](crate::ffi::CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET): If this attribute is set, the\n   kernel must launch with a valid cluster size specified.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH): The required cluster width in\n   blocks.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT): The required cluster height in\n   blocks.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH): The required cluster depth in\n   blocks.\n - [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](crate::ffi::CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED): Indicates whether\n   the function can be launched with non-portable cluster size. 1 is allowed,\n   0 is disallowed. A non-portable cluster size may only function on the\n   specific SKUs the program is tested on. The launch might fail if the\n   program is run on a different hardware platform. CUDA API provides\n   cudaOccupancyMaxActiveClusters to assist with checking whether the desired\n   size can be launched on the current device. A portable cluster size is\n   guaranteed to be functional on all compute capabilities higher than the\n   target compute capability. The portable cluster size for sm_90 is 8 blocks\n   per cluster. This value may increase for future compute capabilities. The\n   specific hardware unit may support higher cluster sizes thats not\n   guaranteed to be portable.\n - [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](crate::ffi::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE): The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n\n With a few execeptions, function attributes may also be queried on unloaded\n function handles returned from [cuModuleEnumerateFunctions](crate::ffi::cuModuleEnumerateFunctions).\n [CUDA_ERROR_FUNCTION_NOT_LOADED](crate::ffi::CUDA_ERROR_FUNCTION_NOT_LOADED) is returned if the attribute requires a fully\n loaded function but the function is not loaded. The loading state of a function\n may be queried using [cuFuncIsloaded](crate::ffi::cuFuncIsloaded). [cuFuncLoad](crate::ffi::cuFuncLoad) may be called to explicitly\n load a function before querying the following attributes that require the function\n to be loaded:\n - [CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK)\n - [CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES)\n - [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES)\n#### pi:\n- Returned attribute value\n#### attrib:\n- Attribute requested\n#### hfunc:\n- Function to query attribute of\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_FUNCTION_NOT_LOADED](crate::ffi::CUDA_ERROR_FUNCTION_NOT_LOADED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cudaFuncGetAttributes](crate::ffi::cudaFuncGetAttributes),\n [cudaFuncSetAttribute](crate::ffi::cudaFuncSetAttribute),\n [cuFuncIsLoaded](crate::ffi::cuFuncIsLoaded),\n [cuFuncLoad](crate::ffi::cuFuncLoad),\n [cuKernelGetAttribute](crate::ffi::cuKernelGetAttribute)\n"]
    pub fn cuFuncGetAttribute(
        pi: *mut ::std::ffi::c_int,
        attrib: CUfunction_attribute,
        hfunc: CUfunction,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets information about a function\n\n This call sets the value of a specified attribute `attrib` on the kernel given\n by `hfunc` to an integer value specified by `val`\n This function returns CUDA_SUCCESS if the new value of the attribute could be\n successfully set. If the set fails, this call will return an error.\n Not all attributes can have values set. Attempting to set a value on a read-only\n attribute will result in an error (CUDA_ERROR_INVALID_VALUE)\n\n Supported attributes for the cuFuncSetAttribute call are:\n - [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES): This maximum size in bytes of\n   dynamically-allocated shared memory. The value should contain the requested\n   maximum size of dynamically-allocated shared memory. The sum of this value and\n   the function attribute [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](crate::ffi::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES) cannot exceed the\n   device attribute [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN).\n   The maximal size of requestable dynamic shared memory may differ by GPU\n   architecture.\n - [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](crate::ffi::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT): On devices where the L1\n   cache and shared memory use the same hardware resources, this sets the shared memory\n   carveout preference, in percent of the total shared memory.\n   See [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR](crate::ffi::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR)\n   This is only a hint, and the driver can choose a different ratio if required to execute the function.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH): The required cluster width in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT): The required cluster height in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](crate::ffi::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH): The required cluster depth in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](crate::ffi::CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED): Indicates whether\n   the function can be launched with non-portable cluster size. 1 is allowed,\n   0 is disallowed.\n - [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](crate::ffi::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE): The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n#### hfunc:\n- Function to query attribute of\n#### attrib:\n- Attribute requested\n#### value:\n- The value to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cudaFuncGetAttributes](crate::ffi::cudaFuncGetAttributes),\n [cudaFuncSetAttribute](crate::ffi::cudaFuncSetAttribute),\n [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    pub fn cuFuncSetAttribute(
        hfunc: CUfunction,
        attrib: CUfunction_attribute,
        value: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the preferred cache configuration for a device function\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through `config` the preferred cache configuration for\n the device function `hfunc`. This is only a preference. The driver will use\n the requested configuration if possible, but it is free to choose a different\n configuration if required to execute `hfunc`.  Any context-wide preference\n set via [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig)() will be overridden by this per-function\n setting unless the per-function setting is [CU_FUNC_CACHE_PREFER_NONE](crate::ffi::CU_FUNC_CACHE_PREFER_NONE). In\n that case, the current context-wide setting will be used.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n\n The supported cache configurations are:\n - [CU_FUNC_CACHE_PREFER_NONE](crate::ffi::CU_FUNC_CACHE_PREFER_NONE): no preference for shared memory or L1 (default)\n - [CU_FUNC_CACHE_PREFER_SHARED](crate::ffi::CU_FUNC_CACHE_PREFER_SHARED): prefer larger shared memory and smaller L1 cache\n - [CU_FUNC_CACHE_PREFER_L1](crate::ffi::CU_FUNC_CACHE_PREFER_L1): prefer larger L1 cache and smaller shared memory\n - [CU_FUNC_CACHE_PREFER_EQUAL](crate::ffi::CU_FUNC_CACHE_PREFER_EQUAL): prefer equal sized L1 cache and shared memory\n#### hfunc:\n- Kernel to configure cache for\n#### config:\n- Requested cache configuration\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cudaFuncSetCacheConfig](crate::ffi::cudaFuncSetCacheConfig),\n [cuKernelSetCacheConfig](crate::ffi::cuKernelSetCacheConfig)\n"]
    pub fn cuFuncSetCacheConfig(hfunc: CUfunction, config: CUfunc_cache) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a module handle\n\n Returns in `*hmod` the handle of the module that function `hfunc`\n is located in. The lifetime of the module corresponds to the lifetime of\n the context it was loaded in or until the module is explicitly unloaded.\n\n The CUDA runtime manages its own modules loaded into the primary context.\n If the handle returned by this API refers to a module loaded by the CUDA runtime,\n calling [cuModuleUnload](crate::ffi::cuModuleUnload)() on that module will result in undefined behavior.\n#### hmod:\n- Returned module handle\n#### hfunc:\n- Function to retrieve module for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n"]
    pub fn cuFuncGetModule(hmod: *mut CUmodule, hfunc: CUfunction) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the function name for a [CUfunction](crate::ffi::CUfunction) handle\n\n Returns in `*`*name the function name associated with the function handle `hfunc` .\n The function name is returned as a null-terminated string. The returned name is only\n valid when the function handle is valid. If the module is unloaded or reloaded, one\n must call the API again to get the updated name. This API may return a mangled name if\n the function is not declared as having C linkage. If either `*`*name or `hfunc`\n is NULL, [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n#### name:\n- The returned name of the function\n#### hfunc:\n- The function handle to retrieve the name for\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n"]
    pub fn cuFuncGetName(name: *mut *const ::std::ffi::c_char, hfunc: CUfunction) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the offset and size of a kernel parameter in the device-side parameter layout\n\n Queries the kernel parameter at `paramIndex` into `func`'s list of parameters, and returns\n in `paramOffset` and `paramSize` the offset and size, respectively, where the parameter\n will reside in the device-side parameter layout. This information can be used to update kernel\n node parameters from the device via [cudaGraphKernelNodeSetParam](crate::ffi::cudaGraphKernelNodeSetParam)() and\n [cudaGraphKernelNodeUpdatesApply](crate::ffi::cudaGraphKernelNodeUpdatesApply)(). `paramIndex` must be less than the number of parameters\n that `func` takes. `paramSize` can be set to NULL if only the parameter offset is desired.\n#### func:\n- The function to query\n#### paramIndex:\n- The parameter index to query\n#### paramOffset:\n- Returns the offset into the device-side parameter layout at which the parameter resides\n#### paramSize:\n- Optionally returns the size of the parameter in the device-side parameter layout\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuKernelGetParamInfo](crate::ffi::cuKernelGetParamInfo)\n"]
    pub fn cuFuncGetParamInfo(
        func: CUfunction,
        paramIndex: usize,
        paramOffset: *mut usize,
        paramSize: *mut usize,
    ) -> CUresult;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUfunctionLoadingState_enum {
    CU_FUNCTION_LOADING_STATE_UNLOADED = 0,
    CU_FUNCTION_LOADING_STATE_LOADED = 1,
    CU_FUNCTION_LOADING_STATE_MAX = 2,
}
pub use self::CUfunctionLoadingState_enum as CUfunctionLoadingState;
unsafe extern "C" {
    #[doc = " Returns if the function is loaded\n\n Returns in `state` the loading state of `function`.\n#### state:\n- returned loading state\n#### function:\n- the function to check\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuFuncLoad](crate::ffi::cuFuncLoad),\n [cuModuleEnumerateFunctions](crate::ffi::cuModuleEnumerateFunctions)\n"]
    pub fn cuFuncIsLoaded(state: *mut CUfunctionLoadingState, function: CUfunction) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Loads a function\n\n Finalizes function loading for `function`. Calling this API with a\n fully loaded function has no effect.\n#### function:\n- the function to load\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuModuleEnumerateFunctions](crate::ffi::cuModuleEnumerateFunctions),\n [cuFuncIsLoaded](crate::ffi::cuFuncIsLoaded)\n"]
    pub fn cuFuncLoad(function: CUfunction) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches a CUDA function [CUfunction](crate::ffi::CUfunction) or a CUDA kernel [CUkernel](crate::ffi::CUkernel)\n\n Invokes the function [CUfunction](crate::ffi::CUfunction) or the kernel [CUkernel](crate::ffi::CUkernel) `f`\n on a `gridDimX` x `gridDimY` x `gridDimZ` grid of blocks.\n Each block contains `blockDimX` x `blockDimY` x\n `blockDimZ` threads.\n\n `sharedMemBytes` sets the amount of dynamic shared memory that will be\n available to each thread block.\n\n Kernel parameters to `f` can be specified in one of two ways:\n\n 1) Kernel parameters can be specified via `kernelParams`.  If `f`\n has N parameters, then `kernelParams` needs to be an array of N\n pointers.  Each of `kernelParams`[0] through `kernelParams`[N-1]\n must point to a region of memory from which the actual kernel\n parameter will be copied.  The number of kernel parameters and their\n offsets and sizes do not need to be specified as that information is\n retrieved directly from the kernel's image.\n\n 2) Kernel parameters can also be packaged by the application into\n a single buffer that is passed in via the `extra` parameter.\n This places the burden on the application of knowing each kernel\n parameter's size and alignment/padding within the buffer.  Here is\n an example of using the `extra` parameter in this manner:\n \\code\nsize_t argBufferSize;\nchar argBuffer[256];\n\n// populate argBuffer and argBufferSize\n\nvoid *config[] = {\nCU_LAUNCH_PARAM_BUFFER_POINTER, argBuffer,\nCU_LAUNCH_PARAM_BUFFER_SIZE,    &argBufferSize,\nCU_LAUNCH_PARAM_END\n};\nstatus = cuLaunchKernel(f, gx, gy, gz, bx, by, bz, sh, s, NULL, config);\n \\endcode\n\n The `extra` parameter exists to allow [cuLaunchKernel](crate::ffi::cuLaunchKernel) to take\n additional less commonly used arguments.  `extra` specifies a list of\n names of extra settings and their corresponding values.  Each extra\n setting name is immediately followed by the corresponding value.  The\n list must be terminated with either NULL or [CU_LAUNCH_PARAM_END](crate::ffi::CU_LAUNCH_PARAM_END).\n\n - [CU_LAUNCH_PARAM_END](crate::ffi::CU_LAUNCH_PARAM_END), which indicates the end of the `extra`\n   array;\n - [CU_LAUNCH_PARAM_BUFFER_POINTER](crate::ffi::CU_LAUNCH_PARAM_BUFFER_POINTER), which specifies that the next\n   value in `extra` will be a pointer to a buffer containing all\n   the kernel parameters for launching kernel `f`;\n - [CU_LAUNCH_PARAM_BUFFER_SIZE](crate::ffi::CU_LAUNCH_PARAM_BUFFER_SIZE), which specifies that the next\n   value in `extra` will be a pointer to a size_t containing the\n   size of the buffer specified with [CU_LAUNCH_PARAM_BUFFER_POINTER](crate::ffi::CU_LAUNCH_PARAM_BUFFER_POINTER);\n\n The error [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned if kernel\n parameters are specified with both `kernelParams` and `extra`\n (i.e. both `kernelParams` and `extra` are non-NULL).\n\n Calling [cuLaunchKernel](crate::ffi::cuLaunchKernel)() invalidates the persistent function state\n set through the following deprecated APIs:\n  [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape)(),\n  [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize)(),\n  [cuParamSetSize](crate::ffi::cuParamSetSize)(),\n  [cuParamSeti](crate::ffi::cuParamSeti)(),\n  [cuParamSetf](crate::ffi::cuParamSetf)(),\n  [cuParamSetv](crate::ffi::cuParamSetv)().\n\n Note that to use [cuLaunchKernel](crate::ffi::cuLaunchKernel)(), the kernel `f` must either have\n been compiled with toolchain version 3.2 or later so that it will\n contain kernel parameter information, or have no kernel parameters.\n If either of these conditions is not met, then [cuLaunchKernel](crate::ffi::cuLaunchKernel)() will\n return [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE).\n\n Note that the API can also be used to launch context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to launch\n the kernel on will either be taken from the specified stream `hStream`\n or the current context in case of NULL stream.\n#### f:\n- Function [CUfunction](crate::ffi::CUfunction) or Kernel [CUkernel](crate::ffi::CUkernel) to launch\n#### gridDimX:\n- Width of grid in blocks\n#### gridDimY:\n- Height of grid in blocks\n#### gridDimZ:\n- Depth of grid in blocks\n#### blockDimX:\n- X dimension of each thread block\n#### blockDimY:\n- Y dimension of each thread block\n#### blockDimZ:\n- Z dimension of each thread block\n#### sharedMemBytes:\n- Dynamic shared-memory size per thread block in bytes\n#### hStream:\n- Stream identifier\n#### kernelParams:\n- Array of pointers to kernel parameters\n#### extra:\n- Extra options\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_LAUNCH_FAILED](crate::ffi::CUDA_ERROR_LAUNCH_FAILED),\n [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](crate::ffi::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES),\n [CUDA_ERROR_LAUNCH_TIMEOUT](crate::ffi::CUDA_ERROR_LAUNCH_TIMEOUT),\n [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](crate::ffi::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cudaLaunchKernel](crate::ffi::cudaLaunchKernel),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel),\n [cuKernelSetCacheConfig](crate::ffi::cuKernelSetCacheConfig),\n [cuKernelGetAttribute](crate::ffi::cuKernelGetAttribute),\n [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    pub fn cuLaunchKernel(
        f: CUfunction,
        gridDimX: ::std::ffi::c_uint,
        gridDimY: ::std::ffi::c_uint,
        gridDimZ: ::std::ffi::c_uint,
        blockDimX: ::std::ffi::c_uint,
        blockDimY: ::std::ffi::c_uint,
        blockDimZ: ::std::ffi::c_uint,
        sharedMemBytes: ::std::ffi::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::ffi::c_void,
        extra: *mut *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches a CUDA function [CUfunction](crate::ffi::CUfunction) or a CUDA kernel [CUkernel](crate::ffi::CUkernel) with launch-time configuration\n\n Invokes the function [CUfunction](crate::ffi::CUfunction) or the kernel [CUkernel](crate::ffi::CUkernel) `f` with the specified launch-time configuration\n `config`.\n\n The [CUlaunchConfig](crate::ffi::CUlaunchConfig) structure is defined as:\n\n \\code\n       typedef struct CUlaunchConfig_st {\n     unsigned int gridDimX;\n     unsigned int gridDimY;\n     unsigned int gridDimZ;\n     unsigned int blockDimX;\n     unsigned int blockDimY;\n     unsigned int blockDimZ;\n     unsigned int sharedMemBytes;\n     CUstream hStream;\n     CUlaunchAttribute *attrs;\n     unsigned int numAttrs;\n } CUlaunchConfig;\n \\endcode\n\n where:\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[gridDimX](crate::ffi::gridDimX) is the width of the grid in blocks.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[gridDimY](crate::ffi::gridDimY) is the height of the grid in blocks.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[gridDimZ](crate::ffi::gridDimZ) is the depth of the grid in blocks.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[blockDimX](crate::ffi::blockDimX) is the X dimension of each thread block.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[blockDimX](crate::ffi::blockDimX) is the Y dimension of each thread block.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[blockDimZ](crate::ffi::blockDimZ) is the Z dimension of each thread block.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[sharedMemBytes](crate::ffi::sharedMemBytes) is the dynamic shared-memory size per\n   thread block in bytes.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[hStream](crate::ffi::hStream) is the handle to the stream to perform the launch\n   in. The CUDA context associated with this stream must match that associated\n   with function f.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[attrs](crate::ffi::attrs) is an array of [CUlaunchConfig](crate::ffi::CUlaunchConfig)[numAttrs](crate::ffi::numAttrs)\n   continguous [CUlaunchAttribute](crate::ffi::CUlaunchAttribute) elements. The value of this pointer is not\n   considered if [CUlaunchConfig](crate::ffi::CUlaunchConfig)[numAttrs](crate::ffi::numAttrs) is zero. However, in that case, it\n   is recommended to set the pointer to NULL.\n - [CUlaunchConfig](crate::ffi::CUlaunchConfig)[numAttrs](crate::ffi::numAttrs) is the number of attributes populating the\n   first [CUlaunchConfig](crate::ffi::CUlaunchConfig)[numAttrs](crate::ffi::numAttrs) positions of the [CUlaunchConfig](crate::ffi::CUlaunchConfig)[attrs](crate::ffi::attrs)\n   array.\n\n Launch-time configuration is specified by adding entries to\n [CUlaunchConfig](crate::ffi::CUlaunchConfig)[attrs](crate::ffi::attrs). Each entry is an attribute ID and a corresponding\n attribute value.\n\n The [CUlaunchAttribute](crate::ffi::CUlaunchAttribute) structure is defined as:\n \\code\n       typedef struct CUlaunchAttribute_st {\n     CUlaunchAttributeID id;\n     CUlaunchAttributeValue value;\n } CUlaunchAttribute;\n \\endcode\n where:\n - [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)[id](crate::ffi::id) is a unique enum identifying the attribute.\n - [CUlaunchAttribute](crate::ffi::CUlaunchAttribute)[value](crate::ffi::value) is a union that hold the attribute value.\n\n An example of using the `config` parameter:\n \\code\n       CUlaunchAttribute coopAttr = {.id = CU_LAUNCH_ATTRIBUTE_COOPERATIVE,\n                               .value = 1};\n CUlaunchConfig config = {... // set block and grid dimensions\n                        .attrs = &coopAttr,\n                        .numAttrs = 1};\n\n cuLaunchKernelEx(&config, kernel, NULL, NULL);\n \\endcode\n\n The [CUlaunchAttributeID](crate::ffi::CUlaunchAttributeID) enum is defined as:\n \\code\n       typedef enum CUlaunchAttributeID_enum {\n     CU_LAUNCH_ATTRIBUTE_IGNORE = 0,\n     CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW   = 1,\n     CU_LAUNCH_ATTRIBUTE_COOPERATIVE            = 2,\n     CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3,\n     CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION                    = 4,\n     CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 5,\n     CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION    = 6,\n     CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT                   = 7,\n     CU_LAUNCH_ATTRIBUTE_PRIORITY               = 8,\n     CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP    = 9,\n     CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN        = 10,\n     CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION = 11,\n     CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT = 12,\n     CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE = 13,\n } CUlaunchAttributeID;\n \\endcode\n\n and the corresponding [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue) union as :\n \\code\n       typedef union CUlaunchAttributeValue_union {\n     CUaccessPolicyWindow accessPolicyWindow;\n     int cooperative;\n     CUsynchronizationPolicy syncPolicy;\n     struct {\n         unsigned int x;\n         unsigned int y;\n         unsigned int z;\n     } clusterDim;\n     CUclusterSchedulingPolicy clusterSchedulingPolicyPreference;\n     int programmaticStreamSerializationAllowed;\n     struct {\n         CUevent event;\n         int flags;\n         int triggerAtBlockStart;\n     } programmaticEvent;\n     int priority;\n     CUlaunchMemSyncDomainMap memSyncDomainMap;\n     CUlaunchMemSyncDomain memSyncDomain;\n     struct {\n         unsigned int x;\n         unsigned int y;\n         unsigned int z;\n     } preferredClusterDim;\n     struct {\n         CUevent event;\n         int flags;\n     } launchCompletionEvent;\n     struct {\n         int deviceUpdatable;\n         CUgraphDeviceNode devNode;\n     } deviceUpdatableKernelNode;\n } CUlaunchAttributeValue;\n \\endcode\n\n Setting [CU_LAUNCH_ATTRIBUTE_COOPERATIVE](crate::ffi::CU_LAUNCH_ATTRIBUTE_COOPERATIVE) to a non-zero value causes the\n kernel launch to be a cooperative launch, with exactly the same usage and\n semantics of [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel).\n\n Setting [CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION](crate::ffi::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION) to a non-zero\n values causes the kernel to use programmatic means to resolve its stream\n dependency -- enabling the CUDA runtime to opportunistically allow the grid's\n execution to overlap with the previous kernel in the stream, if that kernel\n requests the overlap.\n\n [CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT](crate::ffi::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT) records an event along with the\n kernel launch. Event recorded through this launch attribute is guaranteed to\n only trigger after all block in the associated kernel trigger the event. A\n block can trigger the event through PTX launchdep.release or CUDA builtin\n function cudaTriggerProgrammaticLaunchCompletion(). A trigger can also be\n inserted at the beginning of each block's execution if triggerAtBlockStart is\n set to non-0. Note that dependents (including the CPU thread calling\n cuEventSynchronize()) are not guaranteed to observe the release precisely\n when it is released. For example, cuEventSynchronize() may only observe the\n event trigger long after the associated kernel has completed. This recording\n type is primarily meant for establishing programmatic dependency between\n device tasks. The event supplied must not be an interprocess or interop\n event. The event must disable timing (i.e. created with\n [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING) flag set).\n\n [CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT](crate::ffi::CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT) records an event along with\n the kernel launch. Nominally, the event is triggered once all blocks of the\n kernel have begun execution. Currently this is a best effort. If a kernel B\n has a launch completion dependency on a kernel A, B may wait until A is\n complete. Alternatively, blocks of B may begin before all blocks of A have\n begun, for example:\n\n  - If B can claim execution resources unavaiable to A, for example if they\n    run on different GPUs.\n  - If B is a higher priority than A.\n\n Exercise caution if such an ordering inversion could lead to deadlock. The\n event supplied must not be an interprocess or interop event. The event must\n disable timing (i.e. must be created with the [CU_EVENT_DISABLE_TIMING](crate::ffi::CU_EVENT_DISABLE_TIMING) flag\n set).\n\n Setting [CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE](crate::ffi::CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE) to 1\n on a captured launch causes the resulting kernel node to be device-updatable.\n This attribute is specific to graphs, and passing it to a launch in a\n non-capturing stream results in an error. Passing a value other than 0 or 1 is\n not allowed.\n\n On success, a handle will be returned via\n [CUlaunchAttributeValue](crate::ffi::CUlaunchAttributeValue)[deviceUpdatableKernelNode](crate::ffi::deviceUpdatableKernelNode)[devNode](crate::ffi::devNode) which can be passed\n to the various device-side update functions to update the node's kernel parameters\n from within another kernel. For more information on the types of device updates\n that can be made, as well as the relevant limitations thereof, see\n [cudaGraphKernelNodeUpdatesApply](crate::ffi::cudaGraphKernelNodeUpdatesApply).\n\n Kernel nodes which are device-updatable have additional restrictions compared to regular\n kernel nodes. Firstly, device-updatable nodes cannot be removed from their graph via\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode). Additionally, once opted-in to this functionality, a node cannot\n opt out, and any attempt to set the attribute to 0 will result in an error. Graphs\n containing one or more device-updatable node also do not allow multiple instantiation.\n\n [CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION](crate::ffi::CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION) allows the kernel launch to\n specify a preferred substitute cluster dimension. Blocks may be grouped\n according to either the dimensions specified with this attribute (grouped\n into a \"preferred substitute cluster\"), or the one specified with\n [CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](crate::ffi::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION) attribute (grouped into a \"regular\n cluster\"). The cluster dimensions of a \"preferred substitute cluster\" shall\n be an integer multiple greater than zero of the regular cluster dimensions.\n The device will attempt - on a best-effort basis - to group thread blocks\n into preferred clusters over grouping them into regular clusters. When it\n deems necessary (primarily when the device temporarily runs out of physical\n resources to launch the larger preferred clusters), the device may switch to\n launch the regular clusters instead to attempt to utilize as much of the\n physical device resources as possible.\n\n Each type of cluster will have its enumeration / coordinate setup as if the\n grid consists solely of its type of cluster. For example, if the preferred\n substitute cluster dimensions double the regular cluster dimensions, there\n might be simultaneously a regular cluster indexed at (1,0,0), and a preferred\n cluster indexed at (1,0,0). In this example, the preferred substitute cluster\n (1,0,0) replaces regular clusters (2,0,0) and (3,0,0) and groups their\n blocks.\n\n This attribute will only take effect when a regular cluster dimension has\n been specified. The preferred substitute The preferred substitute cluster\n dimension must be an integer multiple greater than zero of the regular\n cluster dimension and must divide the grid. It must also be no more than\n `maxBlocksPerCluster`, if it is set in the kernel's `__launch_bounds__`.\n Otherwise it must be less than the maximum value the driver can support.\n Otherwise, setting this attribute to a value physically unable to fit on any\n particular device is permitted.\n\n The effect of other attributes is consistent with their effect when set via\n persistent APIs.\n\n See [cuStreamSetAttribute](crate::ffi::cuStreamSetAttribute) for\n - [CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW](crate::ffi::CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW)\n - [CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY](crate::ffi::CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY)\n\n See [cuFuncSetAttribute](crate::ffi::cuFuncSetAttribute) for\n - [CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](crate::ffi::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION)\n - [CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](crate::ffi::CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE)\n\n Kernel parameters to `f` can be specified in the same ways that they can be\n using [cuLaunchKernel](crate::ffi::cuLaunchKernel).\n\n Note that the API can also be used to launch context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to launch\n the kernel on will either be taken from the specified stream [CUlaunchConfig](crate::ffi::CUlaunchConfig)[hStream](crate::ffi::hStream)\n or the current context in case of NULL stream.\n#### config:\n- Config to launch\n#### f:\n- Function [CUfunction](crate::ffi::CUfunction) or Kernel [CUkernel](crate::ffi::CUkernel) to launch\n#### kernelParams:\n- Array of pointers to kernel parameters\n#### extra:\n- Extra options\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_LAUNCH_FAILED](crate::ffi::CUDA_ERROR_LAUNCH_FAILED),\n [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](crate::ffi::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES),\n [CUDA_ERROR_LAUNCH_TIMEOUT](crate::ffi::CUDA_ERROR_LAUNCH_TIMEOUT),\n [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](crate::ffi::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING),\n [CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE](crate::ffi::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cudaLaunchKernel](crate::ffi::cudaLaunchKernel),\n [cudaLaunchKernelEx](crate::ffi::cudaLaunchKernelEx),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel),\n [cuKernelSetCacheConfig](crate::ffi::cuKernelSetCacheConfig),\n [cuKernelGetAttribute](crate::ffi::cuKernelGetAttribute),\n [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    pub fn cuLaunchKernelEx(
        config: *const CUlaunchConfig,
        f: CUfunction,
        kernelParams: *mut *mut ::std::ffi::c_void,
        extra: *mut *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches a CUDA function [CUfunction](crate::ffi::CUfunction) or a CUDA kernel [CUkernel](crate::ffi::CUkernel) where thread blocks\n can cooperate and synchronize as they execute\n\n Invokes the function [CUfunction](crate::ffi::CUfunction) or the kernel [CUkernel](crate::ffi::CUkernel) `f` on a `gridDimX` x `gridDimY` x `gridDimZ`\n grid of blocks. Each block contains `blockDimX` x `blockDimY` x\n `blockDimZ` threads.\n\n `sharedMemBytes` sets the amount of dynamic shared memory that will be\n available to each thread block.\n\n The device on which this kernel is invoked must have a non-zero value for\n the device attribute [CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH](crate::ffi::CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH).\n\n The total number of blocks launched cannot exceed the maximum number of blocks per\n multiprocessor as returned by [cuOccupancyMaxActiveBlocksPerMultiprocessor](crate::ffi::cuOccupancyMaxActiveBlocksPerMultiprocessor) (or\n [cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](crate::ffi::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags)) times the number of multiprocessors\n as specified by the device attribute [CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT](crate::ffi::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT).\n\n The kernel cannot make use of CUDA dynamic parallelism.\n\n Kernel parameters must be specified via `kernelParams`.  If `f`\n has N parameters, then `kernelParams` needs to be an array of N\n pointers.  Each of `kernelParams`[0] through `kernelParams`[N-1]\n must point to a region of memory from which the actual kernel\n parameter will be copied.  The number of kernel parameters and their\n offsets and sizes do not need to be specified as that information is\n retrieved directly from the kernel's image.\n\n Calling [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel)() sets persistent function state that is\n the same as function state set through [cuLaunchKernel](crate::ffi::cuLaunchKernel) API\n\n When the kernel `f` is launched via [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel)(), the previous\n block shape, shared size and parameter info associated with `f`\n is overwritten.\n\n Note that to use [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel)(), the kernel `f` must either have\n been compiled with toolchain version 3.2 or later so that it will\n contain kernel parameter information, or have no kernel parameters.\n If either of these conditions is not met, then [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel)() will\n return [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE).\n\n Note that the API can also be used to launch context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to launch\n the kernel on will either be taken from the specified stream `hStream`\n or the current context in case of NULL stream.\n#### f:\n- Function [CUfunction](crate::ffi::CUfunction) or Kernel [CUkernel](crate::ffi::CUkernel) to launch\n#### gridDimX:\n- Width of grid in blocks\n#### gridDimY:\n- Height of grid in blocks\n#### gridDimZ:\n- Depth of grid in blocks\n#### blockDimX:\n- X dimension of each thread block\n#### blockDimY:\n- Y dimension of each thread block\n#### blockDimZ:\n- Z dimension of each thread block\n#### sharedMemBytes:\n- Dynamic shared-memory size per thread block in bytes\n#### hStream:\n- Stream identifier\n#### kernelParams:\n- Array of pointers to kernel parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_LAUNCH_FAILED](crate::ffi::CUDA_ERROR_LAUNCH_FAILED),\n [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](crate::ffi::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES),\n [CUDA_ERROR_LAUNCH_TIMEOUT](crate::ffi::CUDA_ERROR_LAUNCH_TIMEOUT),\n [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](crate::ffi::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING),\n [CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE](crate::ffi::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED),\n [CUDA_ERROR_NOT_FOUND](crate::ffi::CUDA_ERROR_NOT_FOUND)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuLaunchCooperativeKernelMultiDevice](crate::ffi::cuLaunchCooperativeKernelMultiDevice),\n [cudaLaunchCooperativeKernel](crate::ffi::cudaLaunchCooperativeKernel),\n [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel),\n [cuKernelSetCacheConfig](crate::ffi::cuKernelSetCacheConfig),\n [cuKernelGetAttribute](crate::ffi::cuKernelGetAttribute),\n [cuKernelSetAttribute](crate::ffi::cuKernelSetAttribute)\n"]
    pub fn cuLaunchCooperativeKernel(
        f: CUfunction,
        gridDimX: ::std::ffi::c_uint,
        gridDimY: ::std::ffi::c_uint,
        gridDimZ: ::std::ffi::c_uint,
        blockDimX: ::std::ffi::c_uint,
        blockDimY: ::std::ffi::c_uint,
        blockDimZ: ::std::ffi::c_uint,
        sharedMemBytes: ::std::ffi::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute\n\n \\deprecated This function is deprecated as of CUDA 11.3.\n\n Invokes kernels as specified in the `launchParamsList` array where each element\n of the array specifies all the parameters required to perform a single kernel launch.\n These kernels can cooperate and synchronize as they execute. The size of the array is\n specified by `numDevices`.\n\n No two kernels can be launched on the same device. All the devices targeted by this\n multi-device launch must be identical. All devices must have a non-zero value for the\n device attribute [CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH](crate::ffi::CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH).\n\n All kernels launched must be identical with respect to the compiled code. Note that\n any __device__, __constant__ or __managed__ variables present in the module that owns\n the kernel launched on each device, are independently instantiated on every device.\n It is the application's responsibility to ensure these variables are initialized and\n used appropriately.\n\n The size of the grids as specified in blocks, the size of the blocks themselves\n and the amount of shared memory used by each thread block must also match across\n all launched kernels.\n\n The streams used to launch these kernels must have been created via either [cuStreamCreate](crate::ffi::cuStreamCreate)\n or [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority). The NULL stream or [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) or [CU_STREAM_PER_THREAD](crate::ffi::CU_STREAM_PER_THREAD)\n cannot be used.\n\n The total number of blocks launched per kernel cannot exceed the maximum number of blocks\n per multiprocessor as returned by [cuOccupancyMaxActiveBlocksPerMultiprocessor](crate::ffi::cuOccupancyMaxActiveBlocksPerMultiprocessor) (or\n [cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](crate::ffi::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags)) times the number of multiprocessors\n as specified by the device attribute [CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT](crate::ffi::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT). Since the\n total number of blocks launched per device has to match across all devices, the maximum\n number of blocks that can be launched per device will be limited by the device with the\n least number of multiprocessors.\n\n The kernels cannot make use of CUDA dynamic parallelism.\n\n The [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS) structure is defined as:\n \\code\ntypedef struct CUDA_LAUNCH_PARAMS_st\n{\nCUfunction function;\nunsigned int gridDimX;\nunsigned int gridDimY;\nunsigned int gridDimZ;\nunsigned int blockDimX;\nunsigned int blockDimY;\nunsigned int blockDimZ;\nunsigned int sharedMemBytes;\nCUstream hStream;\nvoid **kernelParams;\n} CUDA_LAUNCH_PARAMS;\n \\endcode\n where:\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[function](crate::ffi::function) specifies the kernel to be launched. All functions must\n   be identical with respect to the compiled code.\n   Note that you can also specify context-less kernel [CUkernel](crate::ffi::CUkernel) by querying the handle\n   using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then casting to [CUfunction](crate::ffi::CUfunction). In this case, the context to\n   launch the kernel on be taken from the specified stream [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[hStream](crate::ffi::hStream).\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[gridDimX](crate::ffi::gridDimX) is the width of the grid in blocks. This must match across\n   all kernels launched.\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[gridDimY](crate::ffi::gridDimY) is the height of the grid in blocks. This must match across\n   all kernels launched.\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[gridDimZ](crate::ffi::gridDimZ) is the depth of the grid in blocks. This must match across\n   all kernels launched.\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[blockDimX](crate::ffi::blockDimX) is the X dimension of each thread block. This must match across\n   all kernels launched.\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[blockDimX](crate::ffi::blockDimX) is the Y dimension of each thread block. This must match across\n   all kernels launched.\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[blockDimZ](crate::ffi::blockDimZ) is the Z dimension of each thread block. This must match across\n   all kernels launched.\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[sharedMemBytes](crate::ffi::sharedMemBytes) is the dynamic shared-memory size per thread block in bytes.\n   This must match across all kernels launched.\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[hStream](crate::ffi::hStream) is the handle to the stream to perform the launch in. This cannot\n   be the NULL stream or [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY) or [CU_STREAM_PER_THREAD](crate::ffi::CU_STREAM_PER_THREAD). The CUDA context associated\n   with this stream must match that associated with [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[function](crate::ffi::function).\n - [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[kernelParams](crate::ffi::kernelParams) is an array of pointers to kernel parameters. If\n   [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[function](crate::ffi::function) has N parameters, then [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[kernelParams](crate::ffi::kernelParams)\n   needs to be an array of N pointers. Each of [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[kernelParams](crate::ffi::kernelParams)[0] through\n   [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[kernelParams](crate::ffi::kernelParams)[N-1] must point to a region of memory from which the actual\n   kernel parameter will be copied. The number of kernel parameters and their offsets and sizes\n   do not need to be specified as that information is retrieved directly from the kernel's image.\n\n By default, the kernel won't begin execution on any GPU until all prior work in all the specified\n streams has completed. This behavior can be overridden by specifying the flag\n [CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC](crate::ffi::CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC). When this flag is specified, each kernel\n will only wait for prior work in the stream corresponding to that GPU to complete before it begins\n execution.\n\n Similarly, by default, any subsequent work pushed in any of the specified streams will not begin\n execution until the kernels on all GPUs have completed. This behavior can be overridden by specifying\n the flag [CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC](crate::ffi::CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC). When this flag is specified,\n any subsequent work pushed in any of the specified streams will only wait for the kernel launched\n on the GPU corresponding to that stream to complete before it begins execution.\n\n Calling [cuLaunchCooperativeKernelMultiDevice](crate::ffi::cuLaunchCooperativeKernelMultiDevice)() sets persistent function state that is\n the same as function state set through [cuLaunchKernel](crate::ffi::cuLaunchKernel) API when called individually for each\n element in `launchParamsList`.\n\n When kernels are launched via [cuLaunchCooperativeKernelMultiDevice](crate::ffi::cuLaunchCooperativeKernelMultiDevice)(), the previous\n block shape, shared size and parameter info associated with each [CUDA_LAUNCH_PARAMS](crate::ffi::CUDA_LAUNCH_PARAMS)[function](crate::ffi::function)\n in `launchParamsList` is overwritten.\n\n Note that to use [cuLaunchCooperativeKernelMultiDevice](crate::ffi::cuLaunchCooperativeKernelMultiDevice)(), the kernels must either have\n been compiled with toolchain version 3.2 or later so that it will\n contain kernel parameter information, or have no kernel parameters.\n If either of these conditions is not met, then [cuLaunchCooperativeKernelMultiDevice](crate::ffi::cuLaunchCooperativeKernelMultiDevice)() will\n return [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE).\n#### launchParamsList:\n- List of launch parameters, one per device\n#### numDevices:\n- Size of the `launchParamsList` array\n#### flags:\n- Flags to control launch behavior\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_IMAGE](crate::ffi::CUDA_ERROR_INVALID_IMAGE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_LAUNCH_FAILED](crate::ffi::CUDA_ERROR_LAUNCH_FAILED),\n [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](crate::ffi::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES),\n [CUDA_ERROR_LAUNCH_TIMEOUT](crate::ffi::CUDA_ERROR_LAUNCH_TIMEOUT),\n [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](crate::ffi::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING),\n [CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE](crate::ffi::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel),\n [cudaLaunchCooperativeKernelMultiDevice](crate::ffi::cudaLaunchCooperativeKernelMultiDevice)\n"]
    pub fn cuLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut CUDA_LAUNCH_PARAMS,
        numDevices: ::std::ffi::c_uint,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Enqueues a host function call in a stream\n\n Enqueues a host function to run in a stream.  The function will be called\n after currently enqueued work and will block work added after it.\n\n The host function must not make any CUDA API calls.  Attempting to use a\n CUDA API may result in [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED), but this is not required.\n The host function must not perform any synchronization that may depend on\n outstanding CUDA work not mandated to run earlier.  Host functions without a\n mandated order (such as in independent streams) execute in undefined order\n and may be serialized.\n\n For the purposes of Unified Memory, execution makes a number of guarantees:\n <ul>\n   <li>The stream is considered idle for the duration of the function's\n   execution.  Thus, for example, the function may always use memory attached\n   to the stream it was enqueued in.</li>\n   <li>The start of execution of the function has the same effect as\n   synchronizing an event recorded in the same stream immediately prior to\n   the function.  It thus synchronizes streams which have been \"joined\"\n   prior to the function.</li>\n   <li>Adding device work to any stream does not have the effect of making\n   the stream active until all preceding host functions and stream callbacks\n   have executed.  Thus, for\n   example, a function might use global attached memory even if work has\n   been added to another stream, if the work has been ordered behind the\n   function call with an event.</li>\n   <li>Completion of the function does not cause a stream to become\n   active except as described above.  The stream will remain idle\n   if no device work follows the function, and will remain idle across\n   consecutive host functions or stream callbacks without device work in\n   between.  Thus, for example,\n   stream synchronization can be done by signaling from a host function at the\n   end of the stream.</li>\n </ul>\n\n Note that, in contrast to [cuStreamAddCallback](crate::ffi::cuStreamAddCallback), the function will not be\n called in the event of an error in the CUDA context.\n#### hStream:\n- Stream to enqueue function call in\n#### fn:\n- The function to call once preceding stream operations are complete\n#### userData:\n- User-specified data to be passed to the function\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuMemAllocManaged](crate::ffi::cuMemAllocManaged),\n [cuStreamAttachMemAsync](crate::ffi::cuStreamAttachMemAsync),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback)\n"]
    pub fn cuLaunchHostFunc(
        hStream: CUstream,
        fn_: CUhostFn,
        userData: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the block-dimensions for the function\n\n \\deprecated\n\n Specifies the `x`, `y`, and `z` dimensions of the thread blocks that are\n created when the kernel given by `hfunc` is launched.\n#### hfunc:\n- Kernel to specify dimensions of\n#### x:\n- X dimension\n#### y:\n- Y dimension\n#### z:\n- Z dimension\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuFuncSetBlockShape(
        hfunc: CUfunction,
        x: ::std::ffi::c_int,
        y: ::std::ffi::c_int,
        z: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the dynamic shared-memory size for the function\n\n \\deprecated\n\n Sets through `bytes` the amount of dynamic shared memory that will be\n available to each thread block when the kernel given by `hfunc` is launched.\n#### hfunc:\n- Kernel to specify dynamic shared-memory size for\n#### bytes:\n- Dynamic shared-memory size per thread in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetCacheConfig](crate::ffi::cuFuncSetCacheConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuFuncSetSharedSize(hfunc: CUfunction, bytes: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameter size for the function\n\n \\deprecated\n\n Sets through `numbytes` the total size in bytes needed by the function\n parameters of the kernel corresponding to `hfunc`.\n#### hfunc:\n- Kernel to set parameter size for\n#### numbytes:\n- Size of parameter list in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuParamSetSize(hfunc: CUfunction, numbytes: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds an integer parameter to the function's argument list\n\n \\deprecated\n\n Sets an integer parameter that will be specified the next time the\n kernel corresponding to `hfunc` will be invoked. `offset` is a byte offset.\n#### hfunc:\n- Kernel to add parameter to\n#### offset:\n- Offset to add parameter to argument list\n#### value:\n- Value of parameter\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuParamSeti(
        hfunc: CUfunction,
        offset: ::std::ffi::c_int,
        value: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds a floating-point parameter to the function's argument list\n\n \\deprecated\n\n Sets a floating-point parameter that will be specified the next time the\n kernel corresponding to `hfunc` will be invoked. `offset` is a byte offset.\n#### hfunc:\n- Kernel to add parameter to\n#### offset:\n- Offset to add parameter to argument list\n#### value:\n- Value of parameter\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuParamSetf(hfunc: CUfunction, offset: ::std::ffi::c_int, value: f32) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds arbitrary data to the function's argument list\n\n \\deprecated\n\n Copies an arbitrary amount of data (specified in `numbytes`) from `ptr`\n into the parameter space of the kernel corresponding to `hfunc`. `offset`\n is a byte offset.\n#### hfunc:\n- Kernel to add data to\n#### offset:\n- Offset to add data to argument list\n#### ptr:\n- Pointer to arbitrary data\n#### numbytes:\n- Size of data to copy in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuParamSetv(
        hfunc: CUfunction,
        offset: ::std::ffi::c_int,
        ptr: *mut ::std::ffi::c_void,
        numbytes: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches a CUDA function\n\n \\deprecated\n\n Invokes the kernel `f` on a 1 x 1 x 1 grid of blocks. The block\n contains the number of threads specified by a previous call to\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape)().\n\n The block shape, dynamic shared memory size, and parameter information\n must be set using\n  [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape)(),\n  [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize)(),\n  [cuParamSetSize](crate::ffi::cuParamSetSize)(),\n  [cuParamSeti](crate::ffi::cuParamSeti)(),\n  [cuParamSetf](crate::ffi::cuParamSetf)(), and\n  [cuParamSetv](crate::ffi::cuParamSetv)()\n prior to calling this function.\n\n Launching a function via [cuLaunchKernel](crate::ffi::cuLaunchKernel)() invalidates the function's\n block shape, dynamic shared memory size, and parameter information. After\n launching via cuLaunchKernel, this state must be re-initialized prior to\n calling this function. Failure to do so results in undefined behavior.\n#### f:\n- Kernel to launch\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_LAUNCH_FAILED](crate::ffi::CUDA_ERROR_LAUNCH_FAILED),\n [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](crate::ffi::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES),\n [CUDA_ERROR_LAUNCH_TIMEOUT](crate::ffi::CUDA_ERROR_LAUNCH_TIMEOUT),\n [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](crate::ffi::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuLaunch(f: CUfunction) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches a CUDA function\n\n \\deprecated\n\n Invokes the kernel `f` on a `grid_width` x `grid_height` grid of\n blocks. Each block contains the number of threads specified by a previous\n call to [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape)().\n\n The block shape, dynamic shared memory size, and parameter information\n must be set using\n  [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape)(),\n  [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize)(),\n  [cuParamSetSize](crate::ffi::cuParamSetSize)(),\n  [cuParamSeti](crate::ffi::cuParamSeti)(),\n  [cuParamSetf](crate::ffi::cuParamSetf)(), and\n  [cuParamSetv](crate::ffi::cuParamSetv)()\n prior to calling this function.\n\n Launching a function via [cuLaunchKernel](crate::ffi::cuLaunchKernel)() invalidates the function's\n block shape, dynamic shared memory size, and parameter information. After\n launching via cuLaunchKernel, this state must be re-initialized prior to\n calling this function. Failure to do so results in undefined behavior.\n#### f:\n- Kernel to launch\n#### grid_width:\n- Width of grid in blocks\n#### grid_height:\n- Height of grid in blocks\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_LAUNCH_FAILED](crate::ffi::CUDA_ERROR_LAUNCH_FAILED),\n [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](crate::ffi::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES),\n [CUDA_ERROR_LAUNCH_TIMEOUT](crate::ffi::CUDA_ERROR_LAUNCH_TIMEOUT),\n [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](crate::ffi::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGridAsync](crate::ffi::cuLaunchGridAsync),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuLaunchGrid(
        f: CUfunction,
        grid_width: ::std::ffi::c_int,
        grid_height: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches a CUDA function\n\n \\deprecated\n\n Invokes the kernel `f` on a `grid_width` x `grid_height` grid of\n blocks. Each block contains the number of threads specified by a previous\n call to [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape)().\n\n The block shape, dynamic shared memory size, and parameter information\n must be set using\n  [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape)(),\n  [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize)(),\n  [cuParamSetSize](crate::ffi::cuParamSetSize)(),\n  [cuParamSeti](crate::ffi::cuParamSeti)(),\n  [cuParamSetf](crate::ffi::cuParamSetf)(), and\n  [cuParamSetv](crate::ffi::cuParamSetv)()\n prior to calling this function.\n\n Launching a function via [cuLaunchKernel](crate::ffi::cuLaunchKernel)() invalidates the function's\n block shape, dynamic shared memory size, and parameter information. After\n launching via cuLaunchKernel, this state must be re-initialized prior to\n calling this function. Failure to do so results in undefined behavior.\n#### f:\n- Kernel to launch\n#### grid_width:\n- Width of grid in blocks\n#### grid_height:\n- Height of grid in blocks\n#### hStream:\n- Stream identifier\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_LAUNCH_FAILED](crate::ffi::CUDA_ERROR_LAUNCH_FAILED),\n [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](crate::ffi::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES),\n [CUDA_ERROR_LAUNCH_TIMEOUT](crate::ffi::CUDA_ERROR_LAUNCH_TIMEOUT),\n [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](crate::ffi::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING),\n [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](crate::ffi::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED)\n\n### Note:\n ### Note:\nIn certain cases where cubins are created with no ABI (i.e., using `ptxas` \\p --abi-compile `no`),\n       this function may serialize kernel launches. The CUDA driver retains asynchronous behavior by\n       growing the per-thread stack as needed per launch and not shrinking it afterwards.\n\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuFuncSetBlockShape](crate::ffi::cuFuncSetBlockShape),\n [cuFuncSetSharedSize](crate::ffi::cuFuncSetSharedSize),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuParamSetSize](crate::ffi::cuParamSetSize),\n [cuParamSetf](crate::ffi::cuParamSetf),\n [cuParamSeti](crate::ffi::cuParamSeti),\n [cuParamSetv](crate::ffi::cuParamSetv),\n [cuLaunch](crate::ffi::cuLaunch),\n [cuLaunchGrid](crate::ffi::cuLaunchGrid),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel)\n"]
    pub fn cuLaunchGridAsync(
        f: CUfunction,
        grid_width: ::std::ffi::c_int,
        grid_height: ::std::ffi::c_int,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds a texture-reference to the function's argument list\n\n \\deprecated\n\n Makes the CUDA array or linear memory bound to the texture reference\n `hTexRef` available to a device program as a texture. In this version of\n CUDA, the texture-reference must be obtained via [cuModuleGetTexRef](crate::ffi::cuModuleGetTexRef)() and\n the `texunit` parameter must be set to [CU_PARAM_TR_DEFAULT](crate::ffi::CU_PARAM_TR_DEFAULT).\n#### hfunc:\n- Kernel to add texture-reference to\n#### texunit:\n- Texture unit (must be [CU_PARAM_TR_DEFAULT](crate::ffi::CU_PARAM_TR_DEFAULT))\n#### hTexRef:\n- Texture-reference to add to argument list\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n"]
    pub fn cuParamSetTexRef(
        hfunc: CUfunction,
        texunit: ::std::ffi::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the shared memory configuration for a device function.\n\n \\deprecated\n\n On devices with configurable shared memory banks, this function will\n force all subsequent launches of the specified device function to have\n the given shared memory bank size configuration. On any given launch of the\n function, the shared memory configuration of the device will be temporarily\n changed if needed to suit the function's preferred configuration. Changes in\n shared memory configuration between subsequent launches of functions,\n may introduce a device side synchronization point.\n\n Any per-function setting of shared memory bank size set via\n [cuFuncSetSharedMemConfig](crate::ffi::cuFuncSetSharedMemConfig) will override the context wide setting set with\n [cuCtxSetSharedMemConfig](crate::ffi::cuCtxSetSharedMemConfig).\n\n Changing the shared memory bank size will not increase shared memory usage\n or affect occupancy of kernels, but may have major effects on performance.\n Larger bank sizes will allow for greater potential bandwidth to shared memory,\n but will change what kinds of accesses to shared memory will result in bank\n conflicts.\n\n This function will do nothing on devices with fixed shared memory bank size.\n\n The supported bank configurations are:\n - [CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE): use the context's shared memory\n   configuration when launching this function.\n - [CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE): set shared memory bank width to\n   be natively four bytes when launching this function.\n - [CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE](crate::ffi::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE): set shared memory bank width to\n   be natively eight bytes when launching this function.\n#### hfunc:\n- kernel to be given a shared memory config\n#### config:\n- requested shared memory configuration\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuCtxGetCacheConfig](crate::ffi::cuCtxGetCacheConfig),\n [cuCtxSetCacheConfig](crate::ffi::cuCtxSetCacheConfig),\n [cuCtxGetSharedMemConfig](crate::ffi::cuCtxGetSharedMemConfig),\n [cuCtxSetSharedMemConfig](crate::ffi::cuCtxSetSharedMemConfig),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cudaFuncSetSharedMemConfig](crate::ffi::cudaFuncSetSharedMemConfig)\n"]
    pub fn cuFuncSetSharedMemConfig(hfunc: CUfunction, config: CUsharedconfig) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a graph\n\n Creates an empty graph, which is returned via `phGraph`.\n#### phGraph:\n- Returns newly created graph\n#### flags:\n- Graph creation flags, must be 0\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate),\n [cuGraphDestroy](crate::ffi::cuGraphDestroy),\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphClone](crate::ffi::cuGraphClone)\n"]
    pub fn cuGraphCreate(phGraph: *mut CUgraph, flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a kernel execution node and adds it to a graph\n\n Creates a new kernel execution node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies` and arguments specified in `nodeParams`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n The CUDA_KERNEL_NODE_PARAMS structure is defined as:\n\n \\code\n  typedef struct CUDA_KERNEL_NODE_PARAMS_st {\n      CUfunction func;\n      unsigned int gridDimX;\n      unsigned int gridDimY;\n      unsigned int gridDimZ;\n      unsigned int blockDimX;\n      unsigned int blockDimY;\n      unsigned int blockDimZ;\n      unsigned int sharedMemBytes;\n      void **kernelParams;\n      void **extra;\n      CUkernel kern;\n      CUcontext ctx;\n  } CUDA_KERNEL_NODE_PARAMS;\n \\endcode\n\n When the graph is launched, the node will invoke kernel `func` on a (`gridDimX` x\n `gridDimY` x `gridDimZ`) grid of blocks. Each block contains\n (`blockDimX` x `blockDimY` x `blockDimZ`) threads.\n\n `sharedMemBytes` sets the amount of dynamic shared memory that will be\n available to each thread block.\n\n Kernel parameters to `func` can be specified in one of two ways:\n\n 1) Kernel parameters can be specified via `kernelParams`. If the kernel has N\n parameters, then `kernelParams` needs to be an array of N pointers. Each pointer,\n from `kernelParams`[0] to `kernelParams`[N-1], points to the region of memory from which the actual\n parameter will be copied. The number of kernel parameters and their offsets and sizes do not need\n to be specified as that information is retrieved directly from the kernel's image.\n\n 2) Kernel parameters for non-cooperative kernels can also be packaged by the application into a single\n buffer that is passed in via `extra`. This places the burden on the application of knowing each\n kernel parameter's size and alignment/padding within the buffer. The `extra` parameter exists\n to allow this function to take additional less commonly used arguments. `extra` specifies\n a list of names of extra settings and their corresponding values. Each extra setting name is\n immediately followed by the corresponding value. The list must be terminated with either NULL or\n CU_LAUNCH_PARAM_END.\n\n - [CU_LAUNCH_PARAM_END](crate::ffi::CU_LAUNCH_PARAM_END), which indicates the end of the `extra`\n   array;\n - [CU_LAUNCH_PARAM_BUFFER_POINTER](crate::ffi::CU_LAUNCH_PARAM_BUFFER_POINTER), which specifies that the next\n   value in `extra` will be a pointer to a buffer\n   containing all the kernel parameters for launching kernel\n   `func`;\n - [CU_LAUNCH_PARAM_BUFFER_SIZE](crate::ffi::CU_LAUNCH_PARAM_BUFFER_SIZE), which specifies that the next\n   value in `extra` will be a pointer to a size_t\n   containing the size of the buffer specified with\n   [CU_LAUNCH_PARAM_BUFFER_POINTER](crate::ffi::CU_LAUNCH_PARAM_BUFFER_POINTER);\n\n The error [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned if kernel parameters are specified with both\n `kernelParams` and `extra` (i.e. both `kernelParams` and `extra` are non-NULL).\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) will be returned if `extra` is used for a cooperative kernel.\n\n The `kernelParams` or `extra` array, as well as the argument values it points to,\n are copied during this call.\n\n### Note:\n ### Note:\nKernels launched using graphs must not use texture and surface references. Reading or\n       writing through any texture or surface reference is undefined behavior.\n       This restriction does not apply to texture and surface objects.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Parameters for the GPU execution node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cuLaunchCooperativeKernel](crate::ffi::cuLaunchCooperativeKernel),\n [cuGraphKernelNodeGetParams](crate::ffi::cuGraphKernelNodeGetParams),\n [cuGraphKernelNodeSetParams](crate::ffi::cuGraphKernelNodeSetParams),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddKernelNode_v2(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a kernel node's parameters\n\n Returns the parameters of kernel node `hNode` in `nodeParams`.\n The `kernelParams` or `extra` array returned in `nodeParams`,\n as well as the argument values it points to, are owned by the node.\n This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use [cuGraphKernelNodeSetParams](crate::ffi::cuGraphKernelNodeSetParams) to update the\n parameters of this node.\n\n The params will contain either `kernelParams` or `extra`,\n according to which of these was most recently set on the node.\n#### hNode:\n- Node to get the parameters for\n#### nodeParams:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphKernelNodeSetParams](crate::ffi::cuGraphKernelNodeSetParams)\n"]
    pub fn cuGraphKernelNodeGetParams_v2(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets a kernel node's parameters\n\n Sets the parameters of kernel node `hNode` to `nodeParams`.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphKernelNodeGetParams](crate::ffi::cuGraphKernelNodeGetParams)\n"]
    pub fn cuGraphKernelNodeSetParams_v2(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a memcpy node and adds it to a graph\n\n Creates a new memcpy node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n When the graph is launched, the node will perform the memcpy described by `copyParams`.\n See [cuMemcpy3D](crate::ffi::cuMemcpy3D)() for a description of the structure and its restrictions.\n\n Memcpy nodes have some additional restrictions with regards to managed memory, if the\n system contains at least one device which has a zero value for the device attribute\n [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](crate::ffi::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS). If one or more of the operands refer\n to managed memory, then using the memory type [CU_MEMORYTYPE_UNIFIED](crate::ffi::CU_MEMORYTYPE_UNIFIED) is disallowed\n for those operand(s). The managed memory will be treated as residing on either the\n host or the device, depending on which memory type is specified.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### copyParams:\n- Parameters for the memory copy\n#### ctx:\n- Context on which to run the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D),\n [cuGraphMemcpyNodeGetParams](crate::ffi::cuGraphMemcpyNodeGetParams),\n [cuGraphMemcpyNodeSetParams](crate::ffi::cuGraphMemcpyNodeSetParams),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddMemcpyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a memcpy node's parameters\n\n Returns the parameters of memcpy node `hNode` in `nodeParams`.\n#### hNode:\n- Node to get the parameters for\n#### nodeParams:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMemcpy3D](crate::ffi::cuMemcpy3D),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphMemcpyNodeSetParams](crate::ffi::cuGraphMemcpyNodeSetParams)\n"]
    pub fn cuGraphMemcpyNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMCPY3D,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets a memcpy node's parameters\n\n Sets the parameters of memcpy node `hNode` to `nodeParams`.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuMemcpy3D](crate::ffi::cuMemcpy3D),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphMemcpyNodeGetParams](crate::ffi::cuGraphMemcpyNodeGetParams)\n"]
    pub fn cuGraphMemcpyNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMCPY3D,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a memset node and adds it to a graph\n\n Creates a new memset node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n The element size must be 1, 2, or 4 bytes.\n When the graph is launched, the node will perform the memset described by `memsetParams`.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### memsetParams:\n- Parameters for the memory set\n#### ctx:\n- Context on which to run the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32),\n [cuGraphMemsetNodeGetParams](crate::ffi::cuGraphMemsetNodeGetParams),\n [cuGraphMemsetNodeSetParams](crate::ffi::cuGraphMemsetNodeSetParams),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode)\n"]
    pub fn cuGraphAddMemsetNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a memset node's parameters\n\n Returns the parameters of memset node `hNode` in `nodeParams`.\n#### hNode:\n- Node to get the parameters for\n#### nodeParams:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode),\n [cuGraphMemsetNodeSetParams](crate::ffi::cuGraphMemsetNodeSetParams)\n"]
    pub fn cuGraphMemsetNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets a memset node's parameters\n\n Sets the parameters of memset node `hNode` to `nodeParams`.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuMemsetD2D32](crate::ffi::cuMemsetD2D32),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode),\n [cuGraphMemsetNodeGetParams](crate::ffi::cuGraphMemsetNodeGetParams)\n"]
    pub fn cuGraphMemsetNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a host execution node and adds it to a graph\n\n Creates a new CPU execution node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies` and arguments specified in `nodeParams`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n When the graph is launched, the node will invoke the specified CPU function.\n Host nodes are not supported under MPS with pre-Volta GPUs.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Parameters for the host node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuLaunchHostFunc](crate::ffi::cuLaunchHostFunc),\n [cuGraphHostNodeGetParams](crate::ffi::cuGraphHostNodeGetParams),\n [cuGraphHostNodeSetParams](crate::ffi::cuGraphHostNodeSetParams),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddHostNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a host node's parameters\n\n Returns the parameters of host node `hNode` in `nodeParams`.\n#### hNode:\n- Node to get the parameters for\n#### nodeParams:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuLaunchHostFunc](crate::ffi::cuLaunchHostFunc),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphHostNodeSetParams](crate::ffi::cuGraphHostNodeSetParams)\n"]
    pub fn cuGraphHostNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets a host node's parameters\n\n Sets the parameters of host node `hNode` to `nodeParams`.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuLaunchHostFunc](crate::ffi::cuLaunchHostFunc),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphHostNodeGetParams](crate::ffi::cuGraphHostNodeGetParams)\n"]
    pub fn cuGraphHostNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a child graph node and adds it to a graph\n\n Creates a new node which executes an embedded graph, and adds it to `hGraph` with\n `numDependencies` dependencies specified via `dependencies`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n If `hGraph` contains allocation or free nodes, this call will return an error.\n\n The node executes an embedded child graph. The child graph is cloned in this call.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### childGraph:\n- The graph to clone into this node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphChildGraphNodeGetGraph](crate::ffi::cuGraphChildGraphNodeGetGraph),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode),\n [cuGraphClone](crate::ffi::cuGraphClone)\n"]
    pub fn cuGraphAddChildGraphNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        childGraph: CUgraph,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets a handle to the embedded graph of a child graph node\n\n Gets a handle to the embedded graph in a child graph node. This call\n does not clone the graph. Changes to the graph will be reflected in\n the node, and the node retains ownership of the graph.\n\n Allocation and free nodes cannot be added to the returned graph.\n Attempting to do so will return an error.\n#### hNode:\n- Node to get the embedded graph for\n#### phGraph:\n- Location to store a handle to the graph\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphNodeFindInClone](crate::ffi::cuGraphNodeFindInClone)\n"]
    pub fn cuGraphChildGraphNodeGetGraph(hNode: CUgraphNode, phGraph: *mut CUgraph) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an empty node and adds it to a graph\n\n Creates a new node which performs no operation, and adds it to `hGraph` with\n `numDependencies` dependencies specified via `dependencies`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n An empty node performs no operation during execution, but can be used for\n transitive ordering. For example, a phased execution graph with 2 groups of n\n nodes with a barrier between them can be represented using an empty node and\n 2*n dependency edges, rather than no empty node and n^2 dependency edges.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddEmptyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an event record node and adds it to a graph\n\n Creates a new event record node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies` and event specified in `event`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n Each launch of the graph will record `event` to capture execution of the\n node's dependencies.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### event:\n- Event for the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddEventRecordNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the event associated with an event record node\n\n Returns the event of event record node `hNode` in `event_out`.\n#### hNode:\n- Node to get the event for\n#### event_out:\n- Pointer to return the event\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuGraphEventRecordNodeSetEvent](crate::ffi::cuGraphEventRecordNodeSetEvent),\n [cuGraphEventWaitNodeGetEvent](crate::ffi::cuGraphEventWaitNodeGetEvent),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n"]
    pub fn cuGraphEventRecordNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets an event record node's event\n\n Sets the event of event record node `hNode` to `event`.\n#### hNode:\n- Node to set the event for\n#### event:\n- Event to use\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuGraphEventRecordNodeGetEvent](crate::ffi::cuGraphEventRecordNodeGetEvent),\n [cuGraphEventWaitNodeSetEvent](crate::ffi::cuGraphEventWaitNodeSetEvent),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n"]
    pub fn cuGraphEventRecordNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an event wait node and adds it to a graph\n\n Creates a new event wait node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies` and event specified in `event`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n The graph node will wait for all work captured in `event`.  See [cuEventRecord](crate::ffi::cuEventRecord)()\n for details on what is captured by an event. `event` may be from a different context\n or device than the launch stream.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### event:\n- Event for the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddEventWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the event associated with an event wait node\n\n Returns the event of event wait node `hNode` in `event_out`.\n#### hNode:\n- Node to get the event for\n#### event_out:\n- Pointer to return the event\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuGraphEventWaitNodeSetEvent](crate::ffi::cuGraphEventWaitNodeSetEvent),\n [cuGraphEventRecordNodeGetEvent](crate::ffi::cuGraphEventRecordNodeGetEvent),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n"]
    pub fn cuGraphEventWaitNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets an event wait node's event\n\n Sets the event of event wait node `hNode` to `event`.\n#### hNode:\n- Node to set the event for\n#### event:\n- Event to use\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuGraphEventWaitNodeGetEvent](crate::ffi::cuGraphEventWaitNodeGetEvent),\n [cuGraphEventRecordNodeSetEvent](crate::ffi::cuGraphEventRecordNodeSetEvent),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n"]
    pub fn cuGraphEventWaitNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an external semaphore signal node and adds it to a graph\n\n Creates a new external semaphore signal node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified\n in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the\n node will be placed at the root of the graph. `dependencies` may not have any\n duplicate entries. A handle to the new node will be returned in `phGraphNode`.\n\n Performs a signal operation on a set of externally allocated semaphore objects\n when the node is launched.  The operation(s) will occur after all of the node's\n dependencies have completed.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Parameters for the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphExternalSemaphoresSignalNodeGetParams](crate::ffi::cuGraphExternalSemaphoresSignalNodeGetParams),\n [cuGraphExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddExternalSemaphoresSignalNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns an external semaphore signal node's parameters\n\n Returns the parameters of an external semaphore signal node `hNode` in `params_out`.\n The `extSemArray` and `paramsArray` returned in `params_out`,\n are owned by the node.  This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use [cuGraphExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExternalSemaphoresSignalNodeSetParams) to update the\n parameters of this node.\n#### hNode:\n- Node to get the parameters for\n#### params_out:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cuGraphAddExternalSemaphoresSignalNode](crate::ffi::cuGraphAddExternalSemaphoresSignalNode),\n [cuGraphExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExternalSemaphoresSignalNodeSetParams),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuGraphExternalSemaphoresSignalNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets an external semaphore signal node's parameters\n\n Sets the parameters of an external semaphore signal node `hNode` to `nodeParams`.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuGraphAddExternalSemaphoresSignalNode](crate::ffi::cuGraphAddExternalSemaphoresSignalNode),\n [cuGraphExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExternalSemaphoresSignalNodeSetParams),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuGraphExternalSemaphoresSignalNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an external semaphore wait node and adds it to a graph\n\n Creates a new external semaphore wait node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies` and arguments specified in `nodeParams`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries. A handle\n to the new node will be returned in `phGraphNode`.\n\n Performs a wait operation on a set of externally allocated semaphore objects\n when the node is launched.  The node's dependencies will not be launched until\n the wait operation has completed.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Parameters for the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphExternalSemaphoresWaitNodeGetParams](crate::ffi::cuGraphExternalSemaphoresWaitNodeGetParams),\n [cuGraphExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphAddExternalSemaphoresSignalNode](crate::ffi::cuGraphAddExternalSemaphoresSignalNode),\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddExternalSemaphoresWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns an external semaphore wait node's parameters\n\n Returns the parameters of an external semaphore wait node `hNode` in `params_out`.\n The `extSemArray` and `paramsArray` returned in `params_out`,\n are owned by the node.  This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use [cuGraphExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExternalSemaphoresSignalNodeSetParams) to update the\n parameters of this node.\n#### hNode:\n- Node to get the parameters for\n#### params_out:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuLaunchKernel](crate::ffi::cuLaunchKernel),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuGraphExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExternalSemaphoresWaitNodeSetParams),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuGraphExternalSemaphoresWaitNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets an external semaphore wait node's parameters\n\n Sets the parameters of an external semaphore wait node `hNode` to `nodeParams`.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuGraphExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExternalSemaphoresWaitNodeSetParams),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync)\n"]
    pub fn cuGraphExternalSemaphoresWaitNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a batch memory operation node and adds it to a graph\n\n Creates a new batch memory operation node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries.\n A handle to the new node will be returned in `phGraphNode`.\n\n When the node is added, the paramArray inside `nodeParams` is copied and therefore it can be\n freed after the call returns.\n\n### Note:\n \\note\n Warning:\n Improper use of this API may deadlock the application. Synchronization\n ordering established through this API is not visible to CUDA. CUDA tasks\n that are (even indirectly) ordered by this API should also have that order\n expressed with CUDA-visible dependencies such as events. This ensures that\n the scheduler does not serialize them in an improper order. For more\n information, see the Stream Memory Operations section in the programming\n guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Parameters for the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuStreamWaitValue32](crate::ffi::cuStreamWaitValue32),\n [cuStreamWriteValue32](crate::ffi::cuStreamWriteValue32),\n [cuStreamWaitValue64](crate::ffi::cuStreamWaitValue64),\n [cuStreamWriteValue64](crate::ffi::cuStreamWriteValue64),\n [cuGraphBatchMemOpNodeGetParams](crate::ffi::cuGraphBatchMemOpNodeGetParams),\n [cuGraphBatchMemOpNodeSetParams](crate::ffi::cuGraphBatchMemOpNodeSetParams),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddBatchMemOpNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a batch mem op node's parameters\n\n Returns the parameters of batch mem op node `hNode` in `nodeParams_out`.\n The `paramArray` returned in `nodeParams_out` is owned by the node.\n This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use [cuGraphBatchMemOpNodeSetParams](crate::ffi::cuGraphBatchMemOpNodeSetParams) to update the\n parameters of this node.\n#### hNode:\n- Node to get the parameters for\n#### nodeParams_out:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuGraphAddBatchMemOpNode](crate::ffi::cuGraphAddBatchMemOpNode),\n [cuGraphBatchMemOpNodeSetParams](crate::ffi::cuGraphBatchMemOpNodeSetParams)\n"]
    pub fn cuGraphBatchMemOpNodeGetParams(
        hNode: CUgraphNode,
        nodeParams_out: *mut CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets a batch mem op node's parameters\n\n Sets the parameters of batch mem op node `hNode` to `nodeParams`.\n\n The paramArray inside `nodeParams` is copied and therefore it can be\n freed after the call returns.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuGraphAddBatchMemOpNode](crate::ffi::cuGraphAddBatchMemOpNode),\n [cuGraphBatchMemOpNodeGetParams](crate::ffi::cuGraphBatchMemOpNodeGetParams)\n"]
    pub fn cuGraphBatchMemOpNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameters for a batch mem op node in the given graphExec\n\n Sets the parameters of a batch mem op node in an executable graph `hGraphExec`.\n The node is identified by the corresponding node `hNode` in the\n non-executable graph, from which the executable graph was instantiated.\n\n The following fields on operations may be modified on an executable graph:\n\n  op.waitValue.address\n  op.waitValue.value[64]\n  op.waitValue.flags bits corresponding to wait type (i.e. CU_STREAM_WAIT_VALUE_FLUSH bit cannot be modified)\n  op.writeValue.address\n  op.writeValue.value[64]\n\n Other fields, such as the context, count or type of operations, and other types of operations such as membars,\n may not be modified.\n\n `hNode` must not have been removed from the original graph.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n\n The paramArray inside `nodeParams` is copied and therefore it can be\n freed after the call returns.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- Batch mem op node from the graph from which graphExec was instantiated\n#### nodeParams:\n- Updated Parameters to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuStreamBatchMemOp](crate::ffi::cuStreamBatchMemOp),\n [cuGraphAddBatchMemOpNode](crate::ffi::cuGraphAddBatchMemOpNode),\n [cuGraphBatchMemOpNodeGetParams](crate::ffi::cuGraphBatchMemOpNodeGetParams),\n [cuGraphBatchMemOpNodeSetParams](crate::ffi::cuGraphBatchMemOpNodeSetParams),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecBatchMemOpNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an allocation node and adds it to a graph\n\n Creates a new allocation node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies` and arguments specified in `nodeParams`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries. A handle\n to the new node will be returned in `phGraphNode`.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Parameters for the node\n\n When [cuGraphAddMemAllocNode](crate::ffi::cuGraphAddMemAllocNode) creates an allocation node, it returns the address of the allocation in\n `nodeParams`.dptr.  The allocation's address remains fixed across instantiations and launches.\n\n If the allocation is freed in the same graph, by creating a free node using [cuGraphAddMemFreeNode](crate::ffi::cuGraphAddMemFreeNode),\n the allocation can be accessed by nodes ordered after the allocation node but before the free node.\n These allocations cannot be freed outside the owning graph, and they can only be freed once in the\n owning graph.\n\n If the allocation is not freed in the same graph, then it can be accessed not only by nodes in the\n graph which are ordered after the allocation node, but also by stream operations ordered after the\n graph's execution but before the allocation is freed.\n\n Allocations which are not freed in the same graph can be freed by:\n - passing the allocation to [cuMemFreeAsync](crate::ffi::cuMemFreeAsync) or [cuMemFree](crate::ffi::cuMemFree);\n - launching a graph with a free node for that allocation; or\n - specifying [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH) during instantiation, which makes\n each launch behave as though it called [cuMemFreeAsync](crate::ffi::cuMemFreeAsync) for every unfreed allocation.\n\n It is not possible to free an allocation in both the owning graph and another graph.  If the allocation\n is freed in the same graph, a free node cannot be added to another graph.  If the allocation is freed\n in another graph, a free node can no longer be added to the owning graph.\n\n The following restrictions apply to graphs which contain allocation and/or memory free nodes:\n - Nodes and edges of the graph cannot be deleted.\n - The graph cannot be used in a child node.\n - Only one instantiation of the graph may exist at any point in time.\n - The graph cannot be cloned.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphAddMemFreeNode](crate::ffi::cuGraphAddMemFreeNode),\n [cuGraphMemAllocNodeGetParams](crate::ffi::cuGraphMemAllocNodeGetParams),\n [cuDeviceGraphMemTrim](crate::ffi::cuDeviceGraphMemTrim),\n [cuDeviceGetGraphMemAttribute](crate::ffi::cuDeviceGetGraphMemAttribute),\n [cuDeviceSetGraphMemAttribute](crate::ffi::cuDeviceSetGraphMemAttribute),\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync),\n [cuMemFreeAsync](crate::ffi::cuMemFreeAsync),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuGraphAddExternalSemaphoresSignalNode](crate::ffi::cuGraphAddExternalSemaphoresSignalNode),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddMemAllocNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a memory alloc node's parameters\n\n Returns the parameters of a memory alloc node `hNode` in `params_out`.\n The `poolProps` and `accessDescs` returned in `params_out`, are owned by the\n node.  This memory remains valid until the node is destroyed.  The returned\n parameters must not be modified.\n#### hNode:\n- Node to get the parameters for\n#### params_out:\n- Pointer to return the parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddMemAllocNode](crate::ffi::cuGraphAddMemAllocNode),\n [cuGraphMemFreeNodeGetParams](crate::ffi::cuGraphMemFreeNodeGetParams)\n"]
    pub fn cuGraphMemAllocNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a memory free node and adds it to a graph\n\n Creates a new memory free node and adds it to `hGraph` with `numDependencies`\n dependencies specified via `dependencies` and arguments specified in `nodeParams`.\n It is possible for `numDependencies` to be 0, in which case the node will be placed\n at the root of the graph. `dependencies` may not have any duplicate entries. A handle\n to the new node will be returned in `phGraphNode`.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### dptr:\n- Address of memory to free\n\n [cuGraphAddMemFreeNode](crate::ffi::cuGraphAddMemFreeNode) will return [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if the user attempts to free:\n - an allocation twice in the same graph.\n - an address that was not returned by an allocation node.\n - an invalid address.\n\n The following restrictions apply to graphs which contain allocation and/or memory free nodes:\n - Nodes and edges of the graph cannot be deleted.\n - The graph cannot be used in a child node.\n - Only one instantiation of the graph may exist at any point in time.\n - The graph cannot be cloned.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphAddMemAllocNode](crate::ffi::cuGraphAddMemAllocNode),\n [cuGraphMemFreeNodeGetParams](crate::ffi::cuGraphMemFreeNodeGetParams),\n [cuDeviceGraphMemTrim](crate::ffi::cuDeviceGraphMemTrim),\n [cuDeviceGetGraphMemAttribute](crate::ffi::cuDeviceGetGraphMemAttribute),\n [cuDeviceSetGraphMemAttribute](crate::ffi::cuDeviceSetGraphMemAttribute),\n [cuMemAllocAsync](crate::ffi::cuMemAllocAsync),\n [cuMemFreeAsync](crate::ffi::cuMemFreeAsync),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphDestroyNode](crate::ffi::cuGraphDestroyNode),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuGraphAddExternalSemaphoresSignalNode](crate::ffi::cuGraphAddExternalSemaphoresSignalNode),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphAddMemFreeNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a memory free node's parameters\n\n Returns the address of a memory free node `hNode` in `dptr_out`.\n#### hNode:\n- Node to get the parameters for\n#### dptr_out:\n- Pointer to return the device address\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddMemFreeNode](crate::ffi::cuGraphAddMemFreeNode),\n [cuGraphMemAllocNodeGetParams](crate::ffi::cuGraphMemAllocNodeGetParams)\n"]
    pub fn cuGraphMemFreeNodeGetParams(hNode: CUgraphNode, dptr_out: *mut CUdeviceptr) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Free unused memory that was cached on the specified device for use with graphs back to the OS.\n\n Blocks which are not in use by a graph that is either currently executing or scheduled to execute are\n freed back to the operating system.\n#### device:\n- The device for which cached memory should be freed.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n\n ### See also:\n\n [cuGraphAddMemAllocNode](crate::ffi::cuGraphAddMemAllocNode),\n [cuGraphAddMemFreeNode](crate::ffi::cuGraphAddMemFreeNode),\n [cuDeviceSetGraphMemAttribute](crate::ffi::cuDeviceSetGraphMemAttribute),\n [cuDeviceGetGraphMemAttribute](crate::ffi::cuDeviceGetGraphMemAttribute)\n"]
    pub fn cuDeviceGraphMemTrim(device: CUdevice) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query asynchronous allocation attributes related to graphs\n\n Valid attributes are:\n\n - [CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT](crate::ffi::CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT): Amount of memory, in bytes, currently associated with graphs\n - [CU_GRAPH_MEM_ATTR_USED_MEM_HIGH](crate::ffi::CU_GRAPH_MEM_ATTR_USED_MEM_HIGH): High watermark of memory, in bytes, associated with graphs since the\n   last time it was reset.  High watermark can only be reset to zero.\n - [CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT](crate::ffi::CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT): Amount of memory, in bytes, currently allocated for use by\n   the CUDA graphs asynchronous allocator.\n - [CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH](crate::ffi::CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH): High watermark of memory, in bytes, currently allocated for use by\n   the CUDA graphs asynchronous allocator.\n#### device:\n- Specifies the scope of the query\n#### attr:\n- attribute to get\n#### value:\n- retrieved value\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n\n ### See also:\n\n [cuDeviceSetGraphMemAttribute](crate::ffi::cuDeviceSetGraphMemAttribute),\n [cuGraphAddMemAllocNode](crate::ffi::cuGraphAddMemAllocNode),\n [cuGraphAddMemFreeNode](crate::ffi::cuGraphAddMemFreeNode)\n"]
    pub fn cuDeviceGetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Set asynchronous allocation attributes related to graphs\n\n Valid attributes are:\n\n - [CU_GRAPH_MEM_ATTR_USED_MEM_HIGH](crate::ffi::CU_GRAPH_MEM_ATTR_USED_MEM_HIGH): High watermark of memory, in bytes, associated with graphs since the\n   last time it was reset.  High watermark can only be reset to zero.\n - [CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH](crate::ffi::CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH): High watermark of memory, in bytes, currently allocated for use by\n   the CUDA graphs asynchronous allocator.\n#### device:\n- Specifies the scope of the query\n#### attr:\n- attribute to get\n#### value:\n- pointer to value to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n\n ### See also:\n\n [cuDeviceGetGraphMemAttribute](crate::ffi::cuDeviceGetGraphMemAttribute),\n [cuGraphAddMemAllocNode](crate::ffi::cuGraphAddMemAllocNode),\n [cuGraphAddMemFreeNode](crate::ffi::cuGraphAddMemFreeNode)\n"]
    pub fn cuDeviceSetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Clones a graph\n\n This function creates a copy of `originalGraph` and returns it in `phGraphClone`.\n All parameters are copied into the cloned graph. The original graph may be modified\n after this call without affecting the clone.\n\n Child graph nodes in the original graph are recursively copied into the clone.\n#### phGraphClone:\n- Returns newly created cloned graph\n#### originalGraph:\n- Graph to clone\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphNodeFindInClone](crate::ffi::cuGraphNodeFindInClone)\n"]
    pub fn cuGraphClone(phGraphClone: *mut CUgraph, originalGraph: CUgraph) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Finds a cloned version of a node\n\n This function returns the node in `hClonedGraph` corresponding to `hOriginalNode`\n in the original graph.\n\n `hClonedGraph` must have been cloned from `hOriginalGraph` via [cuGraphClone](crate::ffi::cuGraphClone).\n `hOriginalNode` must have been in `hOriginalGraph` at the time of the call to\n [cuGraphClone](crate::ffi::cuGraphClone), and the corresponding cloned node in `hClonedGraph` must not have\n been removed. The cloned node is then returned via `phClonedNode`.\n#### phNode:\n- Returns handle to the cloned node\n#### hOriginalNode:\n- Handle to the original node\n#### hClonedGraph:\n- Cloned graph to query\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphClone](crate::ffi::cuGraphClone)\n"]
    pub fn cuGraphNodeFindInClone(
        phNode: *mut CUgraphNode,
        hOriginalNode: CUgraphNode,
        hClonedGraph: CUgraph,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a node's type\n\n Returns the node type of `hNode` in `type`.\n#### hNode:\n- Node to query\n#### type:\n- Pointer to return the node type\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphChildGraphNodeGetGraph](crate::ffi::cuGraphChildGraphNodeGetGraph),\n [cuGraphKernelNodeGetParams](crate::ffi::cuGraphKernelNodeGetParams),\n [cuGraphKernelNodeSetParams](crate::ffi::cuGraphKernelNodeSetParams),\n [cuGraphHostNodeGetParams](crate::ffi::cuGraphHostNodeGetParams),\n [cuGraphHostNodeSetParams](crate::ffi::cuGraphHostNodeSetParams),\n [cuGraphMemcpyNodeGetParams](crate::ffi::cuGraphMemcpyNodeGetParams),\n [cuGraphMemcpyNodeSetParams](crate::ffi::cuGraphMemcpyNodeSetParams),\n [cuGraphMemsetNodeGetParams](crate::ffi::cuGraphMemsetNodeGetParams),\n [cuGraphMemsetNodeSetParams](crate::ffi::cuGraphMemsetNodeSetParams)\n"]
    pub fn cuGraphNodeGetType(hNode: CUgraphNode, type_: *mut CUgraphNodeType) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a graph's nodes\n\n Returns a list of `hGraph`'s nodes. `nodes` may be NULL, in which case this\n function will return the number of nodes in `numNodes`. Otherwise,\n `numNodes` entries will be filled in. If `numNodes` is higher than the actual\n number of nodes, the remaining entries in `nodes` will be set to NULL, and the\n number of nodes actually obtained will be returned in `numNodes`.\n#### hGraph:\n- Graph to query\n#### nodes:\n- Pointer to return the nodes\n#### numNodes:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphNodeGetType](crate::ffi::cuGraphNodeGetType),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphGetNodes(
        hGraph: CUgraph,
        nodes: *mut CUgraphNode,
        numNodes: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a graph's root nodes\n\n Returns a list of `hGraph`'s root nodes. `rootNodes` may be NULL, in which case this\n function will return the number of root nodes in `numRootNodes`. Otherwise,\n `numRootNodes` entries will be filled in. If `numRootNodes` is higher than the actual\n number of root nodes, the remaining entries in `rootNodes` will be set to NULL, and the\n number of nodes actually obtained will be returned in `numRootNodes`.\n#### hGraph:\n- Graph to query\n#### rootNodes:\n- Pointer to return the root nodes\n#### numRootNodes:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphNodeGetType](crate::ffi::cuGraphNodeGetType),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphGetRootNodes(
        hGraph: CUgraph,
        rootNodes: *mut CUgraphNode,
        numRootNodes: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a graph's dependency edges\n\n Returns a list of `hGraph`'s dependency edges. Edges are returned via corresponding\n indices in `from` and `to`; that is, the node in `to`[i] has a dependency on the\n node in `from`[i]. `from` and `to` may both be NULL, in which\n case this function only returns the number of edges in `numEdges`. Otherwise,\n `numEdges` entries will be filled in. If `numEdges` is higher than the actual\n number of edges, the remaining entries in `from` and `to` will be set to NULL, and\n the number of edges actually returned will be written to `numEdges`.\n#### hGraph:\n- Graph to get the edges from\n#### from:\n- Location to return edge endpoints\n#### to:\n- Location to return edge endpoints\n#### numEdges:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphGetEdges(
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        numEdges: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a graph's dependency edges (12.3+)\n\n Returns a list of `hGraph`'s dependency edges. Edges are returned via corresponding\n indices in `from`, `to` and `edgeData`; that is, the node in `to`[i] has a\n dependency on the node in `from`[i] with data `edgeData`[i]. `from` and `to` may\n both be NULL, in which case this function only returns the number of edges in\n `numEdges`. Otherwise, `numEdges` entries will be filled in. If `numEdges` is higher\n than the actual number of edges, the remaining entries in `from` and `to` will be\n set to NULL, and the number of edges actually returned will be written to `numEdges`.\n `edgeData` may alone be NULL, in which case the edges must all have default (zeroed)\n edge data. Attempting a lossy query via NULL `edgeData` will result in\n [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY). If `edgeData` is non-NULL then `from` and `to` must be\n as well.\n#### hGraph:\n- Graph to get the edges from\n#### from:\n- Location to return edge endpoints\n#### to:\n- Location to return edge endpoints\n#### edgeData:\n- Optional location to return edge data\n#### numEdges:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphGetEdges_v2(
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        edgeData: *mut CUgraphEdgeData,
        numEdges: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a node's dependencies\n\n Returns a list of `node`'s dependencies. `dependencies` may be NULL, in which case this\n function will return the number of dependencies in `numDependencies`. Otherwise,\n `numDependencies` entries will be filled in. If `numDependencies` is higher than the actual\n number of dependencies, the remaining entries in `dependencies` will be set to NULL, and the\n number of nodes actually obtained will be returned in `numDependencies`.\n#### hNode:\n- Node to query\n#### dependencies:\n- Pointer to return the dependencies\n#### numDependencies:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes),\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies)\n"]
    pub fn cuGraphNodeGetDependencies(
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        numDependencies: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a node's dependencies (12.3+)\n\n Returns a list of `node`'s dependencies. `dependencies` may be NULL, in which case this\n function will return the number of dependencies in `numDependencies`. Otherwise,\n `numDependencies` entries will be filled in. If `numDependencies` is higher than the actual\n number of dependencies, the remaining entries in `dependencies` will be set to NULL, and the\n number of nodes actually obtained will be returned in `numDependencies`.\n\n Note that if an edge has non-zero (non-default) edge data and `edgeData` is NULL,\n this API will return [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY). If `edgeData` is non-NULL, then\n `dependencies` must be as well.\n#### hNode:\n- Node to query\n#### dependencies:\n- Pointer to return the dependencies\n#### edgeData:\n- Optional array to return edge data for each dependency\n#### numDependencies:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes),\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies)\n"]
    pub fn cuGraphNodeGetDependencies_v2(
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        edgeData: *mut CUgraphEdgeData,
        numDependencies: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a node's dependent nodes\n\n Returns a list of `node`'s dependent nodes. `dependentNodes` may be NULL, in which\n case this function will return the number of dependent nodes in `numDependentNodes`.\n Otherwise, `numDependentNodes` entries will be filled in. If `numDependentNodes` is\n higher than the actual number of dependent nodes, the remaining entries in\n `dependentNodes` will be set to NULL, and the number of nodes actually obtained will\n be returned in `numDependentNodes`.\n#### hNode:\n- Node to query\n#### dependentNodes:\n- Pointer to return the dependent nodes\n#### numDependentNodes:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies)\n"]
    pub fn cuGraphNodeGetDependentNodes(
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        numDependentNodes: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a node's dependent nodes (12.3+)\n\n Returns a list of `node`'s dependent nodes. `dependentNodes` may be NULL, in which\n case this function will return the number of dependent nodes in `numDependentNodes`.\n Otherwise, `numDependentNodes` entries will be filled in. If `numDependentNodes` is\n higher than the actual number of dependent nodes, the remaining entries in\n `dependentNodes` will be set to NULL, and the number of nodes actually obtained will\n be returned in `numDependentNodes`.\n\n Note that if an edge has non-zero (non-default) edge data and `edgeData` is NULL,\n this API will return [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY).  If `edgeData` is non-NULL, then\n `dependentNodes` must be as well.\n#### hNode:\n- Node to query\n#### dependentNodes:\n- Pointer to return the dependent nodes\n#### edgeData:\n- Optional pointer to return edge data for dependent nodes\n#### numDependentNodes:\n- See description\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_LOSSY_QUERY](crate::ffi::CUDA_ERROR_LOSSY_QUERY),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphGetNodes](crate::ffi::cuGraphGetNodes),\n [cuGraphGetRootNodes](crate::ffi::cuGraphGetRootNodes),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies)\n"]
    pub fn cuGraphNodeGetDependentNodes_v2(
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        edgeData: *mut CUgraphEdgeData,
        numDependentNodes: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds dependency edges to a graph\n\n The number of dependencies to be added is defined by `numDependencies`\n Elements in `from` and `to` at corresponding indices define a dependency.\n Each node in `from` and `to` must belong to `hGraph`.\n\n If `numDependencies` is 0, elements in `from` and `to` will be ignored.\n Specifying an existing dependency will return an error.\n#### hGraph:\n- Graph to which dependencies are added\n#### from:\n- Array of nodes that provide the dependencies\n#### to:\n- Array of dependent nodes\n#### numDependencies:\n- Number of dependencies to be added\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphAddDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds dependency edges to a graph (12.3+)\n\n The number of dependencies to be added is defined by `numDependencies`\n Elements in `from` and `to` at corresponding indices define a dependency.\n Each node in `from` and `to` must belong to `hGraph`.\n\n If `numDependencies` is 0, elements in `from` and `to` will be ignored.\n Specifying an existing dependency will return an error.\n#### hGraph:\n- Graph to which dependencies are added\n#### from:\n- Array of nodes that provide the dependencies\n#### to:\n- Array of dependent nodes\n#### edgeData:\n- Optional array of edge data. If NULL, default (zeroed) edge data is assumed.\n#### numDependencies:\n- Number of dependencies to be added\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphRemoveDependencies](crate::ffi::cuGraphRemoveDependencies),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphAddDependencies_v2(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        edgeData: *const CUgraphEdgeData,
        numDependencies: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Removes dependency edges from a graph\n\n The number of `dependencies` to be removed is defined by `numDependencies`.\n Elements in `from` and `to` at corresponding indices define a dependency.\n Each node in `from` and `to` must belong to `hGraph`.\n\n If `numDependencies` is 0, elements in `from` and `to` will be ignored.\n Specifying a non-existing dependency will return an error.\n\n Dependencies cannot be removed from graphs which contain allocation or free nodes.\n Any attempt to do so will return an error.\n#### hGraph:\n- Graph from which to remove dependencies\n#### from:\n- Array of nodes that provide the dependencies\n#### to:\n- Array of dependent nodes\n#### numDependencies:\n- Number of dependencies to be removed\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphRemoveDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Removes dependency edges from a graph (12.3+)\n\n The number of `dependencies` to be removed is defined by `numDependencies`.\n Elements in `from` and `to` at corresponding indices define a dependency.\n Each node in `from` and `to` must belong to `hGraph`.\n\n If `numDependencies` is 0, elements in `from` and `to` will be ignored.\n Specifying an edge that does not exist in the graph, with data matching\n `edgeData`, results in an error. `edgeData` is nullable, which is equivalent\n to passing default (zeroed) data for each edge.\n\n Dependencies cannot be removed from graphs which contain allocation or free nodes.\n Any attempt to do so will return an error.\n#### hGraph:\n- Graph from which to remove dependencies\n#### from:\n- Array of nodes that provide the dependencies\n#### to:\n- Array of dependent nodes\n#### edgeData:\n- Optional array of edge data. If NULL, edge data is assumed to\n                   be default (zeroed).\n#### numDependencies:\n- Number of dependencies to be removed\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddDependencies](crate::ffi::cuGraphAddDependencies),\n [cuGraphGetEdges](crate::ffi::cuGraphGetEdges),\n [cuGraphNodeGetDependencies](crate::ffi::cuGraphNodeGetDependencies),\n [cuGraphNodeGetDependentNodes](crate::ffi::cuGraphNodeGetDependentNodes)\n"]
    pub fn cuGraphRemoveDependencies_v2(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        edgeData: *const CUgraphEdgeData,
        numDependencies: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Remove a node from the graph\n\n Removes `hNode` from its graph. This operation also severs any dependencies of other nodes\n on `hNode` and vice versa.\n\n Nodes which belong to a graph which contains allocation or free nodes cannot be destroyed.\n Any attempt to do so will return an error.\n#### hNode:\n- Node to remove\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphAddEmptyNode](crate::ffi::cuGraphAddEmptyNode),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode)\n"]
    pub fn cuGraphDestroyNode(hNode: CUgraphNode) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an executable graph from a graph\n\n Instantiates `hGraph` as an executable graph. The graph is validated for any\n structural constraints or intra-node constraints which were not previously\n validated. If instantiation is successful, a handle to the instantiated graph\n is returned in `phGraphExec`.\n\n The `flags` parameter controls the behavior of instantiation and subsequent\n graph launches.  Valid flags are:\n\n - [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH), which configures a\n graph containing memory allocation nodes to automatically free any\n unfreed memory allocations before the graph is relaunched.\n\n - [CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH), which configures the graph for launch\n from the device. If this flag is passed, the executable graph handle returned can be\n used to launch the graph from both the host and device. This flag can only be used\n on platforms which support unified addressing. This flag cannot be used in\n conjunction with [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH).\n\n - [CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY), which causes the graph\n to use the priorities from the per-node attributes rather than the priority\n of the launch stream during execution. Note that priorities are only available\n on kernel nodes, and are copied from stream priority during stream capture.\n\n If `hGraph` contains any allocation or free nodes, there can be at most one\n executable graph in existence for that graph at a time. An attempt to instantiate\n a second executable graph before destroying the first with [cuGraphExecDestroy](crate::ffi::cuGraphExecDestroy)\n will result in an error.\n The same also applies if `hGraph` contains any device-updatable kernel nodes.\n\n If `hGraph` contains kernels which call device-side cudaGraphLaunch() from multiple\n contexts, this will result in an error.\n\n Graphs instantiated for launch on the device have additional restrictions which do not\n apply to host graphs:\n\n - The graph's nodes must reside on a single context.\n - The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.\n - The graph cannot be empty and must contain at least one kernel, memcpy, or memset node.\n   Operation-specific restrictions are outlined below.\n - Kernel nodes:\n   - Use of CUDA Dynamic Parallelism is not permitted.\n   - Cooperative launches are permitted as long as MPS is not in use.\n - Memcpy nodes:\n   - Only copies involving device memory and/or pinned device-mapped host memory are permitted.\n   - Copies involving CUDA arrays are not permitted.\n   - Both operands must be accessible from the current context, and the current context must\n     match the context of other nodes in the graph.\n#### phGraphExec:\n- Returns instantiated graph\n#### hGraph:\n- Graph to instantiate\n#### flags:\n- Flags to control instantiation.  See [CUgraphInstantiate_flags](crate::ffi::CUgraphInstantiate_flags).\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate),\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphUpload](crate::ffi::cuGraphUpload),\n [cuGraphLaunch](crate::ffi::cuGraphLaunch),\n [cuGraphExecDestroy](crate::ffi::cuGraphExecDestroy)\n"]
    pub fn cuGraphInstantiateWithFlags(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        flags: ::std::ffi::c_ulonglong,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates an executable graph from a graph\n\n Instantiates `hGraph` as an executable graph according to the `instantiateParams` structure.\n The graph is validated for any structural constraints or intra-node constraints\n which were not previously validated. If instantiation is successful, a handle to\n the instantiated graph is returned in `phGraphExec`.\n\n `instantiateParams` controls the behavior of instantiation and subsequent\n graph launches, as well as returning more detailed information in the event of an error.\n [CUDA_GRAPH_INSTANTIATE_PARAMS](crate::ffi::CUDA_GRAPH_INSTANTIATE_PARAMS) is defined as:\n\n \\code\ntypedef struct {\ncuuint64_t flags;\nCUstream hUploadStream;\nCUgraphNode hErrNode_out;\nCUgraphInstantiateResult result_out;\n} CUDA_GRAPH_INSTANTIATE_PARAMS;\n \\endcode\n\n The `flags` field controls the behavior of instantiation and subsequent\n graph launches. Valid flags are:\n\n - [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH), which configures a\n graph containing memory allocation nodes to automatically free any\n unfreed memory allocations before the graph is relaunched.\n\n - [CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD), which will perform an upload of the graph\n into `hUploadStream` once the graph has been instantiated.\n\n - [CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH), which configures the graph for launch\n from the device. If this flag is passed, the executable graph handle returned can be\n used to launch the graph from both the host and device. This flag can only be used\n on platforms which support unified addressing. This flag cannot be used in\n conjunction with [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH).\n\n - [CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY), which causes the graph\n to use the priorities from the per-node attributes rather than the priority\n of the launch stream during execution. Note that priorities are only available\n on kernel nodes, and are copied from stream priority during stream capture.\n\n If `hGraph` contains any allocation or free nodes, there can be at most one\n executable graph in existence for that graph at a time. An attempt to instantiate a\n second executable graph before destroying the first with [cuGraphExecDestroy](crate::ffi::cuGraphExecDestroy) will\n result in an error.\n The same also applies if `hGraph` contains any device-updatable kernel nodes.\n\n If `hGraph` contains kernels which call device-side cudaGraphLaunch() from multiple\n contexts, this will result in an error.\n\n Graphs instantiated for launch on the device have additional restrictions which do not\n apply to host graphs:\n\n - The graph's nodes must reside on a single context.\n - The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.\n - The graph cannot be empty and must contain at least one kernel, memcpy, or memset node.\n   Operation-specific restrictions are outlined below.\n - Kernel nodes:\n   - Use of CUDA Dynamic Parallelism is not permitted.\n   - Cooperative launches are permitted as long as MPS is not in use.\n - Memcpy nodes:\n   - Only copies involving device memory and/or pinned device-mapped host memory are permitted.\n   - Copies involving CUDA arrays are not permitted.\n   - Both operands must be accessible from the current context, and the current context must\n     match the context of other nodes in the graph.\n\n In the event of an error, the `result_out` and `hErrNode_out` fields will contain more\n information about the nature of the error. Possible error reporting includes:\n\n - [CUDA_GRAPH_INSTANTIATE_ERROR](crate::ffi::CUDA_GRAPH_INSTANTIATE_ERROR), if passed an invalid value or if an unexpected error occurred\n   which is described by the return value of the function. `hErrNode_out` will be set to NULL.\n - [CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE](crate::ffi::CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE), if the graph structure is invalid. `hErrNode_out`\n   will be set to one of the offending nodes.\n - [CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED](crate::ffi::CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED), if the graph is instantiated for device\n   launch but contains a node of an unsupported node type, or a node which performs unsupported\n   operations, such as use of CUDA dynamic parallelism within a kernel node. `hErrNode_out` will\n   be set to this node.\n - [CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED](crate::ffi::CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED), if the graph is instantiated for device\n   launch but a nodes context differs from that of another node. This error can also be returned\n   if a graph is not instantiated for device launch and it contains kernels which call device-side\n   cudaGraphLaunch() from multiple contexts. `hErrNode_out` will be set to this node.\n\n If instantiation is successful, `result_out` will be set to [CUDA_GRAPH_INSTANTIATE_SUCCESS](crate::ffi::CUDA_GRAPH_INSTANTIATE_SUCCESS),\n and `hErrNode_out` will be set to NULL.\n#### phGraphExec:\n- Returns instantiated graph\n#### hGraph:\n- Graph to instantiate\n#### instantiateParams:\n- Instantiation parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate),\n [cuGraphExecDestroy](crate::ffi::cuGraphExecDestroy)\n"]
    pub fn cuGraphInstantiateWithParams(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        instantiateParams: *mut CUDA_GRAPH_INSTANTIATE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query the instantiation flags of an executable graph\n\n Returns the flags that were passed to instantiation for the given executable graph.\n [CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD) will not be returned by this API as it does\n not affect the resulting executable graph.\n#### hGraphExec:\n- The executable graph to query\n#### flags:\n- Returns the instantiation flags\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate),\n [cuGraphInstantiateWithParams](crate::ffi::cuGraphInstantiateWithParams)\n"]
    pub fn cuGraphExecGetFlags(hGraphExec: CUgraphExec, flags: *mut cuuint64_t) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameters for a kernel node in the given graphExec\n\n Sets the parameters of a kernel node in an executable graph `hGraphExec`.\n The node is identified by the corresponding node `hNode` in the\n non-executable graph, from which the executable graph was instantiated.\n\n `hNode` must not have been removed from the original graph. All `nodeParams`\n fields may change, but the following restrictions apply to `func` updates:\n\n   - The owning context of the function cannot change.\n   - A node whose function originally did not use CUDA dynamic parallelism cannot be updated\n     to a function which uses CDP\n   - A node whose function originally did not make device-side update calls cannot be updated\n     to a function which makes device-side update calls.\n   - If `hGraphExec` was not instantiated for device launch, a node whose function originally\n     did not use device-side cudaGraphLaunch() cannot be updated to a function which uses\n     device-side cudaGraphLaunch() unless the node resides on the same context as nodes which\n     contained such calls at instantiate-time. If no such calls were present at instantiation,\n     these updates cannot be performed at all.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n\n If `hNode` is a device-updatable kernel node, the next upload/launch of `hGraphExec`\n will overwrite any previous device-side updates. Additionally, applying host updates to a\n device-updatable kernel node while it is being updated from the device will result in\n undefined behavior.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- kernel node from the graph from which graphExec was instantiated\n#### nodeParams:\n- Updated Parameters to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddKernelNode](crate::ffi::cuGraphAddKernelNode),\n [cuGraphKernelNodeSetParams](crate::ffi::cuGraphKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecKernelNodeSetParams_v2(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameters for a memcpy node in the given graphExec.\n\n Updates the work represented by `hNode` in `hGraphExec` as though `hNode` had\n contained `copyParams` at instantiation.  hNode must remain in the graph which was\n used to instantiate `hGraphExec`.  Changed edges to and from hNode are ignored.\n\n The source and destination memory in `copyParams` must be allocated from the same\n contexts as the original source and destination memory.  Both the instantiation-time\n memory operands and the memory operands in `copyParams` must be 1-dimensional.\n Zero-length operations are not supported.\n\n The modifications only affect future launches of `hGraphExec`.  Already enqueued\n or running launches of `hGraphExec` are not affected by this call.  hNode is also\n not modified by this call.\n\n Returns CUDA_ERROR_INVALID_VALUE if the memory operands' mappings changed or\n either the original or new memory operands are multidimensional.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- Memcpy node from the graph which was used to instantiate graphExec\n#### copyParams:\n- The updated parameters to set\n#### ctx:\n- Context on which to run the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddMemcpyNode](crate::ffi::cuGraphAddMemcpyNode),\n [cuGraphMemcpyNodeSetParams](crate::ffi::cuGraphMemcpyNodeSetParams),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecMemcpyNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameters for a memset node in the given graphExec.\n\n Updates the work represented by `hNode` in `hGraphExec` as though `hNode` had\n contained `memsetParams` at instantiation.  hNode must remain in the graph which was\n used to instantiate `hGraphExec`.  Changed edges to and from hNode are ignored.\n\n Zero sized operations are not supported.\n\n The new destination pointer in memsetParams must be to the same kind of allocation\n as the original destination pointer and have the same context association and device mapping\n as the original destination pointer.\n\n Both the value and pointer address may be updated.\n Changing other aspects of the memset (width, height, element size or pitch) may cause the update to be rejected.\n Specifically, for 2d memsets, all dimension changes are rejected.\n For 1d memsets, changes in height are explicitly rejected and other changes are oportunistically allowed\n if the resulting work maps onto the work resources already allocated for the node.\n\n The modifications only affect future launches of `hGraphExec`.  Already enqueued\n or running launches of `hGraphExec` are not affected by this call.  hNode is also\n not modified by this call.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- Memset node from the graph which was used to instantiate graphExec\n#### memsetParams:\n- The updated parameters to set\n#### ctx:\n- Context on which to run the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddMemsetNode](crate::ffi::cuGraphAddMemsetNode),\n [cuGraphMemsetNodeSetParams](crate::ffi::cuGraphMemsetNodeSetParams),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecMemsetNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameters for a host node in the given graphExec.\n\n Updates the work represented by `hNode` in `hGraphExec` as though `hNode` had\n contained `nodeParams` at instantiation.  hNode must remain in the graph which was\n used to instantiate `hGraphExec`.  Changed edges to and from hNode are ignored.\n\n The modifications only affect future launches of `hGraphExec`.  Already enqueued\n or running launches of `hGraphExec` are not affected by this call.  hNode is also\n not modified by this call.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- Host node from the graph which was used to instantiate graphExec\n#### nodeParams:\n- The updated parameters to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddHostNode](crate::ffi::cuGraphAddHostNode),\n [cuGraphHostNodeSetParams](crate::ffi::cuGraphHostNodeSetParams),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecHostNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Updates node parameters in the child graph node in the given graphExec.\n\n Updates the work represented by `hNode` in `hGraphExec` as though the nodes contained\n in `hNode`'s graph had the parameters contained in `childGraph`'s nodes at instantiation.\n `hNode` must remain in the graph which was used to instantiate `hGraphExec`.\n Changed edges to and from `hNode` are ignored.\n\n The modifications only affect future launches of `hGraphExec`.  Already enqueued\n or running launches of `hGraphExec` are not affected by this call.  `hNode` is also\n not modified by this call.\n\n The topology of `childGraph`, as well as the node insertion order,  must match that\n of the graph contained in `hNode`.  See [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate)() for a list of restrictions\n on what can be updated in an instantiated graph.  The update is recursive, so child graph\n nodes contained within the top level child graph will also be updated.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- Host node from the graph which was used to instantiate graphExec\n#### childGraph:\n- The graph supplying the updated parameters\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddChildGraphNode](crate::ffi::cuGraphAddChildGraphNode),\n [cuGraphChildGraphNodeGetGraph](crate::ffi::cuGraphChildGraphNodeGetGraph),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecChildGraphNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        childGraph: CUgraph,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the event for an event record node in the given graphExec\n\n Sets the event of an event record node in an executable graph `hGraphExec`.\n The node is identified by the corresponding node `hNode` in the\n non-executable graph, from which the executable graph was instantiated.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- event record node from the graph from which graphExec was instantiated\n#### event:\n- Updated event to use\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddEventRecordNode](crate::ffi::cuGraphAddEventRecordNode),\n [cuGraphEventRecordNodeGetEvent](crate::ffi::cuGraphEventRecordNodeGetEvent),\n [cuGraphEventWaitNodeSetEvent](crate::ffi::cuGraphEventWaitNodeSetEvent),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecEventRecordNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the event for an event wait node in the given graphExec\n\n Sets the event of an event wait node in an executable graph `hGraphExec`.\n The node is identified by the corresponding node `hNode` in the\n non-executable graph, from which the executable graph was instantiated.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- event wait node from the graph from which graphExec was instantiated\n#### event:\n- Updated event to use\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddEventWaitNode](crate::ffi::cuGraphAddEventWaitNode),\n [cuGraphEventWaitNodeGetEvent](crate::ffi::cuGraphEventWaitNodeGetEvent),\n [cuGraphEventRecordNodeSetEvent](crate::ffi::cuGraphEventRecordNodeSetEvent),\n [cuEventRecordWithFlags](crate::ffi::cuEventRecordWithFlags),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecEventWaitNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameters for an external semaphore signal node in the given graphExec\n\n Sets the parameters of an external semaphore signal node in an executable graph `hGraphExec`.\n The node is identified by the corresponding node `hNode` in the\n non-executable graph, from which the executable graph was instantiated.\n\n `hNode` must not have been removed from the original graph.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n\n Changing `nodeParams`->numExtSems is not supported.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- semaphore signal node from the graph from which graphExec was instantiated\n#### nodeParams:\n- Updated Parameters to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddExternalSemaphoresSignalNode](crate::ffi::cuGraphAddExternalSemaphoresSignalNode),\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresWaitNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresWaitNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the parameters for an external semaphore wait node in the given graphExec\n\n Sets the parameters of an external semaphore wait node in an executable graph `hGraphExec`.\n The node is identified by the corresponding node `hNode` in the\n non-executable graph, from which the executable graph was instantiated.\n\n `hNode` must not have been removed from the original graph.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n\n Changing `nodeParams`->numExtSems is not supported.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- semaphore wait node from the graph from which graphExec was instantiated\n#### nodeParams:\n- Updated Parameters to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams),\n [cuGraphAddExternalSemaphoresWaitNode](crate::ffi::cuGraphAddExternalSemaphoresWaitNode),\n [cuImportExternalSemaphore](crate::ffi::cuImportExternalSemaphore),\n [cuSignalExternalSemaphoresAsync](crate::ffi::cuSignalExternalSemaphoresAsync),\n [cuWaitExternalSemaphoresAsync](crate::ffi::cuWaitExternalSemaphoresAsync),\n [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams),\n [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams),\n [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams),\n [cuGraphExecHostNodeSetParams](crate::ffi::cuGraphExecHostNodeSetParams),\n [cuGraphExecChildGraphNodeSetParams](crate::ffi::cuGraphExecChildGraphNodeSetParams),\n [cuGraphExecEventRecordNodeSetEvent](crate::ffi::cuGraphExecEventRecordNodeSetEvent),\n [cuGraphExecEventWaitNodeSetEvent](crate::ffi::cuGraphExecEventWaitNodeSetEvent),\n [cuGraphExecExternalSemaphoresSignalNodeSetParams](crate::ffi::cuGraphExecExternalSemaphoresSignalNodeSetParams),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Enables or disables the specified node in the given graphExec\n\n Sets `hNode` to be either enabled or disabled. Disabled nodes are functionally equivalent\n to empty nodes until they are reenabled. Existing node parameters are not affected by\n disabling/enabling the node.\n\n The node is identified by the corresponding node `hNode` in the non-executable\n graph, from which the executable graph was instantiated.\n\n `hNode` must not have been removed from the original graph.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n\n If `hNode` is a device-updatable kernel node, the next upload/launch of `hGraphExec`\n will overwrite any previous device-side updates. Additionally, applying host updates to a\n device-updatable kernel node while it is being updated from the device will result in\n undefined behavior.\n\n### Note:\n ### Note:\nCurrently only kernel, memset and memcpy nodes are supported.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- Node from the graph from which graphExec was instantiated\n#### isEnabled:\n- Node is enabled if != 0, otherwise the node is disabled\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeGetEnabled](crate::ffi::cuGraphNodeGetEnabled),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n [cuGraphLaunch](crate::ffi::cuGraphLaunch)\n"]
    pub fn cuGraphNodeSetEnabled(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query whether a node in the given graphExec is enabled\n\n Sets isEnabled to 1 if `hNode` is enabled, or 0 if `hNode` is disabled.\n\n The node is identified by the corresponding node `hNode` in the non-executable\n graph, from which the executable graph was instantiated.\n\n `hNode` must not have been removed from the original graph.\n\n### Note:\n ### Note:\nCurrently only kernel, memset and memcpy nodes are supported.\n ### Note:\nThis function will not reflect device-side updates for device-updatable kernel nodes.\n#### hGraphExec:\n- The executable graph in which to set the specified node\n#### hNode:\n- Node from the graph from which graphExec was instantiated\n#### isEnabled:\n- Location to return the enabled status of the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphNodeSetEnabled](crate::ffi::cuGraphNodeSetEnabled),\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n [cuGraphLaunch](crate::ffi::cuGraphLaunch)\n"]
    pub fn cuGraphNodeGetEnabled(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: *mut ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Uploads an executable graph in a stream\n\n Uploads `hGraphExec` to the device in `hStream` without executing it. Uploads of\n the same `hGraphExec` will be serialized. Each upload is ordered behind both any\n previous work in `hStream` and any previous launches of `hGraphExec`.\n Uses memory cached by `stream` to back the allocations owned by `hGraphExec`.\n#### hGraphExec:\n- Executable graph to upload\n#### hStream:\n- Stream in which to upload the graph\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate),\n [cuGraphLaunch](crate::ffi::cuGraphLaunch),\n [cuGraphExecDestroy](crate::ffi::cuGraphExecDestroy)\n"]
    pub fn cuGraphUpload(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Launches an executable graph in a stream\n\n Executes `hGraphExec` in `hStream`. Only one instance of `hGraphExec` may be executing\n at a time. Each launch is ordered behind both any previous work in `hStream`\n and any previous launches of `hGraphExec`. To execute a graph concurrently, it must be\n instantiated multiple times into multiple executable graphs.\n\n If any allocations created by `hGraphExec` remain unfreed (from a previous launch) and\n `hGraphExec` was not instantiated with [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](crate::ffi::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH),\n the launch will fail with [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE).\n#### hGraphExec:\n- Executable graph to launch\n#### hStream:\n- Stream in which to launch the graph\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate),\n [cuGraphUpload](crate::ffi::cuGraphUpload),\n [cuGraphExecDestroy](crate::ffi::cuGraphExecDestroy)\n"]
    pub fn cuGraphLaunch(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys an executable graph\n\n Destroys the executable graph specified by `hGraphExec`, as well\n as all of its executable nodes. If the executable graph is\n in-flight, it will not be terminated, but rather freed\n asynchronously on completion.\n#### hGraphExec:\n- Executable graph to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate),\n [cuGraphUpload](crate::ffi::cuGraphUpload),\n [cuGraphLaunch](crate::ffi::cuGraphLaunch)\n"]
    pub fn cuGraphExecDestroy(hGraphExec: CUgraphExec) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a graph\n\n Destroys the graph specified by `hGraph`, as well as all of its nodes.\n#### hGraph:\n- Graph to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphCreate](crate::ffi::cuGraphCreate)\n"]
    pub fn cuGraphDestroy(hGraph: CUgraph) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Check whether an executable graph can be updated with a graph and perform the update if possible\n\n Updates the node parameters in the instantiated graph specified by `hGraphExec` with the\n node parameters in a topologically identical graph specified by `hGraph`.\n\n Limitations:\n\n - Kernel nodes:\n   - The owning context of the function cannot change.\n   - A node whose function originally did not use CUDA dynamic parallelism cannot be updated\n     to a function which uses CDP.\n   - A node whose function originally did not make device-side update calls cannot be updated\n     to a function which makes device-side update calls.\n   - A cooperative node cannot be updated to a non-cooperative node, and vice-versa.\n   - If the graph was instantiated with CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY, the\n     priority attribute cannot change. Equality is checked on the originally requested\n     priority values, before they are clamped to the device's supported range.\n   - If `hGraphExec` was not instantiated for device launch, a node whose function originally\n     did not use device-side cudaGraphLaunch() cannot be updated to a function which uses\n     device-side cudaGraphLaunch() unless the node resides on the same context as nodes which\n     contained such calls at instantiate-time. If no such calls were present at instantiation,\n     these updates cannot be performed at all.\n   - Neither `hGraph` nor `hGraphExec` may contain device-updatable kernel nodes.\n - Memset and memcpy nodes:\n   - The CUDA device(s) to which the operand(s) was allocated/mapped cannot change.\n   - The source/destination memory must be allocated from the same contexts as the original\n     source/destination memory.\n   - For 2d memsets, only address and assinged value may be updated.\n   - For 1d memsets, updating dimensions is also allowed, but may fail if the resulting operation doesn't\n     map onto the work resources already allocated for the node.\n - Additional memcpy node restrictions:\n   - Changing either the source or destination memory type(i.e. CU_MEMORYTYPE_DEVICE,\n     CU_MEMORYTYPE_ARRAY, etc.) is not supported.\n - External semaphore wait nodes and record nodes:\n   - Changing the number of semaphores is not supported.\n - Conditional nodes:\n   - Changing node parameters is not supported.\n   - Changeing parameters of nodes within the conditional body graph is subject to the rules above.\n   - Conditional handle flags and default values are updated as part of the graph update.\n\n Note:  The API may add further restrictions in future releases.  The return code should always be checked.\n\n cuGraphExecUpdate sets the result member of `resultInfo` to CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED\n under the following conditions:\n - The count of nodes directly in `hGraphExec` and `hGraph` differ, in which case resultInfo->errorNode\n   is set to NULL.\n - `hGraph` has more exit nodes than `hGraph`, in which case resultInfo->errorNode is set to one of\n   the exit nodes in hGraph.\n - A node in `hGraph` has a different number of dependencies than the node from `hGraphExec` it is paired with,\n   in which case resultInfo->errorNode is set to the node from `hGraph`.\n - A node in `hGraph` has a dependency that does not match with the corresponding dependency of the paired node\n   from `hGraphExec`. resultInfo->errorNode will be set to the node from `hGraph`. resultInfo->errorFromNode\n   will be set to the mismatched dependency. The dependencies are paired based on edge order and a dependency\n   does not match when the nodes are already paired based on other edges examined in the graph.\n\n cuGraphExecUpdate sets the result member of `resultInfo` to:\n - CU_GRAPH_EXEC_UPDATE_ERROR if passed an invalid value.\n - CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED if the graph topology changed\n - CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED if the type of a node changed, in which case\n   `hErrorNode_out` is set to the node from `hGraph`.\n - CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE if the function changed in an unsupported\n   way(see note above), in which case `hErrorNode_out` is set to the node from `hGraph`\n - CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED if any parameters to a node changed in a way\n   that is not supported, in which case `hErrorNode_out` is set to the node from `hGraph`.\n - CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED if any attributes of a node changed in a way\n   that is not supported, in which case `hErrorNode_out` is set to the node from `hGraph`.\n - CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED if something about a node is unsupported, like\n   the node's type or configuration, in which case `hErrorNode_out` is set to the node from `hGraph`\n\n If the update fails for a reason not listed above, the result member of `resultInfo` will be set\n to CU_GRAPH_EXEC_UPDATE_ERROR. If the update succeeds, the result member will be set to CU_GRAPH_EXEC_UPDATE_SUCCESS.\n\n cuGraphExecUpdate returns CUDA_SUCCESS when the updated was performed successfully.  It returns\n CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE if the graph update was not performed because it included\n changes which violated constraints specific to instantiated graph update.\n#### hGraphExec:\nThe instantiated graph to be updated\n#### hGraph:\nThe graph containing the updated parameters\n#### resultInfo:\nthe error info structure\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE](crate::ffi::CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE),\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecUpdate_v2(
        hGraphExec: CUgraphExec,
        hGraph: CUgraph,
        resultInfo: *mut CUgraphExecUpdateResultInfo,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Copies attributes from source node to destination node.\n\n Copies attributes from source node `src` to destination node `dst`.\n Both node must have the same context.\n\n `aram`[out] dst Destination node\n `aram`[in] src Source node\n For list of attributes see [CUkernelNodeAttrID](crate::ffi::CUkernelNodeAttrID)\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow)\n"]
    pub fn cuGraphKernelNodeCopyAttributes(dst: CUgraphNode, src: CUgraphNode) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Queries node attribute.\n\n Queries attribute `attr` from node `hNode` and stores it in corresponding\n member of `value_out`.\n\n `aram`[in] hNode\n `aram`[in] attr\n `aram`[out] value_out\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow)\n"]
    pub fn cuGraphKernelNodeGetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value_out: *mut CUkernelNodeAttrValue,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets node attribute.\n\n Sets attribute `attr` on node `hNode` from corresponding attribute of\n `value`.\n\n `aram`[out] hNode\n `aram`[in] attr\n `aram`[out] value\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [CUaccessPolicyWindow](crate::ffi::CUaccessPolicyWindow)\n"]
    pub fn cuGraphKernelNodeSetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value: *const CUkernelNodeAttrValue,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Write a DOT file describing graph structure\n\n Using the provided `hGraph`, write to `path` a DOT formatted description of the graph.\n By default this includes the graph topology, node types, node id, kernel names and memcpy direction.\n `flags` can be specified to write more detailed information about each node type such as\n parameter values, kernel attributes, node and function handles.\n#### hGraph:\n- The graph to create a DOT file from\n#### path:\n- The path to write the DOT file to\n#### flags:\n- Flags from CUgraphDebugDot_flags for specifying which additional node information to write\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OPERATING_SYSTEM](crate::ffi::CUDA_ERROR_OPERATING_SYSTEM)\n"]
    pub fn cuGraphDebugDotPrint(
        hGraph: CUgraph,
        path: *const ::std::ffi::c_char,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a user object\n\n Create a user object with the specified destructor callback and initial reference count. The\n initial references are owned by the caller.\n\n Destructor callbacks cannot make CUDA API calls and should avoid blocking behavior, as they\n are executed by a shared internal thread. Another thread may be signaled to perform such\n actions, if it does not block forward progress of tasks scheduled through CUDA.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n#### object_out:\n- Location to return the user object handle\n#### ptr:\n- The pointer to pass to the destroy function\n#### destroy:\n- Callback to free the user object when it is no longer in use\n#### initialRefcount:\n- The initial refcount to create the object with, typically 1. The\n                          initial references are owned by the calling thread.\n#### flags:\n- Currently it is required to pass [CU_USER_OBJECT_NO_DESTRUCTOR_SYNC](crate::ffi::CU_USER_OBJECT_NO_DESTRUCTOR_SYNC),\n                          which is the only defined flag. This indicates that the destroy\n                          callback cannot be waited on by any CUDA API. Users requiring\n                          synchronization of the callback should signal its completion\n                          manually.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuUserObjectRetain](crate::ffi::cuUserObjectRetain),\n [cuUserObjectRelease](crate::ffi::cuUserObjectRelease),\n [cuGraphRetainUserObject](crate::ffi::cuGraphRetainUserObject),\n [cuGraphReleaseUserObject](crate::ffi::cuGraphReleaseUserObject),\n [cuGraphCreate](crate::ffi::cuGraphCreate)\n"]
    pub fn cuUserObjectCreate(
        object_out: *mut CUuserObject,
        ptr: *mut ::std::ffi::c_void,
        destroy: CUhostFn,
        initialRefcount: ::std::ffi::c_uint,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Retain a reference to a user object\n\n Retains new references to a user object. The new references are owned by the caller.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n#### object:\n- The object to retain\n#### count:\n- The number of references to retain, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuUserObjectCreate](crate::ffi::cuUserObjectCreate),\n [cuUserObjectRelease](crate::ffi::cuUserObjectRelease),\n [cuGraphRetainUserObject](crate::ffi::cuGraphRetainUserObject),\n [cuGraphReleaseUserObject](crate::ffi::cuGraphReleaseUserObject),\n [cuGraphCreate](crate::ffi::cuGraphCreate)\n"]
    pub fn cuUserObjectRetain(object: CUuserObject, count: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Release a reference to a user object\n\n Releases user object references owned by the caller. The object's destructor is invoked if\n the reference count reaches zero.\n\n It is undefined behavior to release references not owned by the caller, or to use a user\n object handle after all references are released.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n#### object:\n- The object to release\n#### count:\n- The number of references to release, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuUserObjectCreate](crate::ffi::cuUserObjectCreate),\n [cuUserObjectRetain](crate::ffi::cuUserObjectRetain),\n [cuGraphRetainUserObject](crate::ffi::cuGraphRetainUserObject),\n [cuGraphReleaseUserObject](crate::ffi::cuGraphReleaseUserObject),\n [cuGraphCreate](crate::ffi::cuGraphCreate)\n"]
    pub fn cuUserObjectRelease(object: CUuserObject, count: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Retain a reference to a user object from a graph\n\n Creates or moves user object references that will be owned by a CUDA graph.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n#### graph:\n- The graph to associate the reference with\n#### object:\n- The user object to retain a reference for\n#### count:\n- The number of references to add to the graph, typically 1. Must be\n                 nonzero and not larger than INT_MAX.\n#### flags:\n- The optional flag [CU_GRAPH_USER_OBJECT_MOVE](crate::ffi::CU_GRAPH_USER_OBJECT_MOVE) transfers references\n                 from the calling thread, rather than create new references. Pass 0\n                 to create new references.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuUserObjectCreate](crate::ffi::cuUserObjectCreate),\n [cuUserObjectRetain](crate::ffi::cuUserObjectRetain),\n [cuUserObjectRelease](crate::ffi::cuUserObjectRelease),\n [cuGraphReleaseUserObject](crate::ffi::cuGraphReleaseUserObject),\n [cuGraphCreate](crate::ffi::cuGraphCreate)\n"]
    pub fn cuGraphRetainUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::ffi::c_uint,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Release a user object reference from a graph\n\n Releases user object references owned by a graph.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n#### graph:\n- The graph that will release the reference\n#### object:\n- The user object to release a reference for\n#### count:\n- The number of references to release, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuUserObjectCreate](crate::ffi::cuUserObjectCreate),\n [cuUserObjectRetain](crate::ffi::cuUserObjectRetain),\n [cuUserObjectRelease](crate::ffi::cuUserObjectRelease),\n [cuGraphRetainUserObject](crate::ffi::cuGraphRetainUserObject),\n [cuGraphCreate](crate::ffi::cuGraphCreate)\n"]
    pub fn cuGraphReleaseUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds a node of arbitrary type to a graph\n\n Creates a new node in `hGraph` described by `nodeParams` with `numDependencies`\n dependencies specified via `dependencies`. `numDependencies` may be 0.\n `dependencies` may be null if `numDependencies` is 0. `dependencies` may not have\n any duplicate entries.\n\n `nodeParams` is a tagged union. The node type should be specified in the `type` field,\n and type-specific parameters in the corresponding union member. All unused bytes - that\n is, `reserved0` and all bytes past the utilized union member - must be set to zero.\n It is recommended to use brace initialization or memset to ensure all bytes are\n initialized.\n\n Note that for some node types, `nodeParams` may contain \"out parameters\" which are\n modified during the call, such as `nodeParams`->alloc.dptr.\n\n A handle to the new node will be returned in `phGraphNode`.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Specification of the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams)\n"]
    pub fn cuGraphAddNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *mut CUgraphNodeParams,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Adds a node of arbitrary type to a graph (12.3+)\n\n Creates a new node in `hGraph` described by `nodeParams` with `numDependencies`\n dependencies specified via `dependencies`. `numDependencies` may be 0.\n `dependencies` may be null if `numDependencies` is 0. `dependencies` may not have\n any duplicate entries.\n\n `nodeParams` is a tagged union. The node type should be specified in the `type` field,\n and type-specific parameters in the corresponding union member. All unused bytes - that\n is, `reserved0` and all bytes past the utilized union member - must be set to zero.\n It is recommended to use brace initialization or memset to ensure all bytes are\n initialized.\n\n Note that for some node types, `nodeParams` may contain \"out parameters\" which are\n modified during the call, such as `nodeParams`->alloc.dptr.\n\n A handle to the new node will be returned in `phGraphNode`.\n#### phGraphNode:\n- Returns newly created node\n#### hGraph:\n- Graph to which to add the node\n#### dependencies:\n- Dependencies of the node\n#### dependencyData:\n- Optional edge data for the dependencies. If NULL, the data is\n                          assumed to be default (zeroed) for all dependencies.\n#### numDependencies:\n- Number of dependencies\n#### nodeParams:\n- Specification of the node\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphCreate](crate::ffi::cuGraphCreate),\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams),\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams)\n"]
    pub fn cuGraphAddNode_v2(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        dependencyData: *const CUgraphEdgeData,
        numDependencies: usize,
        nodeParams: *mut CUgraphNodeParams,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Update's a graph node's parameters\n\n Sets the parameters of graph node `hNode` to `nodeParams`. The node type specified by\n `nodeParams`->type must match the type of `hNode`. `nodeParams` must be fully\n initialized and all unused bytes (reserved, padding) zeroed.\n\n Modifying parameters is not supported for node types CU_GRAPH_NODE_TYPE_MEM_ALLOC and\n CU_GRAPH_NODE_TYPE_MEM_FREE.\n#### hNode:\n- Node to set the parameters for\n#### nodeParams:\n- Parameters to copy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphExecNodeSetParams](crate::ffi::cuGraphExecNodeSetParams)\n"]
    pub fn cuGraphNodeSetParams(hNode: CUgraphNode, nodeParams: *mut CUgraphNodeParams)
        -> CUresult;
}
unsafe extern "C" {
    #[doc = " Update's a graph node's parameters in an instantiated graph\n\n Sets the parameters of a node in an executable graph `hGraphExec`. The node is identified\n by the corresponding node `hNode` in the non-executable graph from which the executable\n graph was instantiated. `hNode` must not have been removed from the original graph.\n\n The modifications only affect future launches of `hGraphExec`. Already\n enqueued or running launches of `hGraphExec` are not affected by this call.\n `hNode` is also not modified by this call.\n\n Allowed changes to parameters on executable graphs are as follows:\n <table>\n   <tr><th>Node type<th>Allowed changes\n   <tr><td>kernel<td>See [cuGraphExecKernelNodeSetParams](crate::ffi::cuGraphExecKernelNodeSetParams)\n   <tr><td>memcpy<td>Addresses for 1-dimensional copies if allocated in same context; see [cuGraphExecMemcpyNodeSetParams](crate::ffi::cuGraphExecMemcpyNodeSetParams)\n   <tr><td>memset<td>Addresses for 1-dimensional memsets if allocated in same context; see [cuGraphExecMemsetNodeSetParams](crate::ffi::cuGraphExecMemsetNodeSetParams)\n   <tr><td>host<td>Unrestricted\n   <tr><td>child graph<td>Topology must match and restrictions apply recursively; see [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate)\n   <tr><td>event wait<td>Unrestricted\n   <tr><td>event record<td>Unrestricted\n   <tr><td>external semaphore signal<td>Number of semaphore operations cannot change\n   <tr><td>external semaphore wait<td>Number of semaphore operations cannot change\n   <tr><td>memory allocation<td>API unsupported\n   <tr><td>memory free<td>API unsupported\n   <tr><td>batch memops<td>Addresses, values, and operation type for wait operations; see [cuGraphExecBatchMemOpNodeSetParams](crate::ffi::cuGraphExecBatchMemOpNodeSetParams)\n </table>\n#### hGraphExec:\n- The executable graph in which to update the specified node\n#### hNode:\n- Corresponding node from the graph from which graphExec was instantiated\n#### nodeParams:\n- Updated Parameters to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode),\n [cuGraphNodeSetParams](crate::ffi::cuGraphNodeSetParams)\n [cuGraphExecUpdate](crate::ffi::cuGraphExecUpdate),\n [cuGraphInstantiate](crate::ffi::cuGraphInstantiate)\n"]
    pub fn cuGraphExecNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *mut CUgraphNodeParams,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a conditional handle\n\n Creates a conditional handle associated with `hGraph`.\n\n The conditional handle must be associated with a conditional node in this graph or one of its children.\n\n Handles not associated with a conditional node may cause graph instantiation to fail.\n\n Handles can only be set from the context with which they are associated.\n#### pHandle_out:\n- Pointer used to return the handle to the caller.\n#### hGraph:\n- Graph which will contain the conditional node using this handle.\n#### ctx:\n- Context for the handle and associated conditional node.\n#### defaultLaunchValue:\n- Optional initial value for the conditional variable.\n                             Applied at the beginning of each graph execution if CU_GRAPH_COND_ASSIGN_DEFAULT is set in `flags`.\n#### flags:\n- Currently must be CU_GRAPH_COND_ASSIGN_DEFAULT or 0.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n \\note_graph_thread_safety\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphAddNode](crate::ffi::cuGraphAddNode)\n"]
    pub fn cuGraphConditionalHandleCreate(
        pHandle_out: *mut CUgraphConditionalHandle,
        hGraph: CUgraph,
        ctx: CUcontext,
        defaultLaunchValue: ::std::ffi::c_uint,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns occupancy of a function\n\n Returns in `*numBlocks` the number of the maximum active blocks per\n streaming multiprocessor.\n\n Note that the API can also be used with context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to use for calculations\n will be the current context.\n#### numBlocks:\n- Returned occupancy\n#### func:\n- Kernel for which occupancy is calculated\n#### blockSize:\n- Block size the kernel is intended to be launched with\n#### dynamicSMemSize:\n- Per-block dynamic shared memory usage intended, in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cudaOccupancyMaxActiveBlocksPerMultiprocessor](crate::ffi::cudaOccupancyMaxActiveBlocksPerMultiprocessor)\n"]
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::ffi::c_int,
        func: CUfunction,
        blockSize: ::std::ffi::c_int,
        dynamicSMemSize: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns occupancy of a function\n\n Returns in `*numBlocks` the number of the maximum active blocks per\n streaming multiprocessor.\n\n The `Flags` parameter controls how special cases are handled. The\n valid flags are:\n\n - [CU_OCCUPANCY_DEFAULT](crate::ffi::CU_OCCUPANCY_DEFAULT), which maintains the default behavior as\n   [cuOccupancyMaxActiveBlocksPerMultiprocessor](crate::ffi::cuOccupancyMaxActiveBlocksPerMultiprocessor);\n\n - [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](crate::ffi::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE), which suppresses the\n   default behavior on platform where global caching affects\n   occupancy. On such platforms, if caching is enabled, but\n   per-block SM resource usage would result in zero occupancy, the\n   occupancy calculator will calculate the occupancy as if caching\n   is disabled. Setting [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](crate::ffi::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE) makes\n   the occupancy calculator to return 0 in such cases. More information\n   can be found about this feature in the \"Unified L1/Texture Cache\"\n   section of the Maxwell tuning guide.\n\n Note that the API can also be with launch context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to use for calculations\n will be the current context.\n#### numBlocks:\n- Returned occupancy\n#### func:\n- Kernel for which occupancy is calculated\n#### blockSize:\n- Block size the kernel is intended to be launched with\n#### dynamicSMemSize:\n- Per-block dynamic shared memory usage intended, in bytes\n#### flags:\n- Requested behavior for the occupancy calculator\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](crate::ffi::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags)\n"]
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::ffi::c_int,
        func: CUfunction,
        blockSize: ::std::ffi::c_int,
        dynamicSMemSize: usize,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Suggest a launch configuration with reasonable occupancy\n\n Returns in `*blockSize` a reasonable block size that can achieve\n the maximum occupancy (or, the maximum number of active warps with\n the fewest blocks per multiprocessor), and in `*minGridSize` the\n minimum grid size to achieve the maximum occupancy.\n\n If `blockSizeLimit` is 0, the configurator will use the maximum\n block size permitted by the device / function instead.\n\n If per-block dynamic shared memory allocation is not needed, the\n user should leave both `blockSizeToDynamicSMemSize` and `dynamicSMemSize` as 0.\n\n If per-block dynamic shared memory allocation is needed, then if\n the dynamic shared memory size is constant regardless of block\n size, the size should be passed through `dynamicSMemSize`, and `blockSizeToDynamicSMemSize` should be NULL.\n\n Otherwise, if the per-block dynamic shared memory size varies with\n different block sizes, the user needs to provide a unary function\n through `blockSizeToDynamicSMemSize` that computes the dynamic\n shared memory needed by `func` for any given block size. `dynamicSMemSize` is ignored. An example signature is:\n\n \\code\n    // Take block size, returns dynamic shared memory needed\n    size_t blockToSmem(int blockSize);\n \\endcode\n\n Note that the API can also be used with context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to use for calculations\n will be the current context.\n#### minGridSize:\n- Returned minimum grid size needed to achieve the maximum occupancy\n#### blockSize:\n- Returned maximum block size that can achieve the maximum occupancy\n#### func:\n- Kernel for which launch configuration is calculated\n#### blockSizeToDynamicSMemSize:\n- A function that calculates how much per-block dynamic shared memory `func` uses based on the block size\n#### dynamicSMemSize:\n- Dynamic shared memory usage intended, in bytes\n#### blockSizeLimit:\n- The maximum block size `func` is designed to handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cudaOccupancyMaxPotentialBlockSize](crate::ffi::cudaOccupancyMaxPotentialBlockSize)\n"]
    pub fn cuOccupancyMaxPotentialBlockSize(
        minGridSize: *mut ::std::ffi::c_int,
        blockSize: *mut ::std::ffi::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Suggest a launch configuration with reasonable occupancy\n\n An extended version of [cuOccupancyMaxPotentialBlockSize](crate::ffi::cuOccupancyMaxPotentialBlockSize). In\n addition to arguments passed to [cuOccupancyMaxPotentialBlockSize](crate::ffi::cuOccupancyMaxPotentialBlockSize),\n [cuOccupancyMaxPotentialBlockSizeWithFlags](crate::ffi::cuOccupancyMaxPotentialBlockSizeWithFlags) also takes a `Flags`\n parameter.\n\n The `Flags` parameter controls how special cases are handled. The\n valid flags are:\n\n - [CU_OCCUPANCY_DEFAULT](crate::ffi::CU_OCCUPANCY_DEFAULT), which maintains the default behavior as\n   [cuOccupancyMaxPotentialBlockSize](crate::ffi::cuOccupancyMaxPotentialBlockSize);\n\n - [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](crate::ffi::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE), which suppresses the\n   default behavior on platform where global caching affects\n   occupancy. On such platforms, the launch configurations that\n   produces maximal occupancy might not support global\n   caching. Setting [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](crate::ffi::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE)\n   guarantees that the the produced launch configuration is global\n   caching compatible at a potential cost of occupancy. More information\n   can be found about this feature in the \"Unified L1/Texture Cache\"\n   section of the Maxwell tuning guide.\n\n Note that the API can also be used with context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to use for calculations\n will be the current context.\n#### minGridSize:\n- Returned minimum grid size needed to achieve the maximum occupancy\n#### blockSize:\n- Returned maximum block size that can achieve the maximum occupancy\n#### func:\n- Kernel for which launch configuration is calculated\n#### blockSizeToDynamicSMemSize:\n- A function that calculates how much per-block dynamic shared memory `func` uses based on the block size\n#### dynamicSMemSize:\n- Dynamic shared memory usage intended, in bytes\n#### blockSizeLimit:\n- The maximum block size `func` is designed to handle\n#### flags:\n- Options\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cudaOccupancyMaxPotentialBlockSizeWithFlags](crate::ffi::cudaOccupancyMaxPotentialBlockSizeWithFlags)\n"]
    pub fn cuOccupancyMaxPotentialBlockSizeWithFlags(
        minGridSize: *mut ::std::ffi::c_int,
        blockSize: *mut ::std::ffi::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::std::ffi::c_int,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns dynamic shared memory available per block when launching `numBlocks` blocks on SM\n\n Returns in `*dynamicSmemSize` the maximum size of dynamic shared memory to allow `numBlocks` blocks per SM.\n\n Note that the API can also be used with context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to use for calculations\n will be the current context.\n#### dynamicSmemSize:\n- Returned maximum dynamic shared memory\n#### func:\n- Kernel function for which occupancy is calculated\n#### numBlocks:\n- Number of blocks to fit on SM\n#### blockSize:\n- Size of the blocks\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n"]
    pub fn cuOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut usize,
        func: CUfunction,
        numBlocks: ::std::ffi::c_int,
        blockSize: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Given the kernel function (`func`) and launch configuration\n (`config`), return the maximum cluster size in `*clusterSize`.\n\n The cluster dimensions in `config` are ignored. If func has a required\n cluster size set (see [cudaFuncGetAttributes](crate::ffi::cudaFuncGetAttributes) / [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute)),`*clusterSize` will reflect the required cluster size.\n\n By default this function will always return a value that's portable on\n future hardware. A higher value may be returned if the kernel function\n allows non-portable cluster sizes.\n\n This function will respect the compile time launch bounds.\n\n Note that the API can also be used with context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to use for calculations\n will either be taken from the specified stream `config`->hStream\n or the current context in case of NULL stream.\n#### clusterSize:\n- Returned maximum cluster size that can be launched\n                      for the given kernel function and launch configuration\n#### func:\n- Kernel function for which maximum cluster\n                      size is calculated\n#### config:\n- Launch configuration for the given kernel function\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cudaFuncGetAttributes](crate::ffi::cudaFuncGetAttributes),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute)\n"]
    pub fn cuOccupancyMaxPotentialClusterSize(
        clusterSize: *mut ::std::ffi::c_int,
        func: CUfunction,
        config: *const CUlaunchConfig,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Given the kernel function (`func`) and launch configuration\n (`config`), return the maximum number of clusters that could co-exist\n on the target device in `*numClusters`.\n\n If the function has required cluster size already set (see\n [cudaFuncGetAttributes](crate::ffi::cudaFuncGetAttributes) / [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute)), the cluster size\n from config must either be unspecified or match the required size.\n Without required sizes, the cluster size must be specified in config,\n else the function will return an error.\n\n Note that various attributes of the kernel function may affect occupancy\n calculation. Runtime environment may affect how the hardware schedules\n the clusters, so the calculated occupancy is not guaranteed to be achievable.\n\n Note that the API can also be used with context-less kernel [CUkernel](crate::ffi::CUkernel)\n by querying the handle using [cuLibraryGetKernel](crate::ffi::cuLibraryGetKernel)() and then passing it\n to the API by casting to [CUfunction](crate::ffi::CUfunction). Here, the context to use for calculations\n will either be taken from the specified stream `config`->hStream\n or the current context in case of NULL stream.\n#### numClusters:\n- Returned maximum number of clusters that\n                      could co-exist on the target device\n#### func:\n- Kernel function for which maximum number\n                      of clusters are calculated\n#### config:\n- Launch configuration for the given kernel function\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_CLUSTER_SIZE](crate::ffi::CUDA_ERROR_INVALID_CLUSTER_SIZE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cudaFuncGetAttributes](crate::ffi::cudaFuncGetAttributes),\n [cuFuncGetAttribute](crate::ffi::cuFuncGetAttribute)\n"]
    pub fn cuOccupancyMaxActiveClusters(
        numClusters: *mut ::std::ffi::c_int,
        func: CUfunction,
        config: *const CUlaunchConfig,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Binds an array as a texture reference\n\n \\deprecated\n\n Binds the CUDA array `hArray` to the texture reference `hTexRef`. Any\n previous address or CUDA array state associated with the texture reference\n is superseded by this function. `Flags` must be set to\n [CU_TRSA_OVERRIDE_FORMAT](crate::ffi::CU_TRSA_OVERRIDE_FORMAT). Any CUDA array previously bound to `hTexRef` is\n unbound.\n#### hTexRef:\n- Texture reference to bind\n#### hArray:\n- Array to bind\n#### Flags:\n- Options (must be [CU_TRSA_OVERRIDE_FORMAT](crate::ffi::CU_TRSA_OVERRIDE_FORMAT))\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetArray(
        hTexRef: CUtexref,
        hArray: CUarray,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Binds a mipmapped array to a texture reference\n\n \\deprecated\n\n Binds the CUDA mipmapped array `hMipmappedArray` to the texture reference `hTexRef`.\n Any previous address or CUDA array state associated with the texture reference\n is superseded by this function. `Flags` must be set to [CU_TRSA_OVERRIDE_FORMAT](crate::ffi::CU_TRSA_OVERRIDE_FORMAT).\n Any CUDA array previously bound to `hTexRef` is unbound.\n#### hTexRef:\n- Texture reference to bind\n#### hMipmappedArray:\n- Mipmapped array to bind\n#### Flags:\n- Options (must be [CU_TRSA_OVERRIDE_FORMAT](crate::ffi::CU_TRSA_OVERRIDE_FORMAT))\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetMipmappedArray(
        hTexRef: CUtexref,
        hMipmappedArray: CUmipmappedArray,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Binds an address as a texture reference\n\n \\deprecated\n\n Binds a linear address range to the texture reference `hTexRef`. Any\n previous address or CUDA array state associated with the texture reference\n is superseded by this function. Any memory previously bound to `hTexRef`\n is unbound.\n\n Since the hardware enforces an alignment requirement on texture base\n addresses, [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress)() passes back a byte offset in\n `*ByteOffset` that must be applied to texture fetches in order to read from\n the desired memory. This offset must be divided by the texel size and\n passed to kernels that read from the texture so they can be applied to the\n [tex1Dfetch](crate::ffi::tex1Dfetch)() function.\n\n If the device memory pointer was returned from [cuMemAlloc](crate::ffi::cuMemAlloc)(), the offset\n is guaranteed to be 0 and NULL may be passed as the `ByteOffset` parameter.\n\n The total number of elements (or texels) in the linear address range\n cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH).\n The number of elements is computed as (`bytes` / bytesPerElement),\n where bytesPerElement is determined from the data format and number of\n components set using [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat)().\n#### ByteOffset:\n- Returned byte offset\n#### hTexRef:\n- Texture reference to bind\n#### dptr:\n- Device pointer to bind\n#### bytes:\n- Size of memory to bind in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetAddress_v2(
        ByteOffset: *mut usize,
        hTexRef: CUtexref,
        dptr: CUdeviceptr,
        bytes: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Binds an address as a 2D texture reference\n\n \\deprecated\n\n Binds a linear address range to the texture reference `hTexRef`. Any\n previous address or CUDA array state associated with the texture reference\n is superseded by this function. Any memory previously bound to `hTexRef`\n is unbound.\n\n Using a [tex2D](crate::ffi::tex2D)() function inside a kernel requires a call to either\n [cuTexRefSetArray](crate::ffi::cuTexRefSetArray)() to bind the corresponding texture reference to an\n array, or [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D)() to bind the texture reference to linear\n memory.\n\n Function calls to [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat)() cannot follow calls to\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D)() for the same texture reference.\n\n It is required that `dptr` be aligned to the appropriate hardware-specific\n texture alignment. You can query this value using the device attribute\n [CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT](crate::ffi::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT). If an unaligned `dptr` is\n supplied, [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n `Pitch` has to be aligned to the hardware-specific texture pitch alignment.\n This value can be queried using the device attribute\n [CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT](crate::ffi::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT). If an unaligned `Pitch` is\n supplied, [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n\n Width and Height, which are specified in elements (or texels), cannot exceed\n [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH) and\n [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT) respectively.\n `Pitch`, which is specified in bytes, cannot exceed\n [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH).\n#### hTexRef:\n- Texture reference to bind\n#### desc:\n- Descriptor of CUDA array\n#### dptr:\n- Device pointer to bind\n#### Pitch:\n- Line pitch in bytes\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetAddress2D_v3(
        hTexRef: CUtexref,
        desc: *const CUDA_ARRAY_DESCRIPTOR,
        dptr: CUdeviceptr,
        Pitch: usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the format for a texture reference\n\n \\deprecated\n\n Specifies the format of the data to be read by the texture reference\n `hTexRef`. `fmt` and `NumPackedComponents` are exactly analogous to the\n [Format](crate::ffi::Format) and [NumChannels](crate::ffi::NumChannels) members of the [CUDA_ARRAY_DESCRIPTOR](crate::ffi::CUDA_ARRAY_DESCRIPTOR) structure:\n They specify the format of each component and the number of components per\n array element.\n#### hTexRef:\n- Texture reference\n#### fmt:\n- Format to set\n#### NumPackedComponents:\n- Number of components per array element\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat),\n [cudaCreateChannelDesc](crate::ffi::cudaCreateChannelDesc)\n"]
    pub fn cuTexRefSetFormat(
        hTexRef: CUtexref,
        fmt: CUarray_format,
        NumPackedComponents: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the addressing mode for a texture reference\n\n \\deprecated\n\n Specifies the addressing mode `am` for the given dimension `dim` of the\n texture reference `hTexRef`. If `dim` is zero, the addressing mode is\n applied to the first parameter of the functions used to fetch from the\n texture; if `dim` is 1, the second, and so on. [CUaddress_mode](crate::ffi::CUaddress_mode) is defined\n as:\n \\code\ntypedef enum CUaddress_mode_enum {\nCU_TR_ADDRESS_MODE_WRAP = 0,\nCU_TR_ADDRESS_MODE_CLAMP = 1,\nCU_TR_ADDRESS_MODE_MIRROR = 2,\nCU_TR_ADDRESS_MODE_BORDER = 3\n} CUaddress_mode;\n \\endcode\n\n Note that this call has no effect if `hTexRef` is bound to linear memory.\n Also, if the flag, [CU_TRSF_NORMALIZED_COORDINATES](crate::ffi::CU_TRSF_NORMALIZED_COORDINATES), is not set, the only\n supported address mode is [CU_TR_ADDRESS_MODE_CLAMP](crate::ffi::CU_TR_ADDRESS_MODE_CLAMP).\n#### hTexRef:\n- Texture reference\n#### dim:\n- Dimension\n#### am:\n- Addressing mode to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetAddressMode(
        hTexRef: CUtexref,
        dim: ::std::ffi::c_int,
        am: CUaddress_mode,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the filtering mode for a texture reference\n\n \\deprecated\n\n Specifies the filtering mode `fm` to be used when reading memory through\n the texture reference `hTexRef`. [CUfilter_mode_enum](crate::ffi::CUfilter_mode_enum) is defined as:\n\n \\code\ntypedef enum CUfilter_mode_enum {\nCU_TR_FILTER_MODE_POINT = 0,\nCU_TR_FILTER_MODE_LINEAR = 1\n} CUfilter_mode;\n \\endcode\n\n Note that this call has no effect if `hTexRef` is bound to linear memory.\n#### hTexRef:\n- Texture reference\n#### fm:\n- Filtering mode to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the mipmap filtering mode for a texture reference\n\n \\deprecated\n\n Specifies the mipmap filtering mode `fm` to be used when reading memory through\n the texture reference `hTexRef`. [CUfilter_mode_enum](crate::ffi::CUfilter_mode_enum) is defined as:\n\n \\code\ntypedef enum CUfilter_mode_enum {\nCU_TR_FILTER_MODE_POINT = 0,\nCU_TR_FILTER_MODE_LINEAR = 1\n} CUfilter_mode;\n \\endcode\n\n Note that this call has no effect if `hTexRef` is not bound to a mipmapped array.\n#### hTexRef:\n- Texture reference\n#### fm:\n- Filtering mode to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetMipmapFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the mipmap level bias for a texture reference\n\n \\deprecated\n\n Specifies the mipmap level bias `bias` to be added to the specified mipmap level when\n reading memory through the texture reference `hTexRef`.\n\n Note that this call has no effect if `hTexRef` is not bound to a mipmapped array.\n#### hTexRef:\n- Texture reference\n#### bias:\n- Mipmap level bias\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetMipmapLevelBias(hTexRef: CUtexref, bias: f32) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the mipmap min/max mipmap level clamps for a texture reference\n\n \\deprecated\n\n Specifies the min/max mipmap level clamps, `minMipmapLevelClamp` and `maxMipmapLevelClamp`\n respectively, to be used when reading memory through the texture reference\n `hTexRef`.\n\n Note that this call has no effect if `hTexRef` is not bound to a mipmapped array.\n#### hTexRef:\n- Texture reference\n#### minMipmapLevelClamp:\n- Mipmap min level clamp\n#### maxMipmapLevelClamp:\n- Mipmap max level clamp\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetMipmapLevelClamp(
        hTexRef: CUtexref,
        minMipmapLevelClamp: f32,
        maxMipmapLevelClamp: f32,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the maximum anisotropy for a texture reference\n\n \\deprecated\n\n Specifies the maximum anisotropy `maxAniso` to be used when reading memory through\n the texture reference `hTexRef`.\n\n Note that this call has no effect if `hTexRef` is bound to linear memory.\n#### hTexRef:\n- Texture reference\n#### maxAniso:\n- Maximum anisotropy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetMaxAnisotropy(hTexRef: CUtexref, maxAniso: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the border color for a texture reference\n\n \\deprecated\n\n Specifies the value of the RGBA color via the `pBorderColor` to the texture reference\n `hTexRef`. The color value supports only float type and holds color components in\n the following sequence:\n pBorderColor[0] holds 'R' component\n pBorderColor[1] holds 'G' component\n pBorderColor[2] holds 'B' component\n pBorderColor[3] holds 'A' component\n\n Note that the color values can be set only when the Address mode is set to\n CU_TR_ADDRESS_MODE_BORDER using [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode).\n Applications using integer border color values have to \"reinterpret_cast\" their values to float.\n#### hTexRef:\n- Texture reference\n#### pBorderColor:\n- RGBA color\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode),\n [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetBorderColor](crate::ffi::cuTexRefGetBorderColor)\n"]
    pub fn cuTexRefSetBorderColor(hTexRef: CUtexref, pBorderColor: *mut f32) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the flags for a texture reference\n\n \\deprecated\n\n Specifies optional flags via `Flags` to specify the behavior of data\n returned through the texture reference `hTexRef`. The valid flags are:\n\n - [CU_TRSF_READ_AS_INTEGER](crate::ffi::CU_TRSF_READ_AS_INTEGER), which suppresses the default behavior of\n   having the texture promote integer data to floating point data in the\n   range [0, 1]. Note that texture with 32-bit integer format\n   would not be promoted, regardless of whether or not this\n   flag is specified;\n - [CU_TRSF_NORMALIZED_COORDINATES](crate::ffi::CU_TRSF_NORMALIZED_COORDINATES), which suppresses the\n   default behavior of having the texture coordinates range\n   from [0, Dim) where Dim is the width or height of the CUDA\n   array. Instead, the texture coordinates [0, 1.0) reference\n   the entire breadth of the array dimension;\n - [CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION](crate::ffi::CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION), which disables any trilinear\n   filtering optimizations. Trilinear optimizations improve texture filtering\n   performance by allowing bilinear filtering on textures in scenarios where\n   it can closely approximate the expected results.\n#### hTexRef:\n- Texture reference\n#### Flags:\n- Optional flags to set\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefSetFlags(hTexRef: CUtexref, Flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the address associated with a texture reference\n\n \\deprecated\n\n Returns in `*pdptr` the base address bound to the texture reference\n `hTexRef`, or returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if the texture reference\n is not bound to any device memory range.\n#### pdptr:\n- Returned device address\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetAddress_v2(pdptr: *mut CUdeviceptr, hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the array bound to a texture reference\n\n \\deprecated\n\n Returns in `*phArray` the CUDA array bound to the texture reference\n `hTexRef`, or returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if the texture reference\n is not bound to any CUDA array.\n#### phArray:\n- Returned array\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetArray(phArray: *mut CUarray, hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the mipmapped array bound to a texture reference\n\n \\deprecated\n\n Returns in `*phMipmappedArray` the CUDA mipmapped array bound to the texture\n reference `hTexRef`, or returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if the texture reference\n is not bound to any CUDA mipmapped array.\n#### phMipmappedArray:\n- Returned mipmapped array\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetMipmappedArray(
        phMipmappedArray: *mut CUmipmappedArray,
        hTexRef: CUtexref,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the addressing mode used by a texture reference\n\n \\deprecated\n\n Returns in `*pam` the addressing mode corresponding to the\n dimension `dim` of the texture reference `hTexRef`. Currently, the only\n valid value for `dim` are 0 and 1.\n#### pam:\n- Returned addressing mode\n#### hTexRef:\n- Texture reference\n#### dim:\n- Dimension\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetAddressMode(
        pam: *mut CUaddress_mode,
        hTexRef: CUtexref,
        dim: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the filter-mode used by a texture reference\n\n \\deprecated\n\n Returns in `*pfm` the filtering mode of the texture reference\n `hTexRef`.\n#### pfm:\n- Returned filtering mode\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the format used by a texture reference\n\n \\deprecated\n\n Returns in `*pFormat` and `*pNumChannels` the format and number\n of components of the CUDA array bound to the texture reference `hTexRef`.\n If `pFormat` or `pNumChannels` is NULL, it will be ignored.\n#### pFormat:\n- Returned format\n#### pNumChannels:\n- Returned number of components\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags)\n"]
    pub fn cuTexRefGetFormat(
        pFormat: *mut CUarray_format,
        pNumChannels: *mut ::std::ffi::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the mipmap filtering mode for a texture reference\n\n \\deprecated\n\n Returns the mipmap filtering mode in `pfm` that's used when reading memory through\n the texture reference `hTexRef`.\n#### pfm:\n- Returned mipmap filtering mode\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetMipmapFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the mipmap level bias for a texture reference\n\n \\deprecated\n\n Returns the mipmap level bias in `pBias` that's added to the specified mipmap\n level when reading memory through the texture reference `hTexRef`.\n#### pbias:\n- Returned mipmap level bias\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetMipmapLevelBias(pbias: *mut f32, hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the min/max mipmap level clamps for a texture reference\n\n \\deprecated\n\n Returns the min/max mipmap level clamps in `pminMipmapLevelClamp` and `pmaxMipmapLevelClamp`\n that's used when reading memory through the texture reference `hTexRef`.\n#### pminMipmapLevelClamp:\n- Returned mipmap min level clamp\n#### pmaxMipmapLevelClamp:\n- Returned mipmap max level clamp\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the maximum anisotropy for a texture reference\n\n \\deprecated\n\n Returns the maximum anisotropy in `pmaxAniso` that's used when reading memory through\n the texture reference `hTexRef`.\n#### pmaxAniso:\n- Returned maximum anisotropy\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFlags](crate::ffi::cuTexRefGetFlags), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetMaxAnisotropy(
        pmaxAniso: *mut ::std::ffi::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the border color used by a texture reference\n\n \\deprecated\n\n Returns in `pBorderColor`, values of the RGBA color used by\n the texture reference `hTexRef`.\n The color value is of type float and holds color components in\n the following sequence:\n pBorderColor[0] holds 'R' component\n pBorderColor[1] holds 'G' component\n pBorderColor[2] holds 'B' component\n pBorderColor[3] holds 'A' component\n#### hTexRef:\n- Texture reference\n#### pBorderColor:\n- Returned Type and Value of RGBA color\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode),\n [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetBorderColor](crate::ffi::cuTexRefSetBorderColor)\n"]
    pub fn cuTexRefGetBorderColor(pBorderColor: *mut f32, hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Gets the flags used by a texture reference\n\n \\deprecated\n\n Returns in `*pFlags` the flags of the texture reference `hTexRef`.\n#### pFlags:\n- Returned flags\n#### hTexRef:\n- Texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress),\n [cuTexRefSetAddress2D](crate::ffi::cuTexRefSetAddress2D), [cuTexRefSetAddressMode](crate::ffi::cuTexRefSetAddressMode), [cuTexRefSetArray](crate::ffi::cuTexRefSetArray),\n [cuTexRefSetFilterMode](crate::ffi::cuTexRefSetFilterMode), [cuTexRefSetFlags](crate::ffi::cuTexRefSetFlags), [cuTexRefSetFormat](crate::ffi::cuTexRefSetFormat),\n [cuTexRefGetAddress](crate::ffi::cuTexRefGetAddress), [cuTexRefGetAddressMode](crate::ffi::cuTexRefGetAddressMode), [cuTexRefGetArray](crate::ffi::cuTexRefGetArray),\n [cuTexRefGetFilterMode](crate::ffi::cuTexRefGetFilterMode), [cuTexRefGetFormat](crate::ffi::cuTexRefGetFormat)\n"]
    pub fn cuTexRefGetFlags(pFlags: *mut ::std::ffi::c_uint, hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a texture reference\n\n \\deprecated\n\n Creates a texture reference and returns its handle in `*pTexRef`. Once\n created, the application must call [cuTexRefSetArray](crate::ffi::cuTexRefSetArray)() or\n [cuTexRefSetAddress](crate::ffi::cuTexRefSetAddress)() to associate the reference with allocated memory.\n Other texture reference functions are used to specify the format and\n interpretation (addressing, filtering, etc.) to be used when the memory is\n read through this texture reference.\n#### pTexRef:\n- Returned texture reference\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefDestroy](crate::ffi::cuTexRefDestroy)\n"]
    pub fn cuTexRefCreate(pTexRef: *mut CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a texture reference\n\n \\deprecated\n\n Destroys the texture reference specified by `hTexRef`.\n#### hTexRef:\n- Texture reference to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuTexRefCreate](crate::ffi::cuTexRefCreate)\n"]
    pub fn cuTexRefDestroy(hTexRef: CUtexref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Sets the CUDA array for a surface reference.\n\n \\deprecated\n\n Sets the CUDA array `hArray` to be read and written by the surface reference\n `hSurfRef`.  Any previous CUDA array state associated with the surface\n reference is superseded by this function.  `Flags` must be set to 0.\n The [CUDA_ARRAY3D_SURFACE_LDST](crate::ffi::CUDA_ARRAY3D_SURFACE_LDST) flag must have been set for the CUDA array.\n Any CUDA array previously bound to `hSurfRef` is unbound.\n#### hSurfRef:\n- Surface reference handle\n#### hArray:\n- CUDA array handle\n#### Flags:\n- set to 0\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuModuleGetSurfRef](crate::ffi::cuModuleGetSurfRef),\n [cuSurfRefGetArray](crate::ffi::cuSurfRefGetArray)\n"]
    pub fn cuSurfRefSetArray(
        hSurfRef: CUsurfref,
        hArray: CUarray,
        Flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Passes back the CUDA array bound to a surface reference.\n\n \\deprecated\n\n Returns in `*phArray` the CUDA array bound to the surface reference\n `hSurfRef`, or returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if the surface reference\n is not bound to any CUDA array.\n#### phArray:\n- Surface reference handle\n#### hSurfRef:\n- Surface reference handle\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n [cuModuleGetSurfRef](crate::ffi::cuModuleGetSurfRef), [cuSurfRefSetArray](crate::ffi::cuSurfRefSetArray)\n"]
    pub fn cuSurfRefGetArray(phArray: *mut CUarray, hSurfRef: CUsurfref) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a texture object\n\n Creates a texture object and returns it in `pTexObject`. `pResDesc` describes\n the data to texture from. `pTexDesc` describes how the data should be sampled.\n `pResViewDesc` is an optional argument that specifies an alternate format for\n the data described by `pResDesc`, and also describes the subresource region\n to restrict access to when texturing. `pResViewDesc` can only be specified if\n the type of resource is a CUDA array or a CUDA mipmapped array not in a block\n compressed format.\n\n Texture objects are only supported on devices of compute capability 3.0 or higher.\n Additionally, a texture object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n The [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC) structure is defined as:\n \\code\ntypedef struct CUDA_RESOURCE_DESC_st\n{\nCUresourcetype resType;\n\nunion {\nstruct {\nCUarray hArray;\n} array;\nstruct {\nCUmipmappedArray hMipmappedArray;\n} mipmap;\nstruct {\nCUdeviceptr devPtr;\nCUarray_format format;\nunsigned int numChannels;\nsize_t sizeInBytes;\n} linear;\nstruct {\nCUdeviceptr devPtr;\nCUarray_format format;\nunsigned int numChannels;\nsize_t width;\nsize_t height;\nsize_t pitchInBytes;\n} pitch2D;\n} res;\n\nunsigned int flags;\n} CUDA_RESOURCE_DESC;\n\n \\endcode\n where:\n - [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) specifies the type of resource to texture from.\n CUresourceType is defined as:\n \\code\ntypedef enum CUresourcetype_enum {\nCU_RESOURCE_TYPE_ARRAY           = 0x00,\nCU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01,\nCU_RESOURCE_TYPE_LINEAR          = 0x02,\nCU_RESOURCE_TYPE_PITCH2D         = 0x03\n} CUresourcetype;\n \\endcode\n\n `ar`\n If [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) is set to [CU_RESOURCE_TYPE_ARRAY](crate::ffi::CU_RESOURCE_TYPE_ARRAY), [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[array](crate::ffi::array)[hArray](crate::ffi::hArray)\n must be set to a valid CUDA array handle.\n\n `ar`\n If [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) is set to [CU_RESOURCE_TYPE_MIPMAPPED_ARRAY](crate::ffi::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY), [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[mipmap](crate::ffi::mipmap)[hMipmappedArray](crate::ffi::hMipmappedArray)\n must be set to a valid CUDA mipmapped array handle.\n\n `ar`\n If [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) is set to [CU_RESOURCE_TYPE_LINEAR](crate::ffi::CU_RESOURCE_TYPE_LINEAR), [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[linear](crate::ffi::linear)[devPtr](crate::ffi::devPtr)\n must be set to a valid device pointer, that is aligned to [CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT](crate::ffi::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT).\n [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[linear](crate::ffi::linear)[format](crate::ffi::format) and [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[linear](crate::ffi::linear)[numChannels](crate::ffi::numChannels)\n describe the format of each component and the number of components per array element. [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[linear](crate::ffi::linear)[sizeInBytes](crate::ffi::sizeInBytes)\n specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed\n [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH). The number of elements is computed as (sizeInBytes / (sizeof(format) * numChannels)).\n\n `ar`\n If [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) is set to [CU_RESOURCE_TYPE_PITCH2D](crate::ffi::CU_RESOURCE_TYPE_PITCH2D), [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[pitch2D](crate::ffi::pitch2D)[devPtr](crate::ffi::devPtr)\n must be set to a valid device pointer, that is aligned to [CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT](crate::ffi::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT).\n [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[pitch2D](crate::ffi::pitch2D)[format](crate::ffi::format) and [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[pitch2D](crate::ffi::pitch2D)[numChannels](crate::ffi::numChannels)\n describe the format of each component and the number of components per array element. [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[pitch2D](crate::ffi::pitch2D)[width](crate::ffi::width)\n and [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[pitch2D](crate::ffi::pitch2D)[height](crate::ffi::height) specify the width and height of the array in elements, and cannot exceed\n [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH) and [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT) respectively.\n [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[pitch2D](crate::ffi::pitch2D)[pitchInBytes](crate::ffi::pitchInBytes) specifies the pitch between two rows in bytes and has to be aligned to\n [CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT](crate::ffi::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT). Pitch cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH](crate::ffi::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH).\n\n - [flags](crate::ffi::flags) must be set to zero.\n\n\n The [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC) struct is defined as\n \\code\ntypedef struct CUDA_TEXTURE_DESC_st {\nCUaddress_mode addressMode[3];\nCUfilter_mode filterMode;\nunsigned int flags;\nunsigned int maxAnisotropy;\nCUfilter_mode mipmapFilterMode;\nfloat mipmapLevelBias;\nfloat minMipmapLevelClamp;\nfloat maxMipmapLevelClamp;\n} CUDA_TEXTURE_DESC;\n \\endcode\n where\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[addressMode](crate::ffi::addressMode) specifies the addressing mode for each dimension of the texture data. [CUaddress_mode](crate::ffi::CUaddress_mode) is defined as:\n   \\code\ntypedef enum CUaddress_mode_enum {\nCU_TR_ADDRESS_MODE_WRAP = 0,\nCU_TR_ADDRESS_MODE_CLAMP = 1,\nCU_TR_ADDRESS_MODE_MIRROR = 2,\nCU_TR_ADDRESS_MODE_BORDER = 3\n} CUaddress_mode;\n   \\endcode\n   This is ignored if [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) is [CU_RESOURCE_TYPE_LINEAR](crate::ffi::CU_RESOURCE_TYPE_LINEAR). Also, if the flag, [CU_TRSF_NORMALIZED_COORDINATES](crate::ffi::CU_TRSF_NORMALIZED_COORDINATES)\n   is not set, the only supported address mode is [CU_TR_ADDRESS_MODE_CLAMP](crate::ffi::CU_TR_ADDRESS_MODE_CLAMP).\n\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[filterMode](crate::ffi::filterMode) specifies the filtering mode to be used when fetching from the texture. CUfilter_mode is defined as:\n   \\code\ntypedef enum CUfilter_mode_enum {\nCU_TR_FILTER_MODE_POINT = 0,\nCU_TR_FILTER_MODE_LINEAR = 1\n} CUfilter_mode;\n   \\endcode\n   This is ignored if [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) is [CU_RESOURCE_TYPE_LINEAR](crate::ffi::CU_RESOURCE_TYPE_LINEAR).\n\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[flags](crate::ffi::flags) can be any combination of the following:\n   - [CU_TRSF_READ_AS_INTEGER](crate::ffi::CU_TRSF_READ_AS_INTEGER), which suppresses the default behavior of\n   having the texture promote integer data to floating point data in the\n   range [0, 1]. Note that texture with 32-bit integer format would not be\n   promoted, regardless of whether or not this flag is specified.\n   - [CU_TRSF_NORMALIZED_COORDINATES](crate::ffi::CU_TRSF_NORMALIZED_COORDINATES), which suppresses the default behavior\n   of having the texture coordinates range from [0, Dim) where Dim is the\n   width or height of the CUDA array. Instead, the texture coordinates\n   [0, 1.0) reference the entire breadth of the array dimension; Note that\n   for CUDA mipmapped arrays, this flag has to be set.\n   - [CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION](crate::ffi::CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION), which disables any trilinear\n   filtering optimizations. Trilinear optimizations improve texture filtering\n   performance by allowing bilinear filtering on textures in scenarios where\n   it can closely approximate the expected results.\n   - [CU_TRSF_SEAMLESS_CUBEMAP](crate::ffi::CU_TRSF_SEAMLESS_CUBEMAP), which enables seamless cube map filtering.\n   This flag can only be specified if the underlying resource is a CUDA array\n   or a CUDA mipmapped array that was created with the flag [CUDA_ARRAY3D_CUBEMAP](crate::ffi::CUDA_ARRAY3D_CUBEMAP).\n   When seamless cube map filtering is enabled, texture address modes specified\n   by [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[addressMode](crate::ffi::addressMode) are ignored. Instead, if the [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[filterMode](crate::ffi::filterMode)\n   is set to [CU_TR_FILTER_MODE_POINT](crate::ffi::CU_TR_FILTER_MODE_POINT) the address mode [CU_TR_ADDRESS_MODE_CLAMP](crate::ffi::CU_TR_ADDRESS_MODE_CLAMP)\n   will be applied for all dimensions. If the [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[filterMode](crate::ffi::filterMode) is\n   set to [CU_TR_FILTER_MODE_LINEAR](crate::ffi::CU_TR_FILTER_MODE_LINEAR) seamless cube map filtering will be performed\n   when sampling along the cube face borders.\n\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[maxAnisotropy](crate::ffi::maxAnisotropy) specifies the maximum anisotropy ratio to be used when doing anisotropic filtering. This value will be\n   clamped to the range [1,16].\n\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[mipmapFilterMode](crate::ffi::mipmapFilterMode) specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels.\n\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[mipmapLevelBias](crate::ffi::mipmapLevelBias) specifies the offset to be applied to the calculated mipmap level.\n\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[minMipmapLevelClamp](crate::ffi::minMipmapLevelClamp) specifies the lower end of the mipmap level range to clamp access to.\n\n - [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[maxMipmapLevelClamp](crate::ffi::maxMipmapLevelClamp) specifies the upper end of the mipmap level range to clamp access to.\n\n\n The [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC) struct is defined as\n \\code\ntypedef struct CUDA_RESOURCE_VIEW_DESC_st\n{\nCUresourceViewFormat format;\nsize_t width;\nsize_t height;\nsize_t depth;\nunsigned int firstMipmapLevel;\nunsigned int lastMipmapLevel;\nunsigned int firstLayer;\nunsigned int lastLayer;\n} CUDA_RESOURCE_VIEW_DESC;\n \\endcode\n where:\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[format](crate::ffi::format) specifies how the data contained in the CUDA array or CUDA mipmapped array should\n   be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block\n   compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a base of format [CU_AD_FORMAT_UNSIGNED_INT32](crate::ffi::CU_AD_FORMAT_UNSIGNED_INT32).\n   with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have\n   a format of [CU_AD_FORMAT_UNSIGNED_INT32](crate::ffi::CU_AD_FORMAT_UNSIGNED_INT32) with 2 channels. The other BC formats require the underlying resource to have the same base\n   format but with 4 channels.\n\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[width](crate::ffi::width) specifies the new width of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[height](crate::ffi::height) specifies the new height of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[depth](crate::ffi::depth) specifies the new depth of the texture data. This value has to be equal to that of the\n   original resource.\n\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[firstMipmapLevel](crate::ffi::firstMipmapLevel) specifies the most detailed mipmap level. This will be the new mipmap level zero.\n   For non-mipmapped resources, this value has to be zero.[CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[minMipmapLevelClamp](crate::ffi::minMipmapLevelClamp) and [CUDA_TEXTURE_DESC](crate::ffi::CUDA_TEXTURE_DESC)[maxMipmapLevelClamp](crate::ffi::maxMipmapLevelClamp)\n   will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified,\n   then the actual minimum mipmap level clamp will be 3.2.\n\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[lastMipmapLevel](crate::ffi::lastMipmapLevel) specifies the least detailed mipmap level. For non-mipmapped resources, this value\n   has to be zero.\n\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[firstLayer](crate::ffi::firstLayer) specifies the first layer index for layered textures. This will be the new layer zero.\n   For non-layered resources, this value has to be zero.\n\n - [CUDA_RESOURCE_VIEW_DESC](crate::ffi::CUDA_RESOURCE_VIEW_DESC)[lastLayer](crate::ffi::lastLayer) specifies the last layer index for layered textures. For non-layered resources,\n   this value has to be zero.\n#### pTexObject:\n- Texture object to create\n#### pResDesc:\n- Resource descriptor\n#### pTexDesc:\n- Texture descriptor\n#### pResViewDesc:\n- Resource view descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexObjectDestroy](crate::ffi::cuTexObjectDestroy),\n [cudaCreateTextureObject](crate::ffi::cudaCreateTextureObject)\n"]
    pub fn cuTexObjectCreate(
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a texture object\n\n Destroys the texture object specified by `texObject`.\n#### texObject:\n- Texture object to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexObjectCreate](crate::ffi::cuTexObjectCreate),\n [cudaDestroyTextureObject](crate::ffi::cudaDestroyTextureObject)\n"]
    pub fn cuTexObjectDestroy(texObject: CUtexObject) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a texture object's resource descriptor\n\n Returns the resource descriptor for the texture object specified by `texObject`.\n#### pResDesc:\n- Resource descriptor\n#### texObject:\n- Texture object\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexObjectCreate](crate::ffi::cuTexObjectCreate),\n [cudaGetTextureObjectResourceDesc](crate::ffi::cudaGetTextureObjectResourceDesc),\n"]
    pub fn cuTexObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a texture object's texture descriptor\n\n Returns the texture descriptor for the texture object specified by `texObject`.\n#### pTexDesc:\n- Texture descriptor\n#### texObject:\n- Texture object\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexObjectCreate](crate::ffi::cuTexObjectCreate),\n [cudaGetTextureObjectTextureDesc](crate::ffi::cudaGetTextureObjectTextureDesc)\n"]
    pub fn cuTexObjectGetTextureDesc(
        pTexDesc: *mut CUDA_TEXTURE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a texture object's resource view descriptor\n\n Returns the resource view descriptor for the texture object specified by `texObject`.\n If no resource view was set for `texObject`, the [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n#### pResViewDesc:\n- Resource view descriptor\n#### texObject:\n- Texture object\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTexObjectCreate](crate::ffi::cuTexObjectCreate),\n [cudaGetTextureObjectResourceViewDesc](crate::ffi::cudaGetTextureObjectResourceViewDesc)\n"]
    pub fn cuTexObjectGetResourceViewDesc(
        pResViewDesc: *mut CUDA_RESOURCE_VIEW_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Creates a surface object\n\n Creates a surface object and returns it in `pSurfObject`. `pResDesc` describes\n the data to perform surface load/stores on. [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[resType](crate::ffi::resType) must be\n [CU_RESOURCE_TYPE_ARRAY](crate::ffi::CU_RESOURCE_TYPE_ARRAY) and  [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[res](crate::ffi::res)[array](crate::ffi::array)[hArray](crate::ffi::hArray)\n must be set to a valid CUDA array handle. [CUDA_RESOURCE_DESC](crate::ffi::CUDA_RESOURCE_DESC)[flags](crate::ffi::flags) must be set to zero.\n\n Surface objects are only supported on devices of compute capability 3.0 or higher.\n Additionally, a surface object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n#### pSurfObject:\n- Surface object to create\n#### pResDesc:\n- Resource descriptor\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuSurfObjectDestroy](crate::ffi::cuSurfObjectDestroy),\n [cudaCreateSurfaceObject](crate::ffi::cudaCreateSurfaceObject)\n"]
    pub fn cuSurfObjectCreate(
        pSurfObject: *mut CUsurfObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a surface object\n\n Destroys the surface object specified by `surfObject`.\n#### surfObject:\n- Surface object to destroy\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuSurfObjectCreate](crate::ffi::cuSurfObjectCreate),\n [cudaDestroySurfaceObject](crate::ffi::cudaDestroySurfaceObject)\n"]
    pub fn cuSurfObjectDestroy(surfObject: CUsurfObject) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns a surface object's resource descriptor\n\n Returns the resource descriptor for the surface object specified by `surfObject`.\n#### pResDesc:\n- Resource descriptor\n#### surfObject:\n- Surface object\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuSurfObjectCreate](crate::ffi::cuSurfObjectCreate),\n [cudaGetSurfaceObjectResourceDesc](crate::ffi::cudaGetSurfaceObjectResourceDesc)\n"]
    pub fn cuSurfObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        surfObject: CUsurfObject,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a tensor map descriptor object representing tiled memory region\n\n Creates a descriptor for Tensor Memory Access (TMA) object specified\n by the parameters describing a tiled region and returns it in `tensorMap`.\n\n Tensor map objects are only supported on devices of compute capability 9.0 or higher.\n Additionally, a tensor map object is an opaque value, and, as such, should only be\n accessed through CUDA APIs and PTX.\n\n The parameters passed are bound to the following requirements:\n\n - `tensorMap` address must be aligned to 64 bytes.\n\n - `tensorDataType` has to be an enum from [CUtensorMapDataType](crate::ffi::CUtensorMapDataType) which is defined as:\n \\code\ntypedef enum CUtensorMapDataType_enum {\nCU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte\nCU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ,    // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B,    // 4 bits\nCU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B,   // 4 bits\nCU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B    // 6 bits\n} CUtensorMapDataType;\n \\endcode\n  [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B) copies '16 x U4' packed values to memory aligned as 8 bytes. There are no gaps between packed values.\n  [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B) copies '16 x U4' packed values to memory aligned as 16 bytes. There are 8 byte gaps between every 8 byte chunk of packed values.\n  [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) copies '16 x U6' packed values to memory aligned as 16 bytes. There are 4 byte gaps between every 12 byte chunk of packed values.\n\n - `tensorRank` must be non-zero and less than or equal to the maximum supported dimensionality of 5. If `interleave` is not\n [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE), then `tensorRank` must additionally be greater than or equal to 3.\n\n - `globalAddress`, which specifies the starting address of the memory region described, must be 16 byte aligned. The following requirements need to also be met:\n    - When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), `globalAddress` must be 32 byte aligned.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), `globalAddress` must be 32 byte aligned.\n\n - `globalDim` array, which specifies tensor size of each of the `tensorRank` dimensions, must be non-zero and less than or\n equal to 2^32. Additionally, the following requirements need to be met for the packed data types:\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), globalDim[0] must be a multiple of 128.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B), `globalDim`[0] must be a multiple of 2.\n    - Dimension for the packed data types must reflect the number of individual U# values.\n\n - `globalStrides` array, which specifies tensor stride of each of the lower `tensorRank` - 1 dimensions in bytes, must be a\n multiple of 16 and less than 2^40. Additionally, the following requirements need to be met:\n    - When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), the strides must be a multiple of 32.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), the strides must be a multiple of 32.\n Each following dimension specified includes previous dimension stride:\n \\code\nglobalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];\nfor (i = 1; i < tensorRank - 1; i++)\nglobalStrides[i] = globalStrides[i  1] * (globalDim[i] + padding[i]);\nassert(globalStrides[i] >= globalDim[i]);\n \\endcode\n\n - `boxDim` array, which specifies number of elements to be traversed along each of the `tensorRank` dimensions, must be non-zero\n and less than or equal to 256. Additionally, the following requirements need to be met:\n    - When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE), { `boxDim`[0] * elementSizeInBytes( `tensorDataType` ) } must be a multiple of 16 bytes.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), boxDim[0] must be 128.\n\n - `elementStrides` array, which specifies the iteration step along each of the `tensorRank` dimensions, must be non-zero and less\n than or equal to 8. Note that when `interleave` is [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE), the first element of this array is ignored since\n TMA doesnt support the stride for dimension zero.\n When all elements of `elementStrides` array is one, `boxDim` specifies the number of elements to load. However, if the `elementStrides`[i]\n is not equal to one, then TMA loads ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along i-th dimension. To load N elements along\n i-th dimension, `boxDim`[i] must be set to N * `elementStrides`[i].\n\n - `interleave` specifies the interleaved layout of type [CUtensorMapInterleave](crate::ffi::CUtensorMapInterleave), which is defined as:\n \\code\ntypedef enum CUtensorMapInterleave_enum {\nCU_TENSOR_MAP_INTERLEAVE_NONE = 0,\nCU_TENSOR_MAP_INTERLEAVE_16B,\nCU_TENSOR_MAP_INTERLEAVE_32B\n} CUtensorMapInterleave;\n \\endcode\n TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16\n uses 32 bytes.\n When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE) and `swizzle` is not [CU_TENSOR_MAP_SWIZZLE_NONE](crate::ffi::CU_TENSOR_MAP_SWIZZLE_NONE), the bounding box inner dimension\n (computed as `boxDim`[0] multiplied by element size derived from `tensorDataType`) must be less than or equal to the swizzle size.\n    - CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension to be <= 32.\n    - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension to be <= 64.\n    - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner dimension to be <= 128.\n Additionally, `tensorDataType` of [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) requires `interleave` to be [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE).\n\n - `swizzle`, which specifies the shared memory bank swizzling pattern, has to be of type [CUtensorMapSwizzle](crate::ffi::CUtensorMapSwizzle) which is defined as:\n \\code\ntypedef enum CUtensorMapSwizzle_enum {\nCU_TENSOR_MAP_SWIZZLE_NONE = 0,\nCU_TENSOR_MAP_SWIZZLE_32B,                   // Swizzle 16B chunks within 32B  span\nCU_TENSOR_MAP_SWIZZLE_64B,                   // Swizzle 16B chunks within 64B  span\nCU_TENSOR_MAP_SWIZZLE_128B,                  // Swizzle 16B chunks within 128B span\nCU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B,         // Swizzle 32B chunks within 128B span\nCU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B, // Swizzle 32B chunks within 128B span, additionally swap lower 8B with upper 8B within each 16B for every alternate row\nCU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B          // Swizzle 64B chunks within 128B span\n} CUtensorMapSwizzle;\n \\endcode\n Data are organized in a specific order in global memory; however, this may not match the order in which the application accesses data\n in shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this\n problem, data can be loaded to shared memory with shuffling across shared memory banks.\n When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), `swizzle` must be [CU_TENSOR_MAP_SWIZZLE_32B](crate::ffi::CU_TENSOR_MAP_SWIZZLE_32B).\n Other interleave modes can have any swizzling pattern.\n When the `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B), only the following swizzle modes are supported:\n    - CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)\n    - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only)\n When the `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), only the following swizzle modes are supported:\n    - CU_TENSOR_MAP_SWIZZLE_NONE (Load only)\n    - CU_TENSOR_MAP_SWIZZLE_128B (Load only)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)\n\n - `l2Promotion` specifies L2 fetch size which indicates the byte granurality at which L2 requests is filled from DRAM. It must be of\n type [CUtensorMapL2promotion](crate::ffi::CUtensorMapL2promotion), which is defined as:\n \\code\ntypedef enum CUtensorMapL2promotion_enum {\nCU_TENSOR_MAP_L2_PROMOTION_NONE = 0,\nCU_TENSOR_MAP_L2_PROMOTION_L2_64B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_128B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_256B\n} CUtensorMapL2promotion;\n \\endcode\n\n - `oobFill`, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type\n [CUtensorMapFloatOOBfill](crate::ffi::CUtensorMapFloatOOBfill) which is defined as:\n \\code\ntypedef enum CUtensorMapFloatOOBfill_enum {\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA\n} CUtensorMapFloatOOBfill;\n \\endcode\n Note that [CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA](crate::ffi::CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA) can only be used when `tensorDataType` represents a floating-point data type,\n and when `tensorDataType` is not [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B), [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), and [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B).\n#### tensorMap:\n- Tensor map object to create\n#### tensorDataType:\n- Tensor data type\n#### tensorRank:\n- Dimensionality of tensor\n#### globalAddress:\n- Starting address of memory region described by tensor\n#### globalDim:\n- Array containing tensor size (number of elements) along each of the `tensorRank` dimensions\n#### globalStrides:\n- Array containing stride size (in bytes) along each of the `tensorRank` - 1 dimensions\n#### boxDim:\n- Array containing traversal box size (number of elments) along each of the `tensorRank` dimensions. Specifies how many elements to be traversed along each tensor dimension.\n#### elementStrides:\n- Array containing traversal stride in each of the `tensorRank` dimensions\n#### interleave:\n- Type of interleaved layout the tensor addresses\n#### swizzle:\n- Bank swizzling pattern inside shared memory\n#### l2Promotion:\n- L2 promotion size\n#### oobFill:\n- Indicate whether zero or special NaN constant must be used to fill out-of-bound elements\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTensorMapEncodeIm2col](crate::ffi::cuTensorMapEncodeIm2col),\n [cuTensorMapEncodeIm2colWide](crate::ffi::cuTensorMapEncodeIm2colWide),\n [cuTensorMapReplaceAddress](crate::ffi::cuTensorMapReplaceAddress)\n"]
    pub fn cuTensorMapEncodeTiled(
        tensorMap: *mut CUtensorMap,
        tensorDataType: CUtensorMapDataType,
        tensorRank: cuuint32_t,
        globalAddress: *mut ::std::ffi::c_void,
        globalDim: *const cuuint64_t,
        globalStrides: *const cuuint64_t,
        boxDim: *const cuuint32_t,
        elementStrides: *const cuuint32_t,
        interleave: CUtensorMapInterleave,
        swizzle: CUtensorMapSwizzle,
        l2Promotion: CUtensorMapL2promotion,
        oobFill: CUtensorMapFloatOOBfill,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a tensor map descriptor object representing im2col memory region\n\n Creates a descriptor for Tensor Memory Access (TMA) object specified\n by the parameters describing a im2col memory layout and returns it in `tensorMap`.\n\n Tensor map objects are only supported on devices of compute capability 9.0 or higher.\n Additionally, a tensor map object is an opaque value, and, as such, should only be\n accessed through CUDA APIs and PTX.\n\n The parameters passed are bound to the following requirements:\n\n - `tensorMap` address must be aligned to 64 bytes.\n\n - `tensorDataType` has to be an enum from [CUtensorMapDataType](crate::ffi::CUtensorMapDataType) which is defined as:\n \\code\ntypedef enum CUtensorMapDataType_enum {\nCU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte\nCU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ     // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B,    // 4 bits\nCU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B,   // 4 bits\nCU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B    // 6 bits\n} CUtensorMapDataType;\n \\endcode\n  [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B) copies '16 x U4' packed values to memory aligned as 8 bytes. There are no gaps between packed values.\n  [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B) copies '16 x U4' packed values to memory aligned as 16 bytes. There are 8 byte gaps between every 8 byte chunk of packed values.\n  [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) copies '16 x U6' packed values to memory aligned as 16 bytes. There are 4 byte gaps between every 12 byte chunk of packed values.\n\n - `tensorRank`, which specifies the number of tensor dimensions, must be 3, 4, or 5.\n\n - `globalAddress`, which specifies the starting address of the memory region described, must be 16 byte aligned. The following requirements need to also be met:\n    - When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), `globalAddress` must be 32 byte aligned.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), `globalAddress` must be 32 byte aligned.\n\n - `globalDim` array, which specifies tensor size of each of the `tensorRank` dimensions, must be non-zero and less than or\n equal to 2^32. Additionally, the following requirements need to be met for the packed data types:\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), globalDim[0] must be a multiple of 128.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B), `globalDim`[0] must be a multiple of 2.\n    - Dimension for the packed data types must reflect the number of individual U# values.\n\n - `globalStrides` array, which specifies tensor stride of each of the lower `tensorRank` - 1 dimensions in bytes, must be a\n multiple of 16 and less than 2^40. Additionally, the following requirements need to be met:\n    - When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), the strides must be a multiple of 32.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), the strides must be a multiple of 32.\n Each following dimension specified includes previous dimension stride:\n \\code\nglobalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];\nfor (i = 1; i < tensorRank - 1; i++)\nglobalStrides[i] = globalStrides[i  1] * (globalDim[i] + padding[i]);\nassert(globalStrides[i] >= globalDim[i]);\n \\endcode\n\n - `pixelBoxLowerCorner` array specifies the coordinate offsets {D, H, W} of the bounding box from top/left/front corner. The number of\n offsets and their precision depend on the tensor dimensionality:\n    - When `tensorRank` is 3, one signed offset within range [-32768, 32767] is supported.\n    - When `tensorRank` is 4, two signed offsets each within range [-128, 127] are supported.\n    - When `tensorRank` is 5, three offsets each within range [-16, 15] are supported.\n\n - `pixelBoxUpperCorner` array specifies the coordinate offsets {D, H, W} of the bounding box from bottom/right/back corner. The number of\n offsets and their precision depend on the tensor dimensionality:\n    - When `tensorRank` is 3, one signed offset within range [-32768, 32767] is supported.\n    - When `tensorRank` is 4, two signed offsets each within range [-128, 127] are supported.\n    - When `tensorRank` is 5, three offsets each within range [-16, 15] are supported.\n The bounding box specified by `pixelBoxLowerCorner` and `pixelBoxUpperCorner` must have non-zero area.\n\n - `channelsPerPixel`, which specifies the number of elements which must be accessed along C dimension, must be less than or equal to 256.\n Additionally, when `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), `channelsPerPixel` must be 128.\n\n - `pixelsPerColumn`, which specifies the number of elements that must be accessed along the {N, D, H, W} dimensions, must be less than or\n equal to 1024.\n\n - `elementStrides` array, which specifies the iteration step along each of the `tensorRank` dimensions, must be non-zero and less\n than or equal to 8. Note that when `interleave` is [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE), the first element of this array is ignored since\n TMA doesnt support the stride for dimension zero.\n When all elements of the `elementStrides` array are one, `boxDim` specifies the number of elements to load. However, if `elementStrides`[i]\n is not equal to one for some `i`, then TMA loads ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along i-th dimension.\n To load N elements along i-th dimension, `boxDim`[i] must be set to N * `elementStrides`[i].\n\n - `interleave` specifies the interleaved layout of type [CUtensorMapInterleave](crate::ffi::CUtensorMapInterleave), which is defined as:\n \\code\ntypedef enum CUtensorMapInterleave_enum {\nCU_TENSOR_MAP_INTERLEAVE_NONE = 0,\nCU_TENSOR_MAP_INTERLEAVE_16B,\nCU_TENSOR_MAP_INTERLEAVE_32B\n} CUtensorMapInterleave;\n \\endcode\n TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16\n uses 32 bytes.\n When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE) and `swizzle` is not [CU_TENSOR_MAP_SWIZZLE_NONE](crate::ffi::CU_TENSOR_MAP_SWIZZLE_NONE), the bounding box inner dimension\n (computed as `channelsPerPixel` multiplied by element size in bytes derived from `tensorDataType`) must be less than or equal to the swizzle size.\n    - CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension to be <= 32.\n    - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension to be <= 64.\n    - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner dimension to be <= 128.\n Additionally, `tensorDataType` of [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) requires `interleave` to be [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE).\n\n - `swizzle`, which specifies the shared memory bank swizzling pattern, has to be of type [CUtensorMapSwizzle](crate::ffi::CUtensorMapSwizzle) which is defined as:\n \\code\ntypedef enum CUtensorMapSwizzle_enum {\nCU_TENSOR_MAP_SWIZZLE_NONE = 0,\nCU_TENSOR_MAP_SWIZZLE_32B,                   // Swizzle 16B chunks within 32B  span\nCU_TENSOR_MAP_SWIZZLE_64B,                   // Swizzle 16B chunks within 64B  span\nCU_TENSOR_MAP_SWIZZLE_128B,                  // Swizzle 16B chunks within 128B span\nCU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B,         // Swizzle 32B chunks within 128B span\nCU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B, // Swizzle 32B chunks within 128B span, additionally swap lower 8B with upper 8B within each 16B for every alternate row\nCU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B          // Swizzle 64B chunks within 128B span\n} CUtensorMapSwizzle;\n \\endcode\n Data are organized in a specific order in global memory; however, this may not match the order in which the application accesses data\n in shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this\n problem, data can be loaded to shared memory with shuffling across shared memory banks.\n When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), `swizzle` must be [CU_TENSOR_MAP_SWIZZLE_32B](crate::ffi::CU_TENSOR_MAP_SWIZZLE_32B).\n Other interleave modes can have any swizzling pattern.\n When the `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B), only the following swizzle modes are supported:\n    - CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)\n    - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only)\n When the `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), only the following swizzle modes are supported:\n    - CU_TENSOR_MAP_SWIZZLE_NONE (Load only)\n    - CU_TENSOR_MAP_SWIZZLE_128B (Load only)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)\n\n - `l2Promotion` specifies L2 fetch size which indicates the byte granularity at which L2 requests are filled from DRAM. It must be of\n type [CUtensorMapL2promotion](crate::ffi::CUtensorMapL2promotion), which is defined as:\n \\code\ntypedef enum CUtensorMapL2promotion_enum {\nCU_TENSOR_MAP_L2_PROMOTION_NONE = 0,\nCU_TENSOR_MAP_L2_PROMOTION_L2_64B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_128B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_256B\n} CUtensorMapL2promotion;\n \\endcode\n\n - `oobFill`, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type\n [CUtensorMapFloatOOBfill](crate::ffi::CUtensorMapFloatOOBfill) which is defined as:\n \\code\ntypedef enum CUtensorMapFloatOOBfill_enum {\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA\n} CUtensorMapFloatOOBfill;\n \\endcode\n Note that [CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA](crate::ffi::CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA) can only be used when `tensorDataType` represents a floating-point data type,\n and when `tensorDataType` is not [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B), [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), and [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B).\n#### tensorMap:\n- Tensor map object to create\n#### tensorDataType:\n- Tensor data type\n#### tensorRank:\n- Dimensionality of tensor; must be at least 3\n#### globalAddress:\n- Starting address of memory region described by tensor\n#### globalDim:\n- Array containing tensor size (number of elements) along each of the `tensorRank` dimensions\n#### globalStrides:\n- Array containing stride size (in bytes) along each of the `tensorRank` - 1 dimensions\n#### pixelBoxLowerCorner:\n- Array containing DHW dimensions of lower box corner\n#### pixelBoxUpperCorner:\n- Array containing DHW dimensions of upper box corner\n#### channelsPerPixel:\n- Number of channels per pixel\n#### pixelsPerColumn:\n- Number of pixels per column\n#### elementStrides:\n- Array containing traversal stride in each of the `tensorRank` dimensions\n#### interleave:\n- Type of interleaved layout the tensor addresses\n#### swizzle:\n- Bank swizzling pattern inside shared memory\n#### l2Promotion:\n- L2 promotion size\n#### oobFill:\n- Indicate whether zero or special NaN constant will be used to fill out-of-bound elements\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTensorMapEncodeTiled](crate::ffi::cuTensorMapEncodeTiled),\n [cuTensorMapEncodeIm2colWide](crate::ffi::cuTensorMapEncodeIm2colWide),\n [cuTensorMapReplaceAddress](crate::ffi::cuTensorMapReplaceAddress)\n"]
    pub fn cuTensorMapEncodeIm2col(
        tensorMap: *mut CUtensorMap,
        tensorDataType: CUtensorMapDataType,
        tensorRank: cuuint32_t,
        globalAddress: *mut ::std::ffi::c_void,
        globalDim: *const cuuint64_t,
        globalStrides: *const cuuint64_t,
        pixelBoxLowerCorner: *const ::std::ffi::c_int,
        pixelBoxUpperCorner: *const ::std::ffi::c_int,
        channelsPerPixel: cuuint32_t,
        pixelsPerColumn: cuuint32_t,
        elementStrides: *const cuuint32_t,
        interleave: CUtensorMapInterleave,
        swizzle: CUtensorMapSwizzle,
        l2Promotion: CUtensorMapL2promotion,
        oobFill: CUtensorMapFloatOOBfill,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a tensor map descriptor object representing im2col memory region, but where\n the elements are exclusively loaded along the W dimension.\n\n Creates a descriptor for Tensor Memory Access (TMA) object specified by the parameters\n describing a im2col memory layout and where the row is always loaded along the W dimensuin\n and returns it in `tensorMap`. This assumes the tensor layout in memory is either NDHWC,\n NHWC, or NWC.\n\n This API is only supported on devices of compute capability 10.0 or higher.\n Additionally, a tensor map object is an opaque value, and, as such, should only be\n accessed through CUDA APIs and PTX.\n\n The parameters passed are bound to the following requirements:\n\n - `tensorMap` address must be aligned to 64 bytes.\n\n - `tensorDataType` has to be an enum from [CUtensorMapDataType](crate::ffi::CUtensorMapDataType) which is defined as:\n \\code\ntypedef enum CUtensorMapDataType_enum {\nCU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte\nCU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ     // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B,    // 4 bits\nCU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B,   // 4 bits\nCU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B    // 6 bits\n} CUtensorMapDataType;\n \\endcode\n  [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B) copies '16 x U4' packed values to memory aligned as 8 bytes. There are no gaps between packed values.\n  [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B) copies '16 x U4' packed values to memory aligned as 16 bytes. There are 8 byte gaps between every 8 byte chunk of packed values.\n  [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) copies '16 x U6' packed values to memory aligned as 16 bytes. There are 4 byte gaps between every 12 byte chunk of packed values.\n\n - `tensorRank`, which specifies the number of tensor dimensions, must be 3, 4, or 5.\n\n - `globalAddress`, which specifies the starting address of the memory region described, must be 16 byte aligned. The following requirements need to also be met:\n    - When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), `globalAddress` must be 32 byte aligned.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), `globalAddress` must be 32 byte aligned.\n\n - `globalDim` array, which specifies tensor size of each of the `tensorRank` dimensions, must be non-zero and less than or\n equal to 2^32. Additionally, the following requirements need to be met for the packed data types:\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), globalDim[0] must be a multiple of 128.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B), `globalDim`[0] must be a multiple of 2.\n    - Dimension for the packed data types must reflect the number of individual U# values.\n\n - `globalStrides` array, which specifies tensor stride of each of the lower `tensorRank` - 1 dimensions in bytes, must be a\n multiple of 16 and less than 2^40. Additionally, the following requirements need to be met:\n    - When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_32B](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_32B), the strides must be a multiple of 32.\n    - When `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), the strides must be a multiple of 32.\n Each following dimension specified includes previous dimension stride:\n \\code\nglobalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];\nfor (i = 1; i < tensorRank - 1; i++)\nglobalStrides[i] = globalStrides[i  1] * (globalDim[i] + padding[i]);\nassert(globalStrides[i] >= globalDim[i]);\n \\endcode\n\n - `pixelBoxLowerCornerWidth` specifies the coordinate offset W of the bounding box from left corner. The offset must be\n within range [-32768, 32767].\n\n - `pixelBoxUpperCornerWidth` specifies the coordinate offset W of the bounding box from right corner. The offset must be\n within range [-32768, 32767].\n\n The bounding box specified by `pixelBoxLowerCornerWidth` and `pixelBoxUpperCornerWidth` must have non-zero area. Note\n that the size of the box along D and H dimensions is always equal to one.\n\n - `channelsPerPixel`, which specifies the number of elements which must be accessed along C dimension, must be less than or equal to 256.\n Additionally, when `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) or [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), `channelsPerPixel` must be 128.\n\n - `pixelsPerColumn`, which specifies the number of elements that must be accessed along the W dimension, must be less than or\n equal to 1024. This field is ignored when `mode` is [CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128](crate::ffi::CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128).\n\n - `elementStrides` array, which specifies the iteration step along each of the `tensorRank` dimensions, must be non-zero and less\n than or equal to 8. Note that when `interleave` is [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE), the first element of this array is ignored since\n TMA doesnt support the stride for dimension zero.\n When all elements of the `elementStrides` array are one, `boxDim` specifies the number of elements to load. However, if `elementStrides`[i]\n is not equal to one for some `i`, then TMA loads ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along i-th dimension.\n To load N elements along i-th dimension, `boxDim`[i] must be set to N * `elementStrides`[i].\n\n - `interleave` specifies the interleaved layout of type [CUtensorMapInterleave](crate::ffi::CUtensorMapInterleave), which is defined as:\n \\code\ntypedef enum CUtensorMapInterleave_enum {\nCU_TENSOR_MAP_INTERLEAVE_NONE = 0,\nCU_TENSOR_MAP_INTERLEAVE_16B,\nCU_TENSOR_MAP_INTERLEAVE_32B\n} CUtensorMapInterleave;\n \\endcode\n TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16\n uses 32 bytes.\n When `interleave` is [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE), the bounding box inner dimension (computed as `channelsPerPixel` multiplied by\n element size in bytes derived from `tensorDataType`) must be less than or equal to the swizzle size.\n    - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension to be <= 64.\n    - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner dimension to be <= 128.\n Additionally, `tensorDataType` of [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B) requires `interleave` to be [CU_TENSOR_MAP_INTERLEAVE_NONE](crate::ffi::CU_TENSOR_MAP_INTERLEAVE_NONE).\n\n - `mode`, which describes loading of elements loaded along the W dimension, has to be one of the following [CUtensorMapIm2ColWideMode](crate::ffi::CUtensorMapIm2ColWideMode) types:\n \\code\n          CU_TENSOR_MAP_IM2COL_WIDE_MODE_W,\n          CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128\n \\endcode\n [CU_TENSOR_MAP_IM2COL_WIDE_MODE_W](crate::ffi::CU_TENSOR_MAP_IM2COL_WIDE_MODE_W) allows the number of elements loaded along the W dimension to be specified\n via the `pixelsPerColumn` field.\n\n - `swizzle`, which specifies the shared memory bank swizzling pattern, must be one of the following\n [CUtensorMapSwizzle](crate::ffi::CUtensorMapSwizzle) modes (other swizzle modes are not supported):\n \\code\ntypedef enum CUtensorMapSwizzle_enum {\nCU_TENSOR_MAP_SWIZZLE_64B,                   // Swizzle 16B chunks within 64B  span\nCU_TENSOR_MAP_SWIZZLE_128B,                  // Swizzle 16B chunks within 128B span\nCU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B,         // Swizzle 32B chunks within 128B span\n} CUtensorMapSwizzle;\n \\endcode\n Data are organized in a specific order in global memory; however, this may not match the order in which the application accesses data\n in shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this\n problem, data can be loaded to shared memory with shuffling across shared memory banks.\n When the `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B), only the following swizzle modes are supported:\n    - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)\n When the `tensorDataType` is [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), only the following swizzle modes are supported:\n    - CU_TENSOR_MAP_SWIZZLE_128B (Load only)\n    - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)\n\n - `l2Promotion` specifies L2 fetch size which indicates the byte granularity at which L2 requests are filled from DRAM. It must be of\n type [CUtensorMapL2promotion](crate::ffi::CUtensorMapL2promotion), which is defined as:\n \\code\ntypedef enum CUtensorMapL2promotion_enum {\nCU_TENSOR_MAP_L2_PROMOTION_NONE = 0,\nCU_TENSOR_MAP_L2_PROMOTION_L2_64B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_128B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_256B\n} CUtensorMapL2promotion;\n \\endcode\n\n - `oobFill`, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type\n [CUtensorMapFloatOOBfill](crate::ffi::CUtensorMapFloatOOBfill) which is defined as:\n \\code\ntypedef enum CUtensorMapFloatOOBfill_enum {\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA\n} CUtensorMapFloatOOBfill;\n \\endcode\n Note that [CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA](crate::ffi::CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA) can only be used when `tensorDataType` represents a floating-point data type,\n and when `tensorDataType` is not [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B), [CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B), and [CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B](crate::ffi::CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B).\n#### tensorMap:\n- Tensor map object to create\n#### tensorDataType:\n- Tensor data type\n#### tensorRank:\n- Dimensionality of tensor; must be at least 3\n#### globalAddress:\n- Starting address of memory region described by tensor\n#### globalDim:\n- Array containing tensor size (number of elements) along each of the `tensorRank` dimensions\n#### globalStrides:\n- Array containing stride size (in bytes) along each of the `tensorRank` - 1 dimensions\n#### pixelBoxLowerCornerWidth:\n- Width offset of left box corner\n#### pixelBoxUpperCornerWidth:\n- Width offset of right box corner\n#### channelsPerPixel:\n- Number of channels per pixel\n#### pixelsPerColumn:\n- Number of pixels per column\n#### elementStrides:\n- Array containing traversal stride in each of the `tensorRank` dimensions\n#### interleave:\n- Type of interleaved layout the tensor addresses\n#### mode:\n- W or W128 mode\n#### swizzle:\n- Bank swizzling pattern inside shared memory\n#### l2Promotion:\n- L2 promotion size\n#### oobFill:\n- Indicate whether zero or special NaN constant will be used to fill out-of-bound elements\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTensorMapEncodeTiled](crate::ffi::cuTensorMapEncodeTiled),\n [cuTensorMapEncodeIm2col](crate::ffi::cuTensorMapEncodeIm2col),\n [cuTensorMapReplaceAddress](crate::ffi::cuTensorMapReplaceAddress)\n"]
    pub fn cuTensorMapEncodeIm2colWide(
        tensorMap: *mut CUtensorMap,
        tensorDataType: CUtensorMapDataType,
        tensorRank: cuuint32_t,
        globalAddress: *mut ::std::ffi::c_void,
        globalDim: *const cuuint64_t,
        globalStrides: *const cuuint64_t,
        pixelBoxLowerCornerWidth: ::std::ffi::c_int,
        pixelBoxUpperCornerWidth: ::std::ffi::c_int,
        channelsPerPixel: cuuint32_t,
        pixelsPerColumn: cuuint32_t,
        elementStrides: *const cuuint32_t,
        interleave: CUtensorMapInterleave,
        mode: CUtensorMapIm2ColWideMode,
        swizzle: CUtensorMapSwizzle,
        l2Promotion: CUtensorMapL2promotion,
        oobFill: CUtensorMapFloatOOBfill,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Modify an existing tensor map descriptor with an updated global address\n\n Modifies the descriptor for Tensor Memory Access (TMA) object passed in `tensorMap` with\n an updated `globalAddress`.\n\n Tensor map objects are only supported on devices of compute capability 9.0 or higher.\n Additionally, a tensor map object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n#### tensorMap:\n- Tensor map object to modify\n#### globalAddress:\n- Starting address of memory region described by tensor, must follow previous alignment requirements\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuTensorMapEncodeTiled](crate::ffi::cuTensorMapEncodeTiled),\n [cuTensorMapEncodeIm2col](crate::ffi::cuTensorMapEncodeIm2col)\n [cuTensorMapEncodeIm2colWide](crate::ffi::cuTensorMapEncodeIm2colWide)\n"]
    pub fn cuTensorMapReplaceAddress(
        tensorMap: *mut CUtensorMap,
        globalAddress: *mut ::std::ffi::c_void,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Queries if a device may directly access a peer device's memory.\n\n Returns in `*canAccessPeer` a value of 1 if contexts on `dev` are capable of\n directly accessing memory from contexts on `peerDev` and 0 otherwise.\n If direct access of `peerDev` from `dev` is possible, then access may be\n enabled on two specific contexts by calling [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess)().\n#### canAccessPeer:\n- Returned access capability\n#### dev:\n- Device from which allocations on `peerDev` are to\n                        be directly accessed.\n#### peerDev:\n- Device on which the allocations to be directly accessed\n                        by `dev` reside.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess),\n [cuCtxDisablePeerAccess](crate::ffi::cuCtxDisablePeerAccess),\n [cudaDeviceCanAccessPeer](crate::ffi::cudaDeviceCanAccessPeer)\n"]
    pub fn cuDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::ffi::c_int,
        dev: CUdevice,
        peerDev: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Enables direct access to memory allocations in a peer context.\n\n If both the current context and `peerContext` are on devices which support unified\n addressing (as may be queried using [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](crate::ffi::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING)) and same\n major compute capability, then on success all allocations from `peerContext` will\n immediately be accessible by the current context.  See \\ref CUDA_UNIFIED for additional\n details.\n\n Note that access granted by this call is unidirectional and that in order to access\n memory from the current context in `peerContext`, a separate symmetric call\n to [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess)() is required.\n\n Note that there are both device-wide and system-wide limitations per system\n configuration, as noted in the CUDA Programming Guide under the section\n \"Peer-to-Peer Memory Access\".\n\n Returns [CUDA_ERROR_PEER_ACCESS_UNSUPPORTED](crate::ffi::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED) if [cuDeviceCanAccessPeer](crate::ffi::cuDeviceCanAccessPeer)() indicates\n that the [CUdevice](crate::ffi::CUdevice) of the current context cannot directly access memory\n from the [CUdevice](crate::ffi::CUdevice) of `peerContext`.\n\n Returns [CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED](crate::ffi::CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED) if direct access of\n `peerContext` from the current context has already been enabled.\n\n Returns [CUDA_ERROR_TOO_MANY_PEERS](crate::ffi::CUDA_ERROR_TOO_MANY_PEERS) if direct peer access is not possible\n because hardware resources required for peer access have been exhausted.\n\n Returns [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) if there is no current context, `peerContext`\n is not a valid context, or if the current context is `peerContext`.\n\n Returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if `Flags` is not 0.\n#### peerContext:\n- Peer context to enable direct access to from the current context\n#### Flags:\n- Reserved for future use and must be set to 0\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED](crate::ffi::CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED),\n [CUDA_ERROR_TOO_MANY_PEERS](crate::ffi::CUDA_ERROR_TOO_MANY_PEERS),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_PEER_ACCESS_UNSUPPORTED](crate::ffi::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceCanAccessPeer](crate::ffi::cuDeviceCanAccessPeer),\n [cuCtxDisablePeerAccess](crate::ffi::cuCtxDisablePeerAccess),\n [cudaDeviceEnablePeerAccess](crate::ffi::cudaDeviceEnablePeerAccess)\n"]
    pub fn cuCtxEnablePeerAccess(peerContext: CUcontext, Flags: ::std::ffi::c_uint) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Disables direct access to memory allocations in a peer context and\n unregisters any registered allocations.\n\nReturns [CUDA_ERROR_PEER_ACCESS_NOT_ENABLED](crate::ffi::CUDA_ERROR_PEER_ACCESS_NOT_ENABLED) if direct peer access has\n not yet been enabled from `peerContext` to the current context.\n\n Returns [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT) if there is no current context, or if\n `peerContext` is not a valid context.\n#### peerContext:\n- Peer context to disable direct access to\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_PEER_ACCESS_NOT_ENABLED](crate::ffi::CUDA_ERROR_PEER_ACCESS_NOT_ENABLED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuDeviceCanAccessPeer](crate::ffi::cuDeviceCanAccessPeer),\n [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess),\n [cudaDeviceDisablePeerAccess](crate::ffi::cudaDeviceDisablePeerAccess)\n"]
    pub fn cuCtxDisablePeerAccess(peerContext: CUcontext) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Queries attributes of the link between two devices.\n\n Returns in `*value` the value of the requested attribute `attrib` of the\n link between `srcDevice` and `dstDevice`. The supported attributes are:\n - [CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK](crate::ffi::CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK): A relative value indicating the\n   performance of the link between two devices.\n - [CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED](crate::ffi::CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED) P2P: 1 if P2P Access is enable.\n - [CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED](crate::ffi::CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED): 1 if Atomic operations over\n   the link are supported.\n - [CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED](crate::ffi::CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED): 1 if cudaArray can\n   be accessed over the link.\n\n Returns [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE) if `srcDevice` or `dstDevice` are not valid\n or if they represent the same device.\n\n Returns [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) if `attrib` is not valid or if `value` is\n a null pointer.\n#### value:\n- Returned value of the requested attribute\n#### attrib:\n- The requested attribute of the link between `srcDevice` and `dstDevice`.\n#### srcDevice:\n- The source device of the target link.\n#### dstDevice:\n- The destination device of the target link.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuCtxEnablePeerAccess](crate::ffi::cuCtxEnablePeerAccess),\n [cuCtxDisablePeerAccess](crate::ffi::cuCtxDisablePeerAccess),\n [cuDeviceCanAccessPeer](crate::ffi::cuDeviceCanAccessPeer),\n [cudaDeviceGetP2PAttribute](crate::ffi::cudaDeviceGetP2PAttribute)\n"]
    pub fn cuDeviceGetP2PAttribute(
        value: *mut ::std::ffi::c_int,
        attrib: CUdevice_P2PAttribute,
        srcDevice: CUdevice,
        dstDevice: CUdevice,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unregisters a graphics resource for access by CUDA\n\n Unregisters the graphics resource `resource` so it is not accessible by\n CUDA unless registered again.\n\n If `resource` is invalid then [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is\n returned.\n#### resource:\n- Resource to unregister\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphicsD3D9RegisterResource](crate::ffi::cuGraphicsD3D9RegisterResource),\n [cuGraphicsD3D10RegisterResource](crate::ffi::cuGraphicsD3D10RegisterResource),\n [cuGraphicsD3D11RegisterResource](crate::ffi::cuGraphicsD3D11RegisterResource),\n [cuGraphicsGLRegisterBuffer](crate::ffi::cuGraphicsGLRegisterBuffer),\n [cuGraphicsGLRegisterImage](crate::ffi::cuGraphicsGLRegisterImage),\n [cudaGraphicsUnregisterResource](crate::ffi::cudaGraphicsUnregisterResource)\n"]
    pub fn cuGraphicsUnregisterResource(resource: CUgraphicsResource) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get an array through which to access a subresource of a mapped graphics resource.\n\n Returns in `*pArray` an array through which the subresource of the mapped\n graphics resource `resource` which corresponds to array index `arrayIndex`\n and mipmap level `mipLevel` may be accessed.  The value set in `*pArray` may\n change every time that `resource` is mapped.\n\n If `resource` is not a texture then it cannot be accessed via an array and\n [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](crate::ffi::CUDA_ERROR_NOT_MAPPED_AS_ARRAY) is returned.\n If `arrayIndex` is not a valid array index for `resource` then\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n If `mipLevel` is not a valid mipmap level for `resource` then\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n If `resource` is not mapped then [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED) is returned.\n#### pArray:\n- Returned array through which a subresource of `resource` may be accessed\n#### resource:\n- Mapped resource to access\n#### arrayIndex:\n- Array index for array textures or cubemap face\n                      index as defined by [CUarray_cubemap_face](crate::ffi::CUarray_cubemap_face) for\n                      cubemap textures for the subresource to access\n#### mipLevel:\n- Mipmap level for the subresource to access\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED),\n [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](crate::ffi::CUDA_ERROR_NOT_MAPPED_AS_ARRAY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphicsResourceGetMappedPointer](crate::ffi::cuGraphicsResourceGetMappedPointer),\n [cudaGraphicsSubResourceGetMappedArray](crate::ffi::cudaGraphicsSubResourceGetMappedArray)\n"]
    pub fn cuGraphicsSubResourceGetMappedArray(
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::std::ffi::c_uint,
        mipLevel: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get a mipmapped array through which to access a mapped graphics resource.\n\n Returns in `*pMipmappedArray` a mipmapped array through which the mapped graphics\n resource `resource`. The value set in `*pMipmappedArray` may change every time\n that `resource` is mapped.\n\n If `resource` is not a texture then it cannot be accessed via a mipmapped array and\n [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](crate::ffi::CUDA_ERROR_NOT_MAPPED_AS_ARRAY) is returned.\n If `resource` is not mapped then [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED) is returned.\n#### pMipmappedArray:\n- Returned mipmapped array through which `resource` may be accessed\n#### resource:\n- Mapped resource to access\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED),\n [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](crate::ffi::CUDA_ERROR_NOT_MAPPED_AS_ARRAY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphicsResourceGetMappedPointer](crate::ffi::cuGraphicsResourceGetMappedPointer),\n [cudaGraphicsResourceGetMappedMipmappedArray](crate::ffi::cudaGraphicsResourceGetMappedMipmappedArray)\n"]
    pub fn cuGraphicsResourceGetMappedMipmappedArray(
        pMipmappedArray: *mut CUmipmappedArray,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get a device pointer through which to access a mapped graphics resource.\n\n Returns in `*pDevPtr` a pointer through which the mapped graphics resource\n `resource` may be accessed.\n Returns in `pSize` the size of the memory in bytes which may be accessed from that pointer.\n The value set in `pPointer` may change every time that `resource` is mapped.\n\n If `resource` is not a buffer then it cannot be accessed via a pointer and\n [CUDA_ERROR_NOT_MAPPED_AS_POINTER](crate::ffi::CUDA_ERROR_NOT_MAPPED_AS_POINTER) is returned.\n If `resource` is not mapped then [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED) is returned.\n *\n#### pDevPtr:\n- Returned pointer through which `resource` may be accessed\n#### pSize:\n- Returned size of the buffer accessible starting at `*pPointer`\n#### resource:\n- Mapped resource to access\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED),\n [CUDA_ERROR_NOT_MAPPED_AS_POINTER](crate::ffi::CUDA_ERROR_NOT_MAPPED_AS_POINTER)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphicsMapResources](crate::ffi::cuGraphicsMapResources),\n [cuGraphicsSubResourceGetMappedArray](crate::ffi::cuGraphicsSubResourceGetMappedArray),\n [cudaGraphicsResourceGetMappedPointer](crate::ffi::cudaGraphicsResourceGetMappedPointer)\n"]
    pub fn cuGraphicsResourceGetMappedPointer_v2(
        pDevPtr: *mut CUdeviceptr,
        pSize: *mut usize,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Set usage flags for mapping a graphics resource\n\n Set `flags` for mapping the graphics resource `resource`.\n\n Changes to `flags` will take effect the next time `resource` is mapped.\n The `flags` argument may be any of the following:\n\n - [CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE](crate::ffi::CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE): Specifies no hints about how this\n   resource will be used. It is therefore assumed that this resource will be\n   read from and written to by CUDA kernels.  This is the default value.\n - [CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY](crate::ffi::CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY): Specifies that CUDA kernels which\n   access this resource will not write to this resource.\n - [CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD](crate::ffi::CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD): Specifies that CUDA kernels\n   which access this resource will not read from this resource and will\n   write over the entire contents of the resource, so none of the data\n   previously stored in the resource will be preserved.\n\n If `resource` is presently mapped for access by CUDA then\n [CUDA_ERROR_ALREADY_MAPPED](crate::ffi::CUDA_ERROR_ALREADY_MAPPED) is returned.\n If `flags` is not one of the above values then [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE) is returned.\n#### resource:\n- Registered resource to set flags for\n#### flags:\n- Parameters for resource mapping\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_ALREADY_MAPPED](crate::ffi::CUDA_ERROR_ALREADY_MAPPED)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphicsMapResources](crate::ffi::cuGraphicsMapResources),\n [cudaGraphicsResourceSetMapFlags](crate::ffi::cudaGraphicsResourceSetMapFlags)\n"]
    pub fn cuGraphicsResourceSetMapFlags_v2(
        resource: CUgraphicsResource,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Map graphics resources for access by CUDA\n\n Maps the `count` graphics resources in `resources` for access by CUDA.\n\n The resources in `resources` may be accessed by CUDA until they\n are unmapped. The graphics API from which `resources` were registered\n should not access any resources while they are mapped by CUDA. If an\n application does so, the results are undefined.\n\n This function provides the synchronization guarantee that any graphics calls\n issued before [cuGraphicsMapResources](crate::ffi::cuGraphicsMapResources)() will complete before any subsequent CUDA\n work issued in `stream` begins.\n\n If `resources` includes any duplicate entries then [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is returned.\n If any of `resources` are presently mapped for access by CUDA then [CUDA_ERROR_ALREADY_MAPPED](crate::ffi::CUDA_ERROR_ALREADY_MAPPED) is returned.\n#### count:\n- Number of resources to map\n#### resources:\n- Resources to map for CUDA usage\n#### hStream:\n- Stream with which to synchronize\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_ALREADY_MAPPED](crate::ffi::CUDA_ERROR_ALREADY_MAPPED),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphicsResourceGetMappedPointer](crate::ffi::cuGraphicsResourceGetMappedPointer),\n [cuGraphicsSubResourceGetMappedArray](crate::ffi::cuGraphicsSubResourceGetMappedArray),\n [cuGraphicsUnmapResources](crate::ffi::cuGraphicsUnmapResources),\n [cudaGraphicsMapResources](crate::ffi::cudaGraphicsMapResources)\n"]
    pub fn cuGraphicsMapResources(
        count: ::std::ffi::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unmap graphics resources.\n\n Unmaps the `count` graphics resources in `resources`.\n\n Once unmapped, the resources in `resources` may not be accessed by CUDA\n until they are mapped again.\n\n This function provides the synchronization guarantee that any CUDA work issued\n in `stream` before [cuGraphicsUnmapResources](crate::ffi::cuGraphicsUnmapResources)() will complete before any\n subsequently issued graphics work begins.\n\n\n If `resources` includes any duplicate entries then [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is returned.\n If any of `resources` are not presently mapped for access by CUDA then [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED) is returned.\n#### count:\n- Number of resources to unmap\n#### resources:\n- Resources to unmap\n#### hStream:\n- Stream with which to synchronize\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_NOT_MAPPED](crate::ffi::CUDA_ERROR_NOT_MAPPED),\n [CUDA_ERROR_UNKNOWN](crate::ffi::CUDA_ERROR_UNKNOWN)\n### Note:\n This function uses standard [default stream](https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream) semantics.\n\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n\n [cuGraphicsMapResources](crate::ffi::cuGraphicsMapResources),\n [cudaGraphicsUnmapResources](crate::ffi::cudaGraphicsUnmapResources)\n"]
    pub fn cuGraphicsUnmapResources(
        count: ::std::ffi::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the requested driver API function pointer\n\n Returns in `*`*pfn the address of the CUDA driver function for the requested\n CUDA version and flags.\n\n The CUDA version is specified as (1000 * major + 10 * minor), so CUDA 11.2\n should be specified as 11020. For a requested driver symbol, if the specified\n CUDA version is greater than or equal to the CUDA version in which the driver symbol\n was introduced, this API will return the function pointer to the corresponding\n versioned function.\n\n The pointer returned by the API should be cast to a function pointer matching the\n requested driver function's definition in the API header file. The function pointer\n typedef can be picked up from the corresponding typedefs header file. For example,\n cudaTypedefs.h consists of function pointer typedefs for driver APIs defined in cuda.h.\n\n The API will return [CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS) and set the returned `pfn` to NULL if the\n requested driver function is not supported on the platform, no ABI\n compatible driver function exists for the specified `cudaVersion` or if the\n driver symbol is invalid.\n\n It will also set the optional `symbolStatus` to one of the values in\n [CUdriverProcAddressQueryResult](crate::ffi::CUdriverProcAddressQueryResult) with the following meanings:\n - [CU_GET_PROC_ADDRESS_SUCCESS](crate::ffi::CU_GET_PROC_ADDRESS_SUCCESS) - The requested symbol was succesfully found based\n   on input arguments and `pfn` is valid\n - [CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND](crate::ffi::CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND) - The requested symbol was not found\n - [CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT](crate::ffi::CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT) - The requested symbol was found but is\n   not supported by cudaVersion specified\n\n The requested flags can be:\n - [CU_GET_PROC_ADDRESS_DEFAULT](crate::ffi::CU_GET_PROC_ADDRESS_DEFAULT): This is the default mode. This is equivalent to\n   [CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM](crate::ffi::CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM) if the code is compiled with\n   --default-stream per-thread compilation flag or the macro CUDA_API_PER_THREAD_DEFAULT_STREAM\n   is defined; [CU_GET_PROC_ADDRESS_LEGACY_STREAM](crate::ffi::CU_GET_PROC_ADDRESS_LEGACY_STREAM) otherwise.\n - [CU_GET_PROC_ADDRESS_LEGACY_STREAM](crate::ffi::CU_GET_PROC_ADDRESS_LEGACY_STREAM): This will enable the search for all driver symbols\n   that match the requested driver symbol name except the corresponding per-thread versions.\n - [CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM](crate::ffi::CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM): This will enable the search for all\n   driver symbols that match the requested driver symbol name including the per-thread\n   versions. If a per-thread version is not found, the API will return the legacy version\n   of the driver function.\n#### symbol:\n- The base name of the driver API function to look for. As an example,\n                 for the driver API [cuMemAlloc_v2](crate::ffi::cuMemAlloc_v2), `symbol` would be cuMemAlloc and\n                 `cudaVersion` would be the ABI compatible CUDA version for the _v2 variant.\n#### pfn:\n- Location to return the function pointer to the requested driver function\n#### cudaVersion:\n- The CUDA version to look for the requested driver symbol\n#### flags:\n-  Flags to specify search options.\n#### symbolStatus:\n- Optional location to store the status of the search for\n                       `symbol` based on `cudaVersion`. See [CUdriverProcAddressQueryResult](crate::ffi::CUdriverProcAddressQueryResult)\n                       for possible values.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n### Note:\n \\note_version_mixing\n\n ### See also:\n\n [cudaGetDriverEntryPoint](crate::ffi::cudaGetDriverEntryPoint)\n"]
    pub fn cuGetProcAddress_v2(
        symbol: *const ::std::ffi::c_char,
        pfn: *mut *mut ::std::ffi::c_void,
        cudaVersion: ::std::ffi::c_int,
        flags: cuuint64_t,
        symbolStatus: *mut CUdriverProcAddressQueryResult,
    ) -> CUresult;
}
#[repr(u32)]
#[doc = " Flags for choosing a coredump attribute to get/set\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUcoredumpSettings_enum {
    CU_COREDUMP_ENABLE_ON_EXCEPTION = 1,
    CU_COREDUMP_TRIGGER_HOST = 2,
    CU_COREDUMP_LIGHTWEIGHT = 3,
    CU_COREDUMP_ENABLE_USER_TRIGGER = 4,
    CU_COREDUMP_FILE = 5,
    CU_COREDUMP_PIPE = 6,
    CU_COREDUMP_GENERATION_FLAGS = 7,
    CU_COREDUMP_MAX = 8,
}
#[doc = " Flags for choosing a coredump attribute to get/set\n"]
pub use self::CUcoredumpSettings_enum as CUcoredumpSettings;
#[repr(u32)]
#[doc = " Flags for controlling coredump contents\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUCoredumpGenerationFlags {
    CU_COREDUMP_DEFAULT_FLAGS = 0,
    CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES = 1,
    CU_COREDUMP_SKIP_GLOBAL_MEMORY = 2,
    CU_COREDUMP_SKIP_SHARED_MEMORY = 4,
    CU_COREDUMP_SKIP_LOCAL_MEMORY = 8,
    CU_COREDUMP_SKIP_ABORT = 16,
    CU_COREDUMP_SKIP_CONSTBANK_MEMORY = 32,
    CU_COREDUMP_LIGHTWEIGHT_FLAGS = 47,
}
unsafe extern "C" {
    #[doc = " Allows caller to fetch a coredump attribute value for the current context\n\n Returns in `*value` the requested value specified by `attrib`. It is up to the caller\n to ensure that the data type and size of `*value` matches the request.\n\n If the caller calls this function with `*value` equal to NULL, the size of the memory\n region (in bytes) expected for `attrib` will be placed in `size`.\n\n The supported attributes are:\n - [CU_COREDUMP_ENABLE_ON_EXCEPTION](crate::ffi::CU_COREDUMP_ENABLE_ON_EXCEPTION): Bool where [true](crate::ffi::true) means that GPU exceptions from\n      this context will create a coredump at the location specified by [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE).\n      The default value is [false](crate::ffi::false) unless set to [true](crate::ffi::true) globally or locally, or the\n      CU_CTX_USER_COREDUMP_ENABLE flag was set during context creation.\n - [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST): Bool where [true](crate::ffi::true) means that the host CPU will\n      also create a coredump. The default value is [true](crate::ffi::true) unless set to [false](crate::ffi::false) globally or\n      or locally. This value is deprecated as of CUDA 12.5 - raise the [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT)\n      flag to disable host device abort() if needed.\n - [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT): Bool where [true](crate::ffi::true) means that any resulting coredumps\n      will not have a dump of GPU memory or non-reloc ELF images. The default value is\n      [false](crate::ffi::false) unless set to [true](crate::ffi::true) globally or locally. This attribute is deprecated as\n      of CUDA 12.5, please use [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS) instead.\n - [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER): Bool where [true](crate::ffi::true) means that a coredump can be\n      created by writing to the system pipe specified by [CU_COREDUMP_PIPE](crate::ffi::CU_COREDUMP_PIPE). The default\n      value is [false](crate::ffi::false) unless set to [true](crate::ffi::true) globally or locally.\n - [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE): String of up to 1023 characters that defines the location where\n      any coredumps generated by this context will be written. The default value is\n      [core](crate::ffi::core).cuda.HOSTNAME.PID where [HOSTNAME](crate::ffi::HOSTNAME) is the host name of the machine running\n      the CUDA applications and [PID](crate::ffi::PID) is the process ID of the CUDA application.\n - [CU_COREDUMP_PIPE](crate::ffi::CU_COREDUMP_PIPE): String of up to 1023 characters that defines the name of the pipe\n      that will be monitored if user-triggered coredumps are enabled. The default value is\n      [corepipe](crate::ffi::corepipe).cuda.HOSTNAME.PID where [HOSTNAME](crate::ffi::HOSTNAME) is the host name of the machine running\n      the CUDA application and [PID](crate::ffi::PID) is the process ID of the CUDA application.\n - [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS): An integer with values to allow granular control the data\n      contained in a coredump specified as a bitwise OR combination of the following values:\n      + [CU_COREDUMP_DEFAULT_FLAGS](crate::ffi::CU_COREDUMP_DEFAULT_FLAGS) - if set by itself, coredump generation returns to its\n          default settings of including all memory regions that it is able to access\n      + [CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES](crate::ffi::CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES) - Coredump will not include the data from\n          CUDA source modules that are not relocated at runtime.\n      + [CU_COREDUMP_SKIP_GLOBAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_GLOBAL_MEMORY) - Coredump will not include device-side global data\n          that does not belong to any context.\n      + [CU_COREDUMP_SKIP_SHARED_MEMORY](crate::ffi::CU_COREDUMP_SKIP_SHARED_MEMORY) - Coredump will not include grid-scale shared memory\n          for the warp that the dumped kernel belonged to.\n      + [CU_COREDUMP_SKIP_LOCAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_LOCAL_MEMORY) - Coredump will not include local memory from the kernel.\n      + [CU_COREDUMP_LIGHTWEIGHT_FLAGS](crate::ffi::CU_COREDUMP_LIGHTWEIGHT_FLAGS) - Enables all of the above options. Equiavlent to setting\n          the [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT) attribute to [true](crate::ffi::true).\n      + [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT) - If set, GPU exceptions will not raise an abort() in the host CPU\n          process. Same functional goal as [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST) but better reflects the default\n          behavior.\n#### attrib:\n- The enum defining which value to fetch.\n#### value:\n- void* containing the requested data.\n#### size:\n- The size of the memory region `value` points to.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n\n ### See also:\n\n [cuCoredumpGetAttributeGlobal](crate::ffi::cuCoredumpGetAttributeGlobal),\n [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute),\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal)\n"]
    pub fn cuCoredumpGetAttribute(
        attrib: CUcoredumpSettings,
        value: *mut ::std::ffi::c_void,
        size: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allows caller to fetch a coredump attribute value for the entire application\n\n Returns in `*value` the requested value specified by `attrib`. It is up to the caller\n to ensure that the data type and size of `*value` matches the request.\n\n If the caller calls this function with `*value` equal to NULL, the size of the memory\n region (in bytes) expected for `attrib` will be placed in `size`.\n\n The supported attributes are:\n - [CU_COREDUMP_ENABLE_ON_EXCEPTION](crate::ffi::CU_COREDUMP_ENABLE_ON_EXCEPTION): Bool where [true](crate::ffi::true) means that GPU exceptions from\n      this context will create a coredump at the location specified by [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE).\n      The default value is [false](crate::ffi::false).\n - [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST): Bool where [true](crate::ffi::true) means that the host CPU will\n      also create a coredump. The default value is [true](crate::ffi::true) unless set to [false](crate::ffi::false) globally or\n      or locally. This value is deprecated as of CUDA 12.5 - raise the [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT)\n      flag to disable host device abort() if needed.\n - [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT): Bool where [true](crate::ffi::true) means that any resulting coredumps\n      will not have a dump of GPU memory or non-reloc ELF images. The default value is\n      [false](crate::ffi::false). This attribute is deprecated as of CUDA 12.5, please use [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS)\n      instead.\n - [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER): Bool where [true](crate::ffi::true) means that a coredump can be\n      created by writing to the system pipe specified by [CU_COREDUMP_PIPE](crate::ffi::CU_COREDUMP_PIPE). The default\n      value is [false](crate::ffi::false).\n - [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE): String of up to 1023 characters that defines the location where\n      any coredumps generated by this context will be written. The default value is\n      [core](crate::ffi::core).cuda.HOSTNAME.PID where [HOSTNAME](crate::ffi::HOSTNAME) is the host name of the machine running\n      the CUDA applications and [PID](crate::ffi::PID) is the process ID of the CUDA application.\n - [CU_COREDUMP_PIPE](crate::ffi::CU_COREDUMP_PIPE): String of up to 1023 characters that defines the name of the pipe\n      that will be monitored if user-triggered coredumps are enabled. The default value is\n      [corepipe](crate::ffi::corepipe).cuda.HOSTNAME.PID where [HOSTNAME](crate::ffi::HOSTNAME) is the host name of the machine running\n      the CUDA application and [PID](crate::ffi::PID) is the process ID of the CUDA application.\n - [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS): An integer with values to allow granular control the data\n      contained in a coredump specified as a bitwise OR combination of the following values:\n      + [CU_COREDUMP_DEFAULT_FLAGS](crate::ffi::CU_COREDUMP_DEFAULT_FLAGS) - if set by itself, coredump generation returns to its\n          default settings of including all memory regions that it is able to access\n      + [CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES](crate::ffi::CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES) - Coredump will not include the data from\n          CUDA source modules that are not relocated at runtime.\n      + [CU_COREDUMP_SKIP_GLOBAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_GLOBAL_MEMORY) - Coredump will not include device-side global data\n          that does not belong to any context.\n      + [CU_COREDUMP_SKIP_SHARED_MEMORY](crate::ffi::CU_COREDUMP_SKIP_SHARED_MEMORY) - Coredump will not include grid-scale shared memory\n          for the warp that the dumped kernel belonged to.\n      + [CU_COREDUMP_SKIP_LOCAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_LOCAL_MEMORY) - Coredump will not include local memory from the kernel.\n      + [CU_COREDUMP_LIGHTWEIGHT_FLAGS](crate::ffi::CU_COREDUMP_LIGHTWEIGHT_FLAGS) - Enables all of the above options. Equiavlent to setting\n          the [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT) attribute to [true](crate::ffi::true).\n      + [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT) - If set, GPU exceptions will not raise an abort() in the host CPU\n          process. Same functional goal as [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST) but better reflects the default\n          behavior.\n#### attrib:\n- The enum defining which value to fetch.\n#### value:\n- void* containing the requested data.\n#### size:\n- The size of the memory region `value` points to.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuCoredumpGetAttribute](crate::ffi::cuCoredumpGetAttribute),\n [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute),\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal)\n"]
    pub fn cuCoredumpGetAttributeGlobal(
        attrib: CUcoredumpSettings,
        value: *mut ::std::ffi::c_void,
        size: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allows caller to set a coredump attribute value for the current context\n\n This function should be considered an alternate interface to the CUDA-GDB environment\n variables defined in this document: https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump\n\n An important design decision to note is that any coredump environment variable values\n set before CUDA initializes will take permanent precedence over any values set with this\n function. This decision was made to ensure no change in behavior for any users that\n may be currently using these variables to get coredumps.\n\n `*value` shall contain the requested value specified by `set`. It is up to the caller\n to ensure that the data type and size of `*value` matches the request.\n\n If the caller calls this function with `*value` equal to NULL, the size of the memory\n region (in bytes) expected for `set` will be placed in `size`.\n\n /note This function will return [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED) if the caller attempts to set\n [CU_COREDUMP_ENABLE_ON_EXCEPTION](crate::ffi::CU_COREDUMP_ENABLE_ON_EXCEPTION) on a GPU of with Compute Capability < 6.0. [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal)\n works on those platforms as an alternative.\n\n /note [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER) and [CU_COREDUMP_PIPE](crate::ffi::CU_COREDUMP_PIPE) cannot be set on a per-context basis.\n\n The supported attributes are:\n - [CU_COREDUMP_ENABLE_ON_EXCEPTION](crate::ffi::CU_COREDUMP_ENABLE_ON_EXCEPTION): Bool where [true](crate::ffi::true) means that GPU exceptions from\n      this context will create a coredump at the location specified by [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE).\n      The default value is [false](crate::ffi::false).\n - [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST): Bool where [true](crate::ffi::true) means that the host CPU will\n      also create a coredump. The default value is [true](crate::ffi::true) unless set to [false](crate::ffi::false) globally or\n      or locally. This value is deprecated as of CUDA 12.5 - raise the [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT)\n      flag to disable host device abort() if needed.\n - [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT): Bool where [true](crate::ffi::true) means that any resulting coredumps\n      will not have a dump of GPU memory or non-reloc ELF images. The default value is\n      [false](crate::ffi::false). This attribute is deprecated as of CUDA 12.5, please use [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS)\n      instead.\n - [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE): String of up to 1023 characters that defines the location where\n      any coredumps generated by this context will be written. The default value is\n      [core](crate::ffi::core).cuda.HOSTNAME.PID where [HOSTNAME](crate::ffi::HOSTNAME) is the host name of the machine running\n      the CUDA applications and [PID](crate::ffi::PID) is the process ID of the CUDA application.\n - [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS): An integer with values to allow granular control the data\n      contained in a coredump specified as a bitwise OR combination of the following values:\n      + [CU_COREDUMP_DEFAULT_FLAGS](crate::ffi::CU_COREDUMP_DEFAULT_FLAGS) - if set by itself, coredump generation returns to its\n          default settings of including all memory regions that it is able to access\n      + [CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES](crate::ffi::CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES) - Coredump will not include the data from\n          CUDA source modules that are not relocated at runtime.\n      + [CU_COREDUMP_SKIP_GLOBAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_GLOBAL_MEMORY) - Coredump will not include device-side global data\n          that does not belong to any context.\n      + [CU_COREDUMP_SKIP_SHARED_MEMORY](crate::ffi::CU_COREDUMP_SKIP_SHARED_MEMORY) - Coredump will not include grid-scale shared memory\n          for the warp that the dumped kernel belonged to.\n      + [CU_COREDUMP_SKIP_LOCAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_LOCAL_MEMORY) - Coredump will not include local memory from the kernel.\n      + [CU_COREDUMP_LIGHTWEIGHT_FLAGS](crate::ffi::CU_COREDUMP_LIGHTWEIGHT_FLAGS) - Enables all of the above options. Equiavlent to setting\n          the [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT) attribute to [true](crate::ffi::true).\n      + [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT) - If set, GPU exceptions will not raise an abort() in the host CPU\n          process. Same functional goal as [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST) but better reflects the default\n          behavior.\n#### attrib:\n- The enum defining which value to set.\n#### value:\n- void* containing the requested data.\n#### size:\n- The size of the memory region `value` points to.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n\n [cuCoredumpGetAttributeGlobal](crate::ffi::cuCoredumpGetAttributeGlobal),\n [cuCoredumpGetAttribute](crate::ffi::cuCoredumpGetAttribute),\n [cuCoredumpSetAttributeGlobal](crate::ffi::cuCoredumpSetAttributeGlobal)\n"]
    pub fn cuCoredumpSetAttribute(
        attrib: CUcoredumpSettings,
        value: *mut ::std::ffi::c_void,
        size: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Allows caller to set a coredump attribute value globally\n\n This function should be considered an alternate interface to the CUDA-GDB environment\n variables defined in this document: https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump\n\n An important design decision to note is that any coredump environment variable values\n set before CUDA initializes will take permanent precedence over any values set with this\n function. This decision was made to ensure no change in behavior for any users that\n may be currently using these variables to get coredumps.\n\n `*value` shall contain the requested value specified by `set`. It is up to the caller\n to ensure that the data type and size of `*value` matches the request.\n\n If the caller calls this function with `*value` equal to NULL, the size of the memory\n region (in bytes) expected for `set` will be placed in `size`.\n\n The supported attributes are:\n - [CU_COREDUMP_ENABLE_ON_EXCEPTION](crate::ffi::CU_COREDUMP_ENABLE_ON_EXCEPTION): Bool where [true](crate::ffi::true) means that GPU exceptions from\n      this context will create a coredump at the location specified by [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE).\n      The default value is [false](crate::ffi::false).\n - [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST): Bool where [true](crate::ffi::true) means that the host CPU will\n      also create a coredump. The default value is [true](crate::ffi::true) unless set to [false](crate::ffi::false) globally or\n      or locally. This value is deprecated as of CUDA 12.5 - raise the [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT)\n      flag to disable host device abort() if needed.\n - [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT): Bool where [true](crate::ffi::true) means that any resulting coredumps\n      will not have a dump of GPU memory or non-reloc ELF images. The default value is\n      [false](crate::ffi::false). This attribute is deprecated as of CUDA 12.5, please use [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS)\n      instead.\n - [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER): Bool where [true](crate::ffi::true) means that a coredump can be\n      created by writing to the system pipe specified by [CU_COREDUMP_PIPE](crate::ffi::CU_COREDUMP_PIPE). The default\n      value is [false](crate::ffi::false).\n - [CU_COREDUMP_FILE](crate::ffi::CU_COREDUMP_FILE): String of up to 1023 characters that defines the location where\n      any coredumps generated by this context will be written. The default value is\n      [core](crate::ffi::core).cuda.HOSTNAME.PID where [HOSTNAME](crate::ffi::HOSTNAME) is the host name of the machine running\n      the CUDA applications and [PID](crate::ffi::PID) is the process ID of the CUDA application.\n - [CU_COREDUMP_PIPE](crate::ffi::CU_COREDUMP_PIPE): String of up to 1023 characters that defines the name of the pipe\n      that will be monitored if user-triggered coredumps are enabled. This value may not be\n      changed after [CU_COREDUMP_ENABLE_USER_TRIGGER](crate::ffi::CU_COREDUMP_ENABLE_USER_TRIGGER) is set to [true](crate::ffi::true). The default\n      value is [corepipe](crate::ffi::corepipe).cuda.HOSTNAME.PID where [HOSTNAME](crate::ffi::HOSTNAME) is the host name of the machine\n      running the CUDA application and [PID](crate::ffi::PID) is the process ID of the CUDA application.\n - [CU_COREDUMP_GENERATION_FLAGS](crate::ffi::CU_COREDUMP_GENERATION_FLAGS): An integer with values to allow granular control the data\n      contained in a coredump specified as a bitwise OR combination of the following values:\n      + [CU_COREDUMP_DEFAULT_FLAGS](crate::ffi::CU_COREDUMP_DEFAULT_FLAGS) - if set by itself, coredump generation returns to its\n          default settings of including all memory regions that it is able to access\n      + [CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES](crate::ffi::CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES) - Coredump will not include the data from\n          CUDA source modules that are not relocated at runtime.\n      + [CU_COREDUMP_SKIP_GLOBAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_GLOBAL_MEMORY) - Coredump will not include device-side global data\n          that does not belong to any context.\n      + [CU_COREDUMP_SKIP_SHARED_MEMORY](crate::ffi::CU_COREDUMP_SKIP_SHARED_MEMORY) - Coredump will not include grid-scale shared memory\n          for the warp that the dumped kernel belonged to.\n      + [CU_COREDUMP_SKIP_LOCAL_MEMORY](crate::ffi::CU_COREDUMP_SKIP_LOCAL_MEMORY) - Coredump will not include local memory from the kernel.\n      + [CU_COREDUMP_LIGHTWEIGHT_FLAGS](crate::ffi::CU_COREDUMP_LIGHTWEIGHT_FLAGS) - Enables all of the above options. Equiavlent to setting\n          the [CU_COREDUMP_LIGHTWEIGHT](crate::ffi::CU_COREDUMP_LIGHTWEIGHT) attribute to [true](crate::ffi::true).\n      + [CU_COREDUMP_SKIP_ABORT](crate::ffi::CU_COREDUMP_SKIP_ABORT) - If set, GPU exceptions will not raise an abort() in the host CPU\n          process. Same functional goal as [CU_COREDUMP_TRIGGER_HOST](crate::ffi::CU_COREDUMP_TRIGGER_HOST) but better reflects the default\n          behavior.\n#### attrib:\n- The enum defining which value to set.\n#### value:\n- void* containing the requested data.\n#### size:\n- The size of the memory region `value` points to.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_PERMITTED](crate::ffi::CUDA_ERROR_NOT_PERMITTED)\n\n ### See also:\n\n [cuCoredumpGetAttribute](crate::ffi::cuCoredumpGetAttribute),\n [cuCoredumpGetAttributeGlobal](crate::ffi::cuCoredumpGetAttributeGlobal),\n [cuCoredumpSetAttribute](crate::ffi::cuCoredumpSetAttribute)\n"]
    pub fn cuCoredumpSetAttributeGlobal(
        attrib: CUcoredumpSettings,
        value: *mut ::std::ffi::c_void,
        size: *mut usize,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " @}\n"]
    pub fn cuGetExportTable(
        ppExportTable: *mut *const ::std::ffi::c_void,
        pExportTableId: *const CUuuid,
    ) -> CUresult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUdevResourceDesc_st {
    _unused: [u8; 0],
}
#[doc = " \\typedef struct CUdevResourceDesc_st* CUdevResourceDesc;\n An opaque descriptor handle. The descriptor encapsulates multiple created and configured resources.\n Created via [cuDevResourceGenerateDesc](crate::ffi::cuDevResourceGenerateDesc)\n"]
pub type CUdevResourceDesc = *mut CUdevResourceDesc_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgreenCtxCreate_flags {
    #[doc = "< Required. Creates a default stream to use inside the green context\n"]
    CU_GREEN_CTX_DEFAULT_STREAM = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdevSmResourceSplit_flags {
    CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING = 1,
    CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE = 2,
}
#[repr(u32)]
#[doc = " \\typedef enum CUdevResourceType\n Type of resource\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdevResourceType {
    CU_DEV_RESOURCE_TYPE_INVALID = 0,
    #[doc = "< Streaming multiprocessors related information\n"]
    CU_DEV_RESOURCE_TYPE_SM = 1,
}
#[doc = " \\struct CUdevSmResource\n Data for SM-related resources\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUdevSmResource_st {
    #[doc = "< The amount of streaming multiprocessors available in this resource. This is an output parameter only, do not write to this field.\n"]
    pub smCount: ::std::ffi::c_uint,
}
#[doc = " \\struct CUdevSmResource\n Data for SM-related resources\n"]
pub type CUdevSmResource = CUdevSmResource_st;
#[doc = " \\struct CUdevResource\n A tagged union describing different resources identified by the type field. This structure should not be directly modified outside of the API that created it.\n \\code\n struct {\n     CUdevResourceType type;\n     union {\n         CUdevSmResource sm;\n     };\n };\n \\endcode\n - If `type` is `CU_DEV_RESOURCE_TYPE_INVALID`, this resoure is not valid and cannot be further accessed.\n - If `type` is `CU_DEV_RESOURCE_TYPE_SM`, the [CUdevSmResource](crate::ffi::CUdevSmResource) structure `sm` is filled in. For example,\n `sm`.smCount will reflect the amount of streaming multiprocessors available in this resource.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUdevResource_st {
    #[doc = "< Type of resource, dictates which union field was last set\n"]
    pub type_: CUdevResourceType,
    pub _internal_padding: [::std::ffi::c_uchar; 92usize],
    pub __bindgen_anon_1: CUdevResource_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUdevResource_st__bindgen_ty_1 {
    #[doc = "< Resource corresponding to CU_DEV_RESOURCE_TYPE_SM \\p. type.\n"]
    pub sm: CUdevSmResource,
    pub _oversize: [::std::ffi::c_uchar; 48usize],
}
#[doc = " \\struct CUdevResource\n A tagged union describing different resources identified by the type field. This structure should not be directly modified outside of the API that created it.\n \\code\n struct {\n     CUdevResourceType type;\n     union {\n         CUdevSmResource sm;\n     };\n };\n \\endcode\n - If `type` is `CU_DEV_RESOURCE_TYPE_INVALID`, this resoure is not valid and cannot be further accessed.\n - If `type` is `CU_DEV_RESOURCE_TYPE_SM`, the [CUdevSmResource](crate::ffi::CUdevSmResource) structure `sm` is filled in. For example,\n `sm`.smCount will reflect the amount of streaming multiprocessors available in this resource.\n"]
pub type CUdevResource_v1 = CUdevResource_st;
#[doc = " \\struct CUdevResource\n A tagged union describing different resources identified by the type field. This structure should not be directly modified outside of the API that created it.\n \\code\n struct {\n     CUdevResourceType type;\n     union {\n         CUdevSmResource sm;\n     };\n };\n \\endcode\n - If `type` is `CU_DEV_RESOURCE_TYPE_INVALID`, this resoure is not valid and cannot be further accessed.\n - If `type` is `CU_DEV_RESOURCE_TYPE_SM`, the [CUdevSmResource](crate::ffi::CUdevSmResource) structure `sm` is filled in. For example,\n `sm`.smCount will reflect the amount of streaming multiprocessors available in this resource.\n"]
pub type CUdevResource = CUdevResource_v1;
unsafe extern "C" {
    #[doc = " Creates a green context with a specified set of resources.\n\n This API creates a green context with the resources specified in the descriptor `desc` and\n returns it in the handle represented by `phCtx`. This API will retain the primary context on device `dev`,\n which will is released when the green context is destroyed. It is advised to have the primary context active\n before calling this API to avoid the heavy cost of triggering primary context initialization and\n deinitialization multiple times.\n\n The API does not set the green context current. In order to set it current, you need to explicitly set it current\n by first converting the green context to a CUcontext using [cuCtxFromGreenCtx](crate::ffi::cuCtxFromGreenCtx) and subsequently calling\n [cuCtxSetCurrent](crate::ffi::cuCtxSetCurrent) / [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent). It should be noted that a green context can be current to only one\n thread at a time. There is no internal synchronization to make API calls accessing the same green context\n from multiple threads work.\n\n Note: The API is not supported on 32-bit platforms.\n#### phCtx:\n- Pointer for the output handle to the green context\n#### desc:\n- Descriptor generated via [cuDevResourceGenerateDesc](crate::ffi::cuDevResourceGenerateDesc) which contains the set of resources to be used\n#### dev:\n- Device on which to create the green context.\n#### flags:\n- One of the supported green context creation flags. `CU_GREEN_CTX_DEFAULT_STREAM` is required.\n\n The supported flags are:\n - `CU_GREEN_CTX_DEFAULT_STREAM` : Creates a default stream to use inside the green context. Required.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n\n ### See also:\n\n [cuGreenCtxDestroy](crate::ffi::cuGreenCtxDestroy),\n [cuCtxFromGreenCtx](crate::ffi::cuCtxFromGreenCtx),\n [cuCtxSetCurrent](crate::ffi::cuCtxSetCurrent),\n [cuCtxPushCurrent](crate::ffi::cuCtxPushCurrent),\n [cuDevResourceGenerateDesc](crate::ffi::cuDevResourceGenerateDesc),\n [cuDevicePrimaryCtxRetain](crate::ffi::cuDevicePrimaryCtxRetain),\n [cuCtxCreate](crate::ffi::cuCtxCreate),\n [cuCtxCreate_v3](crate::ffi::cuCtxCreate_v3)\n"]
    pub fn cuGreenCtxCreate(
        phCtx: *mut CUgreenCtx,
        desc: CUdevResourceDesc,
        dev: CUdevice,
        flags: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Destroys a green context\n\n Destroys the green context, releasing the primary context of the device that this green context was created for.\n Any resources provisioned for this green context (that were initially available via the resource descriptor)\n are released as well.\n#### hCtx:\n- Green context to be destroyed\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_CONTEXT_IS_DESTROYED](crate::ffi::CUDA_ERROR_CONTEXT_IS_DESTROYED)\n\n ### See also:\n\n [cuGreenCtxCreate](crate::ffi::cuGreenCtxCreate),\n [cuCtxDestroy](crate::ffi::cuCtxDestroy)\n"]
    pub fn cuGreenCtxDestroy(hCtx: CUgreenCtx) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Converts a green context into the primary context\n\n The API converts a green context into the primary context returned in `pContext`. It is important\n to note that the converted context `pContext` is a normal primary context but with\n the resources of the specified green context `hCtx`. Once converted, it can then\n be used to set the context current with [cuCtxSetCurrent](crate::ffi::cuCtxSetCurrent) or with any of the CUDA APIs\n that accept a CUcontext parameter.\n\n Users are expected to call this API before calling any CUDA APIs that accept a\n CUcontext. Failing to do so will result in the APIs returning [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT).\n#### pContext:\nReturned primary context with green context resources\n#### hCtx:\nGreen context to convert\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuGreenCtxCreate](crate::ffi::cuGreenCtxCreate)\n"]
    pub fn cuCtxFromGreenCtx(pContext: *mut CUcontext, hCtx: CUgreenCtx) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get device resources\n\n Get the `type` resources available to the `device`.\n This may often be the starting point for further partitioning or configuring of resources.\n\n Note: The API is not supported on 32-bit platforms.\n#### device:\n- Device to get resource for\n#### resource:\n- Output pointer to a CUdevResource structure\n#### type:\n- Type of resource to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_RESOURCE_TYPE](crate::ffi::CUDA_ERROR_INVALID_RESOURCE_TYPE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE)\n\n ### See also:\n\n [cuDevResourceGenerateDesc](crate::ffi::cuDevResourceGenerateDesc)\n"]
    pub fn cuDeviceGetDevResource(
        device: CUdevice,
        resource: *mut CUdevResource,
        type_: CUdevResourceType,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get context resources\n\n Get the `type` resources available to the context represented by `hCtx`\n#### hCtx:\n- Context to get resource for\n\n Note: The API is not supported on 32-bit platforms.\n#### resource:\n- Output pointer to a CUdevResource structure\n#### type:\n- Type of resource to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_RESOURCE_TYPE](crate::ffi::CUDA_ERROR_INVALID_RESOURCE_TYPE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT)\n\n ### See also:\n\n [cuDevResourceGenerateDesc](crate::ffi::cuDevResourceGenerateDesc)\n"]
    pub fn cuCtxGetDevResource(
        hCtx: CUcontext,
        resource: *mut CUdevResource,
        type_: CUdevResourceType,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Get green context resources\n\n Get the `type` resources available to the green context represented by `hCtx`\n#### hCtx:\n- Green context to get resource for\n#### resource:\n- Output pointer to a CUdevResource structure\n#### type:\n- Type of resource to retrieve\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_RESOURCE_TYPE](crate::ffi::CUDA_ERROR_INVALID_RESOURCE_TYPE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n\n ### See also:\n\n [cuDevResourceGenerateDesc](crate::ffi::cuDevResourceGenerateDesc)\n"]
    pub fn cuGreenCtxGetDevResource(
        hCtx: CUgreenCtx,
        resource: *mut CUdevResource,
        type_: CUdevResourceType,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Splits `CU_DEV_RESOURCE_TYPE_SM` resources.\n\n Splits `CU_DEV_RESOURCE_TYPE_SM` resources into `nbGroups`, adhering to the minimum SM count specified in `minCount`\n and the usage flags in `useFlags`. If `result` is NULL, the API simulates a split and provides the amount of groups that\n would be created in `nbGroups`. Otherwise, `nbGroups` must point to the amount of elements in `result` and on return,\n the API will overwrite `nbGroups` with the amount actually created. The groups are written to the array in `result`.\n `nbGroups` can be less than the total amount if a smaller number of groups is needed.\n\n This API is used to spatially partition the input resource. The input resource needs to come from one of\n [cuDeviceGetDevResource](crate::ffi::cuDeviceGetDevResource), [cuCtxGetDevResource](crate::ffi::cuCtxGetDevResource), or [cuGreenCtxGetDevResource](crate::ffi::cuGreenCtxGetDevResource).\n A limitation of the API is that the output results cannot be split again without\n first creating a descriptor and a green context with that descriptor.\n\n When creating the groups, the API will take into account the performance and functional characteristics of the\n input resource, and guarantee a split that will create a disjoint set of symmetrical partitions. This may lead to fewer groups created\n than purely dividing the total SM count by the `minCount` due to cluster requirements or\n alignment and granularity requirements for the minCount.\n\n The `remainder` set does not have the same functional or performance guarantees as the groups in `result`.\n Its use should be carefully planned and future partitions of the `remainder` set are discouraged.\n\n The following flags are supported:\n - `CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING` : Lower the minimum SM count and alignment, and treat each SM independent of its hierarchy.\n  This allows more fine grained partitions but at the cost of advanced features (such as large clusters on compute capability 9.0+).\n - `CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE` : Compute Capability 9.0+ only. Attempt to create groups that may allow\n  for maximally sized thread clusters. This can be queried post green context creation using [cuOccupancyMaxPotentialClusterSize](crate::ffi::cuOccupancyMaxPotentialClusterSize).\n\n A successful API call must either have:\n - A valid array of `result` pointers of size passed in `nbGroups`, with `input` of type `CU_DEV_RESOURCE_TYPE_SM`.\n Value of `minCount` must be between 0 and the SM count specified in `input`. `remaining` may be NULL.\n - NULL passed in for `result`, with a valid integer pointer in `nbGroups` and `input` of type `CU_DEV_RESOURCE_TYPE_SM`.\n Value of `minCount` must be between 0 and the SM count specified in `input`. `remaining` may be NULL.\n This queries the number of groups that would be created by the API.\n\n Note: The API is not supported on 32-bit platforms.\n#### result:\n- Output array of `CUdevResource` resources. Can be NULL to query the number of groups.\n#### nbGroups:\n- This is a pointer, specifying the number of groups that would be or should be created as described below.\n#### input:\n- Input SM resource to be split. Must be a valid `CU_DEV_RESOURCE_TYPE_SM` resource.\n#### remaining:\n- If the input resource cannot be cleanly split among `nbGroups`, the remaining is placed in here.\n Can be ommitted (NULL) if the user does not need the remaining set.\n#### useFlags:\n- Flags specifying how these partitions are used or which constraints to abide by when splitting the input. Zero is valid for default behavior.\n#### minCount:\n- Minimum number of SMs required\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_DEVICE](crate::ffi::CUDA_ERROR_INVALID_DEVICE),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_RESOURCE_TYPE](crate::ffi::CUDA_ERROR_INVALID_RESOURCE_TYPE),\n [CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION](crate::ffi::CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION)\n\n ### See also:\n\n [cuGreenCtxGetDevResource](crate::ffi::cuGreenCtxGetDevResource),\n [cuCtxGetDevResource](crate::ffi::cuCtxGetDevResource),\n [cuDeviceGetDevResource](crate::ffi::cuDeviceGetDevResource)\n"]
    pub fn cuDevSmResourceSplitByCount(
        result: *mut CUdevResource,
        nbGroups: *mut ::std::ffi::c_uint,
        input: *const CUdevResource,
        remaining: *mut CUdevResource,
        useFlags: ::std::ffi::c_uint,
        minCount: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Generate a resource descriptor\n\n Generates a single resource descriptor with the set of resources specified in `resources`.\n The generated resource descriptor is necessary for the creation of green contexts via the [cuGreenCtxCreate](crate::ffi::cuGreenCtxCreate) API.\n Resources of the same type can be passed in, provided they meet the requirements as noted below.\n\n A successful API call must have:\n - A valid output pointer for the `phDesc` descriptor as well as a valid array of `resources` pointers,\n with the array size passed in `nbResources`.\n If multiple resources are provided in `resources`, the device they came from must be the same,\n otherwise CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned.\n If multiple resources are provided in `resources` and they are of type [CU_DEV_RESOURCE_TYPE_SM](crate::ffi::CU_DEV_RESOURCE_TYPE_SM),\n they must be outputs (whether `result` or `remaining`) from the same split API instance,\n otherwise CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned.\n\n Note: The API is not supported on 32-bit platforms.\n#### phDesc:\n- Output descriptor\n#### resources:\n- Array of resources to be included in the descriptor\n#### nbResources:\n- Number of resources passed in `resources`\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_INVALID_RESOURCE_TYPE](crate::ffi::CUDA_ERROR_INVALID_RESOURCE_TYPE),\n [CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION](crate::ffi::CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION)\n\n ### See also:\n\n [cuDevSmResourceSplitByCount](crate::ffi::cuDevSmResourceSplitByCount)\n"]
    pub fn cuDevResourceGenerateDesc(
        phDesc: *mut CUdevResourceDesc,
        resources: *mut CUdevResource,
        nbResources: ::std::ffi::c_uint,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Records an event.\n\n Captures in `hEvent` all the activities of the green context of `hCtx`\n at the time of this call. `hEvent` and `hCtx` must be from the same\n primary context otherwise [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE) is returned.\n Calls such as [cuEventQuery](crate::ffi::cuEventQuery)() or [cuGreenCtxWaitEvent](crate::ffi::cuGreenCtxWaitEvent)() will\n then examine or wait for completion of the work that was captured. Uses of\n `hCtx` after this call do not modify `hEvent`.\n\n### Note:\n ### Note:\nThe API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED) if the\n specified green context `hCtx` has a stream in the capture mode. In such\n a case, the call will invalidate all the conflicting captures.\n#### hCtx:\n- Green context to record event for\n#### hEvent:\n- Event to record\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED)\n\n ### See also:\n\n [cuGreenCtxWaitEvent](crate::ffi::cuGreenCtxWaitEvent),\n [cuEventRecord](crate::ffi::cuEventRecord),\n [cuCtxRecordEvent](crate::ffi::cuCtxRecordEvent),\n [cuCtxWaitEvent](crate::ffi::cuCtxWaitEvent)\n"]
    pub fn cuGreenCtxRecordEvent(hCtx: CUgreenCtx, hEvent: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Make a green context wait on an event\n\n Makes all future work submitted to green context `hCtx` wait for all work\n captured in `hEvent`. The synchronization will be performed on the device\n and will not block the calling CPU thread. See [cuGreenCtxRecordEvent](crate::ffi::cuGreenCtxRecordEvent)()\n or [cuEventRecord](crate::ffi::cuEventRecord)(), for details on what is captured by an event.\n\n### Note:\n ### Note:\n`hEvent` may be from a different context or device than `hCtx`.\n\n ### Note:\nThe API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED) and\n invalidate the capture if the specified event `hEvent` is part of an\n ongoing capture sequence or if the specified green context `hCtx` has\n a stream in the capture mode.\n#### hCtx:\n- Green context to wait\n#### hEvent:\n- Event to wait on\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](crate::ffi::CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED)\n\n ### See also:\n\n [cuGreenCtxRecordEvent](crate::ffi::cuGreenCtxRecordEvent),\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent)\n [cuCtxRecordEvent](crate::ffi::cuCtxRecordEvent),\n [cuCtxWaitEvent](crate::ffi::cuCtxWaitEvent)\n"]
    pub fn cuGreenCtxWaitEvent(hCtx: CUgreenCtx, hEvent: CUevent) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Query the green context associated with a stream\n\n Returns the CUDA green context that the stream is associated with, or NULL if the stream\n is not associated with any green context.\n\n The stream handle `hStream` can refer to any of the following:\n <ul>\n   <li>\n   a stream created via any of the CUDA driver APIs such as [cuStreamCreate](crate::ffi::cuStreamCreate), [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority)\n   and [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate), or their runtime API equivalents such as\n   [cudaStreamCreate](crate::ffi::cudaStreamCreate), [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags) and [cudaStreamCreateWithPriority](crate::ffi::cudaStreamCreateWithPriority).\n   If during stream creation the context that was active in the calling thread was obtained\n   with cuCtxFromGreenCtx, that green context is returned in `phCtx`.\n   Otherwise, `*phCtx` is set to NULL instead.\n   </li>\n   <li>\n   special stream such as the NULL stream or [CU_STREAM_LEGACY](crate::ffi::CU_STREAM_LEGACY).\n   In that case if context that is active in the calling thread was obtained\n   with cuCtxFromGreenCtx, that green context is returned.\n   Otherwise, `*phCtx` is set to NULL instead.\n   </li>\n </ul>\n Passing an invalid handle will result in undefined behavior.\n#### hStream:\n- Handle to the stream to be queried\n#### phCtx:\n- Returned green context associated with the stream\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_HANDLE](crate::ffi::CUDA_ERROR_INVALID_HANDLE),\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamCreateWithPriority](crate::ffi::cuStreamCreateWithPriority),\n [cuStreamGetCtx_v2](crate::ffi::cuStreamGetCtx_v2),\n [cuGreenCtxStreamCreate](crate::ffi::cuGreenCtxStreamCreate),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags),\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamCreate](crate::ffi::cudaStreamCreate),\n [cudaStreamCreateWithFlags](crate::ffi::cudaStreamCreateWithFlags)\n"]
    pub fn cuStreamGetGreenCtx(hStream: CUstream, phCtx: *mut CUgreenCtx) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Create a stream for use in the green context\n\n Creates a stream for use in the specified green context `greenCtx` and returns a handle in `phStream`.\n The stream can be destroyed by calling [cuStreamDestroy](crate::ffi::cuStreamDestroy)(). Note that the API ignores the context that\n is current to the calling thread and creates a stream in the specified green context `greenCtx`.\n\n The supported values for `flags` are:\n - [CU_STREAM_NON_BLOCKING](crate::ffi::CU_STREAM_NON_BLOCKING): This must be specified. It indicates that work running in the created\n   stream may run concurrently with work in the default stream, and that\n   the created stream should perform no implicit synchronization with the default stream.\n\n Specifying `priority` affects the scheduling priority of work in the stream. Priorities provide a\n hint to preferentially run work with higher priority when possible, but do not preempt\n already-running work or provide any other functional guarantee on execution order.\n `priority` follows a convention where lower numbers represent higher priorities.\n '0' represents default priority. The range of meaningful numerical priorities can\n be queried using [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange). If the specified priority is\n outside the numerical range returned by [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n it will automatically be clamped to the lowest or the highest number in the range.\n#### phStream:\n- Returned newly created stream\n#### greenCtx:\n- Green context for which to create the stream for\n#### flags:\n- Flags for stream creation. `CU_STREAM_NON_BLOCKING` must be specified.\n#### priority:\n- Stream priority. Lower numbers represent higher priorities.\n                   See [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange) for more information about\n                   meaningful stream priorities that can be passed.\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS),\n [CUDA_ERROR_DEINITIALIZED](crate::ffi::CUDA_ERROR_DEINITIALIZED),\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED),\n [CUDA_ERROR_INVALID_CONTEXT](crate::ffi::CUDA_ERROR_INVALID_CONTEXT),\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE),\n [CUDA_ERROR_OUT_OF_MEMORY](crate::ffi::CUDA_ERROR_OUT_OF_MEMORY)\n### Note:\n Note that this function may also return error codes from previous, asynchronous launches.\n\n\n ### Note:\nIn the current implementation, only compute kernels launched in\n priority streams are affected by the stream's priority. Stream priorities have\n no effect on host-to-device and device-to-host memory operations.\n\n ### See also:\n [cuStreamDestroy](crate::ffi::cuStreamDestroy),\n [cuGreenCtxCreate](crate::ffi::cuGreenCtxCreate)\n [cuStreamCreate](crate::ffi::cuStreamCreate),\n [cuStreamGetPriority](crate::ffi::cuStreamGetPriority),\n [cuCtxGetStreamPriorityRange](crate::ffi::cuCtxGetStreamPriorityRange),\n [cuStreamGetFlags](crate::ffi::cuStreamGetFlags),\n [cuStreamGetDevice](crate::ffi::cuStreamGetDevice)\n [cuStreamWaitEvent](crate::ffi::cuStreamWaitEvent),\n [cuStreamQuery](crate::ffi::cuStreamQuery),\n [cuStreamSynchronize](crate::ffi::cuStreamSynchronize),\n [cuStreamAddCallback](crate::ffi::cuStreamAddCallback),\n [cudaStreamCreateWithPriority](crate::ffi::cudaStreamCreateWithPriority)\n"]
    pub fn cuGreenCtxStreamCreate(
        phStream: *mut CUstream,
        greenCtx: CUgreenCtx,
        flags: ::std::ffi::c_uint,
        priority: ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the restore thread ID for a CUDA process\n\n Returns in `*tid` the thread ID of the CUDA restore thread for the process\n specified by `pid`.\n#### pid:\n- The process ID of the CUDA process\n#### tid:\n- Returned restore thread ID\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n"]
    pub fn cuCheckpointProcessGetRestoreThreadId(
        pid: ::std::ffi::c_int,
        tid: *mut ::std::ffi::c_int,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Returns the process state of a CUDA process\n\n Returns in `*state` the current state of the CUDA process specified by `pid`.\n#### pid:\n- The process ID of the CUDA process\n#### state:\n- Returned CUDA process state\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n"]
    pub fn cuCheckpointProcessGetState(
        pid: ::std::ffi::c_int,
        state: *mut CUprocessState,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Lock a running CUDA process\n\n Lock the CUDA process specified by `pid` which will block further CUDA API\n calls. Process must be in the RUNNING state in order to lock.\n\n Upon successful return the process will be in the LOCKED state.\n\n If timeoutMs is specified and the timeout is reached the process will be left\n in the RUNNING state upon return.\n#### pid:\n- The process ID of the CUDA process\n#### args:\n- Optional lock operation arguments\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n [CUDA_ERROR_NOT_READY](crate::ffi::CUDA_ERROR_NOT_READY)\n"]
    pub fn cuCheckpointProcessLock(
        pid: ::std::ffi::c_int,
        args: *mut CUcheckpointLockArgs,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Checkpoint a CUDA process's GPU memory contents\n\n Checkpoints a CUDA process specified by `pid` that is in the LOCKED\n state. The GPU memory contents will be brought into host memory and all\n underlying references will be released. Process must be in the LOCKED state\n to checkpoint.\n\n Upon successful return the process will be in the CHECKPOINTED state.\n#### pid:\n- The process ID of the CUDA process\n#### args:\n- Optional checkpoint operation arguments\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n"]
    pub fn cuCheckpointProcessCheckpoint(
        pid: ::std::ffi::c_int,
        args: *mut CUcheckpointCheckpointArgs,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Restore a CUDA process's GPU memory contents from its last checkpoint\n\n Restores a CUDA process specified by `pid` from its last checkpoint. Process\n must be in the CHECKPOINTED state to restore.\n\n Upon successful return the process will be in the LOCKED state.\n\n CUDA process restore requires persistence mode to be enabled or [cuInit](crate::ffi::cuInit) to\n have been called before execution.\n#### pid:\n- The process ID of the CUDA process\n#### args:\n- Optional restore operation arguments\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n\n ### See also:\n\n [cuInit](crate::ffi::cuInit)\n"]
    pub fn cuCheckpointProcessRestore(
        pid: ::std::ffi::c_int,
        args: *mut CUcheckpointRestoreArgs,
    ) -> CUresult;
}
unsafe extern "C" {
    #[doc = " Unlock a CUDA process to allow CUDA API calls\n\n Unlocks a process specified by `pid` allowing it to resume making CUDA API\n calls. Process must be in the LOCKED state.\n\n Upon successful return the process will be in the RUNNING state.\n#### pid:\n- The process ID of the CUDA process\n#### args:\n- Optional unlock operation arguments\n### Returns:\n[CUDA_SUCCESS](crate::ffi::CUDA_SUCCESS)\n [CUDA_ERROR_INVALID_VALUE](crate::ffi::CUDA_ERROR_INVALID_VALUE)\n [CUDA_ERROR_NOT_INITIALIZED](crate::ffi::CUDA_ERROR_NOT_INITIALIZED)\n [CUDA_ERROR_ILLEGAL_STATE](crate::ffi::CUDA_ERROR_ILLEGAL_STATE)\n [CUDA_ERROR_NOT_SUPPORTED](crate::ffi::CUDA_ERROR_NOT_SUPPORTED)\n"]
    pub fn cuCheckpointProcessUnlock(
        pid: ::std::ffi::c_int,
        args: *mut CUcheckpointUnlockArgs,
    ) -> CUresult;
}
